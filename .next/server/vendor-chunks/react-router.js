"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/react-router";
exports.ids = ["vendor-chunks/react-router"];
exports.modules = {

/***/ "(ssr)/./node_modules/react-router/dist/development/index.js":
/*!*************************************************************!*\
  !*** ./node_modules/react-router/dist/development/index.js ***!
  \*************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/**\n * react-router v7.1.0\n *\n * Copyright (c) Remix Software Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE.md file in the root directory of this source tree.\n *\n * @license MIT\n */\n\nvar __create = Object.create;\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __getProtoOf = Object.getPrototypeOf;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __export = (target, all) => {\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\nvar __copyProps = (to, from, except, desc) => {\n  if (from && typeof from === \"object\" || typeof from === \"function\") {\n    for (let key of __getOwnPropNames(from))\n      if (!__hasOwnProp.call(to, key) && key !== except)\n        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });\n  }\n  return to;\n};\nvar __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(\n  // If the importer is in node compatibility mode or this is not an ESM\n  // file that has been converted to a CommonJS file using a Babel-\n  // compatible transform (i.e. \"__esModule\" has not been set), then set\n  // \"default\" to the CommonJS \"module.exports\" for node compatibility.\n  isNodeMode || !mod || !mod.__esModule ? __defProp(target, \"default\", { value: mod, enumerable: true }) : target,\n  mod\n));\nvar __toCommonJS = (mod) => __copyProps(__defProp({}, \"__esModule\", { value: true }), mod);\n\n// index.ts\nvar react_router_exports = {};\n__export(react_router_exports, {\n  Await: () => Await,\n  BrowserRouter: () => BrowserRouter,\n  Form: () => Form,\n  HashRouter: () => HashRouter,\n  IDLE_BLOCKER: () => IDLE_BLOCKER,\n  IDLE_FETCHER: () => IDLE_FETCHER,\n  IDLE_NAVIGATION: () => IDLE_NAVIGATION,\n  Link: () => Link,\n  Links: () => Links,\n  MemoryRouter: () => MemoryRouter,\n  Meta: () => Meta,\n  NavLink: () => NavLink,\n  Navigate: () => Navigate,\n  NavigationType: () => Action,\n  Outlet: () => Outlet,\n  PrefetchPageLinks: () => PrefetchPageLinks,\n  Route: () => Route,\n  Router: () => Router,\n  RouterProvider: () => RouterProvider,\n  Routes: () => Routes,\n  Scripts: () => Scripts,\n  ScrollRestoration: () => ScrollRestoration,\n  ServerRouter: () => ServerRouter,\n  StaticRouter: () => StaticRouter,\n  StaticRouterProvider: () => StaticRouterProvider,\n  UNSAFE_DataRouterContext: () => DataRouterContext,\n  UNSAFE_DataRouterStateContext: () => DataRouterStateContext,\n  UNSAFE_ErrorResponseImpl: () => ErrorResponseImpl,\n  UNSAFE_FetchersContext: () => FetchersContext,\n  UNSAFE_FrameworkContext: () => FrameworkContext,\n  UNSAFE_LocationContext: () => LocationContext,\n  UNSAFE_NavigationContext: () => NavigationContext,\n  UNSAFE_RemixErrorBoundary: () => RemixErrorBoundary,\n  UNSAFE_RouteContext: () => RouteContext,\n  UNSAFE_ServerMode: () => ServerMode,\n  UNSAFE_SingleFetchRedirectSymbol: () => SingleFetchRedirectSymbol,\n  UNSAFE_ViewTransitionContext: () => ViewTransitionContext,\n  UNSAFE_createBrowserHistory: () => createBrowserHistory,\n  UNSAFE_createClientRoutes: () => createClientRoutes,\n  UNSAFE_createClientRoutesWithHMRRevalidationOptOut: () => createClientRoutesWithHMRRevalidationOptOut,\n  UNSAFE_createRouter: () => createRouter,\n  UNSAFE_decodeViaTurboStream: () => decodeViaTurboStream,\n  UNSAFE_deserializeErrors: () => deserializeErrors2,\n  UNSAFE_getPatchRoutesOnNavigationFunction: () => getPatchRoutesOnNavigationFunction,\n  UNSAFE_getSingleFetchDataStrategy: () => getSingleFetchDataStrategy,\n  UNSAFE_invariant: () => invariant,\n  UNSAFE_mapRouteProperties: () => mapRouteProperties,\n  UNSAFE_shouldHydrateRouteLoader: () => shouldHydrateRouteLoader,\n  UNSAFE_useFogOFWarDiscovery: () => useFogOFWarDiscovery,\n  UNSAFE_useScrollRestoration: () => useScrollRestoration,\n  createBrowserRouter: () => createBrowserRouter,\n  createCookie: () => createCookie,\n  createCookieSessionStorage: () => createCookieSessionStorage,\n  createHashRouter: () => createHashRouter,\n  createMemoryRouter: () => createMemoryRouter,\n  createMemorySessionStorage: () => createMemorySessionStorage,\n  createPath: () => createPath,\n  createRequestHandler: () => createRequestHandler,\n  createRoutesFromChildren: () => createRoutesFromChildren,\n  createRoutesFromElements: () => createRoutesFromElements,\n  createRoutesStub: () => createRoutesStub,\n  createSearchParams: () => createSearchParams,\n  createSession: () => createSession,\n  createSessionStorage: () => createSessionStorage,\n  createStaticHandler: () => createStaticHandler2,\n  createStaticRouter: () => createStaticRouter,\n  data: () => data,\n  generatePath: () => generatePath,\n  isCookie: () => isCookie,\n  isRouteErrorResponse: () => isRouteErrorResponse,\n  isSession: () => isSession,\n  matchPath: () => matchPath,\n  matchRoutes: () => matchRoutes,\n  parsePath: () => parsePath,\n  redirect: () => redirect,\n  redirectDocument: () => redirectDocument,\n  renderMatches: () => renderMatches,\n  replace: () => replace,\n  resolvePath: () => resolvePath,\n  unstable_HistoryRouter: () => HistoryRouter,\n  unstable_setDevServerHooks: () => setDevServerHooks,\n  unstable_usePrompt: () => usePrompt,\n  useActionData: () => useActionData,\n  useAsyncError: () => useAsyncError,\n  useAsyncValue: () => useAsyncValue,\n  useBeforeUnload: () => useBeforeUnload,\n  useBlocker: () => useBlocker,\n  useFetcher: () => useFetcher,\n  useFetchers: () => useFetchers,\n  useFormAction: () => useFormAction,\n  useHref: () => useHref,\n  useInRouterContext: () => useInRouterContext,\n  useLinkClickHandler: () => useLinkClickHandler,\n  useLoaderData: () => useLoaderData,\n  useLocation: () => useLocation,\n  useMatch: () => useMatch,\n  useMatches: () => useMatches,\n  useNavigate: () => useNavigate,\n  useNavigation: () => useNavigation,\n  useNavigationType: () => useNavigationType,\n  useOutlet: () => useOutlet,\n  useOutletContext: () => useOutletContext,\n  useParams: () => useParams,\n  useResolvedPath: () => useResolvedPath,\n  useRevalidator: () => useRevalidator,\n  useRouteError: () => useRouteError,\n  useRouteLoaderData: () => useRouteLoaderData,\n  useRoutes: () => useRoutes,\n  useSearchParams: () => useSearchParams,\n  useSubmit: () => useSubmit,\n  useViewTransitionState: () => useViewTransitionState\n});\nmodule.exports = __toCommonJS(react_router_exports);\n\n// lib/router/history.ts\nvar Action = /* @__PURE__ */ ((Action2) => {\n  Action2[\"Pop\"] = \"POP\";\n  Action2[\"Push\"] = \"PUSH\";\n  Action2[\"Replace\"] = \"REPLACE\";\n  return Action2;\n})(Action || {});\nvar PopStateEventType = \"popstate\";\nfunction createMemoryHistory(options = {}) {\n  let { initialEntries = [\"/\"], initialIndex, v5Compat = false } = options;\n  let entries;\n  entries = initialEntries.map(\n    (entry, index2) => createMemoryLocation(\n      entry,\n      typeof entry === \"string\" ? null : entry.state,\n      index2 === 0 ? \"default\" : void 0\n    )\n  );\n  let index = clampIndex(\n    initialIndex == null ? entries.length - 1 : initialIndex\n  );\n  let action = \"POP\" /* Pop */;\n  let listener = null;\n  function clampIndex(n) {\n    return Math.min(Math.max(n, 0), entries.length - 1);\n  }\n  function getCurrentLocation() {\n    return entries[index];\n  }\n  function createMemoryLocation(to, state = null, key) {\n    let location = createLocation(\n      entries ? getCurrentLocation().pathname : \"/\",\n      to,\n      state,\n      key\n    );\n    warning(\n      location.pathname.charAt(0) === \"/\",\n      `relative pathnames are not supported in memory history: ${JSON.stringify(\n        to\n      )}`\n    );\n    return location;\n  }\n  function createHref2(to) {\n    return typeof to === \"string\" ? to : createPath(to);\n  }\n  let history = {\n    get index() {\n      return index;\n    },\n    get action() {\n      return action;\n    },\n    get location() {\n      return getCurrentLocation();\n    },\n    createHref: createHref2,\n    createURL(to) {\n      return new URL(createHref2(to), \"http://localhost\");\n    },\n    encodeLocation(to) {\n      let path = typeof to === \"string\" ? parsePath(to) : to;\n      return {\n        pathname: path.pathname || \"\",\n        search: path.search || \"\",\n        hash: path.hash || \"\"\n      };\n    },\n    push(to, state) {\n      action = \"PUSH\" /* Push */;\n      let nextLocation = createMemoryLocation(to, state);\n      index += 1;\n      entries.splice(index, entries.length, nextLocation);\n      if (v5Compat && listener) {\n        listener({ action, location: nextLocation, delta: 1 });\n      }\n    },\n    replace(to, state) {\n      action = \"REPLACE\" /* Replace */;\n      let nextLocation = createMemoryLocation(to, state);\n      entries[index] = nextLocation;\n      if (v5Compat && listener) {\n        listener({ action, location: nextLocation, delta: 0 });\n      }\n    },\n    go(delta) {\n      action = \"POP\" /* Pop */;\n      let nextIndex = clampIndex(index + delta);\n      let nextLocation = entries[nextIndex];\n      index = nextIndex;\n      if (listener) {\n        listener({ action, location: nextLocation, delta });\n      }\n    },\n    listen(fn) {\n      listener = fn;\n      return () => {\n        listener = null;\n      };\n    }\n  };\n  return history;\n}\nfunction createBrowserHistory(options = {}) {\n  function createBrowserLocation(window2, globalHistory) {\n    let { pathname, search, hash } = window2.location;\n    return createLocation(\n      \"\",\n      { pathname, search, hash },\n      // state defaults to `null` because `window.history.state` does\n      globalHistory.state && globalHistory.state.usr || null,\n      globalHistory.state && globalHistory.state.key || \"default\"\n    );\n  }\n  function createBrowserHref(window2, to) {\n    return typeof to === \"string\" ? to : createPath(to);\n  }\n  return getUrlBasedHistory(\n    createBrowserLocation,\n    createBrowserHref,\n    null,\n    options\n  );\n}\nfunction createHashHistory(options = {}) {\n  function createHashLocation(window2, globalHistory) {\n    let {\n      pathname = \"/\",\n      search = \"\",\n      hash = \"\"\n    } = parsePath(window2.location.hash.substring(1));\n    if (!pathname.startsWith(\"/\") && !pathname.startsWith(\".\")) {\n      pathname = \"/\" + pathname;\n    }\n    return createLocation(\n      \"\",\n      { pathname, search, hash },\n      // state defaults to `null` because `window.history.state` does\n      globalHistory.state && globalHistory.state.usr || null,\n      globalHistory.state && globalHistory.state.key || \"default\"\n    );\n  }\n  function createHashHref(window2, to) {\n    let base = window2.document.querySelector(\"base\");\n    let href = \"\";\n    if (base && base.getAttribute(\"href\")) {\n      let url = window2.location.href;\n      let hashIndex = url.indexOf(\"#\");\n      href = hashIndex === -1 ? url : url.slice(0, hashIndex);\n    }\n    return href + \"#\" + (typeof to === \"string\" ? to : createPath(to));\n  }\n  function validateHashLocation(location, to) {\n    warning(\n      location.pathname.charAt(0) === \"/\",\n      `relative pathnames are not supported in hash history.push(${JSON.stringify(\n        to\n      )})`\n    );\n  }\n  return getUrlBasedHistory(\n    createHashLocation,\n    createHashHref,\n    validateHashLocation,\n    options\n  );\n}\nfunction invariant(value, message) {\n  if (value === false || value === null || typeof value === \"undefined\") {\n    throw new Error(message);\n  }\n}\nfunction warning(cond, message) {\n  if (!cond) {\n    if (typeof console !== \"undefined\") console.warn(message);\n    try {\n      throw new Error(message);\n    } catch (e) {\n    }\n  }\n}\nfunction createKey() {\n  return Math.random().toString(36).substring(2, 10);\n}\nfunction getHistoryState(location, index) {\n  return {\n    usr: location.state,\n    key: location.key,\n    idx: index\n  };\n}\nfunction createLocation(current, to, state = null, key) {\n  let location = {\n    pathname: typeof current === \"string\" ? current : current.pathname,\n    search: \"\",\n    hash: \"\",\n    ...typeof to === \"string\" ? parsePath(to) : to,\n    state,\n    // TODO: This could be cleaned up.  push/replace should probably just take\n    // full Locations now and avoid the need to run through this flow at all\n    // But that's a pretty big refactor to the current test suite so going to\n    // keep as is for the time being and just let any incoming keys take precedence\n    key: to && to.key || key || createKey()\n  };\n  return location;\n}\nfunction createPath({\n  pathname = \"/\",\n  search = \"\",\n  hash = \"\"\n}) {\n  if (search && search !== \"?\")\n    pathname += search.charAt(0) === \"?\" ? search : \"?\" + search;\n  if (hash && hash !== \"#\")\n    pathname += hash.charAt(0) === \"#\" ? hash : \"#\" + hash;\n  return pathname;\n}\nfunction parsePath(path) {\n  let parsedPath = {};\n  if (path) {\n    let hashIndex = path.indexOf(\"#\");\n    if (hashIndex >= 0) {\n      parsedPath.hash = path.substring(hashIndex);\n      path = path.substring(0, hashIndex);\n    }\n    let searchIndex = path.indexOf(\"?\");\n    if (searchIndex >= 0) {\n      parsedPath.search = path.substring(searchIndex);\n      path = path.substring(0, searchIndex);\n    }\n    if (path) {\n      parsedPath.pathname = path;\n    }\n  }\n  return parsedPath;\n}\nfunction getUrlBasedHistory(getLocation, createHref2, validateLocation, options = {}) {\n  let { window: window2 = document.defaultView, v5Compat = false } = options;\n  let globalHistory = window2.history;\n  let action = \"POP\" /* Pop */;\n  let listener = null;\n  let index = getIndex();\n  if (index == null) {\n    index = 0;\n    globalHistory.replaceState({ ...globalHistory.state, idx: index }, \"\");\n  }\n  function getIndex() {\n    let state = globalHistory.state || { idx: null };\n    return state.idx;\n  }\n  function handlePop() {\n    action = \"POP\" /* Pop */;\n    let nextIndex = getIndex();\n    let delta = nextIndex == null ? null : nextIndex - index;\n    index = nextIndex;\n    if (listener) {\n      listener({ action, location: history.location, delta });\n    }\n  }\n  function push(to, state) {\n    action = \"PUSH\" /* Push */;\n    let location = createLocation(history.location, to, state);\n    if (validateLocation) validateLocation(location, to);\n    index = getIndex() + 1;\n    let historyState = getHistoryState(location, index);\n    let url = history.createHref(location);\n    try {\n      globalHistory.pushState(historyState, \"\", url);\n    } catch (error) {\n      if (error instanceof DOMException && error.name === \"DataCloneError\") {\n        throw error;\n      }\n      window2.location.assign(url);\n    }\n    if (v5Compat && listener) {\n      listener({ action, location: history.location, delta: 1 });\n    }\n  }\n  function replace2(to, state) {\n    action = \"REPLACE\" /* Replace */;\n    let location = createLocation(history.location, to, state);\n    if (validateLocation) validateLocation(location, to);\n    index = getIndex();\n    let historyState = getHistoryState(location, index);\n    let url = history.createHref(location);\n    globalHistory.replaceState(historyState, \"\", url);\n    if (v5Compat && listener) {\n      listener({ action, location: history.location, delta: 0 });\n    }\n  }\n  function createURL(to) {\n    let base = window2.location.origin !== \"null\" ? window2.location.origin : window2.location.href;\n    let href = typeof to === \"string\" ? to : createPath(to);\n    href = href.replace(/ $/, \"%20\");\n    invariant(\n      base,\n      `No window.location.(origin|href) available to create URL for href: ${href}`\n    );\n    return new URL(href, base);\n  }\n  let history = {\n    get action() {\n      return action;\n    },\n    get location() {\n      return getLocation(window2, globalHistory);\n    },\n    listen(fn) {\n      if (listener) {\n        throw new Error(\"A history only accepts one active listener\");\n      }\n      window2.addEventListener(PopStateEventType, handlePop);\n      listener = fn;\n      return () => {\n        window2.removeEventListener(PopStateEventType, handlePop);\n        listener = null;\n      };\n    },\n    createHref(to) {\n      return createHref2(window2, to);\n    },\n    createURL,\n    encodeLocation(to) {\n      let url = createURL(to);\n      return {\n        pathname: url.pathname,\n        search: url.search,\n        hash: url.hash\n      };\n    },\n    push,\n    replace: replace2,\n    go(n) {\n      return globalHistory.go(n);\n    }\n  };\n  return history;\n}\n\n// lib/router/utils.ts\nvar immutableRouteKeys = /* @__PURE__ */ new Set([\n  \"lazy\",\n  \"caseSensitive\",\n  \"path\",\n  \"id\",\n  \"index\",\n  \"children\"\n]);\nfunction isIndexRoute(route) {\n  return route.index === true;\n}\nfunction convertRoutesToDataRoutes(routes, mapRouteProperties2, parentPath = [], manifest = {}) {\n  return routes.map((route, index) => {\n    let treePath = [...parentPath, String(index)];\n    let id = typeof route.id === \"string\" ? route.id : treePath.join(\"-\");\n    invariant(\n      route.index !== true || !route.children,\n      `Cannot specify children on an index route`\n    );\n    invariant(\n      !manifest[id],\n      `Found a route id collision on id \"${id}\".  Route id's must be globally unique within Data Router usages`\n    );\n    if (isIndexRoute(route)) {\n      let indexRoute = {\n        ...route,\n        ...mapRouteProperties2(route),\n        id\n      };\n      manifest[id] = indexRoute;\n      return indexRoute;\n    } else {\n      let pathOrLayoutRoute = {\n        ...route,\n        ...mapRouteProperties2(route),\n        id,\n        children: void 0\n      };\n      manifest[id] = pathOrLayoutRoute;\n      if (route.children) {\n        pathOrLayoutRoute.children = convertRoutesToDataRoutes(\n          route.children,\n          mapRouteProperties2,\n          treePath,\n          manifest\n        );\n      }\n      return pathOrLayoutRoute;\n    }\n  });\n}\nfunction matchRoutes(routes, locationArg, basename = \"/\") {\n  return matchRoutesImpl(routes, locationArg, basename, false);\n}\nfunction matchRoutesImpl(routes, locationArg, basename, allowPartial) {\n  let location = typeof locationArg === \"string\" ? parsePath(locationArg) : locationArg;\n  let pathname = stripBasename(location.pathname || \"/\", basename);\n  if (pathname == null) {\n    return null;\n  }\n  let branches = flattenRoutes(routes);\n  rankRouteBranches(branches);\n  let matches = null;\n  for (let i = 0; matches == null && i < branches.length; ++i) {\n    let decoded = decodePath(pathname);\n    matches = matchRouteBranch(\n      branches[i],\n      decoded,\n      allowPartial\n    );\n  }\n  return matches;\n}\nfunction convertRouteMatchToUiMatch(match, loaderData) {\n  let { route, pathname, params } = match;\n  return {\n    id: route.id,\n    pathname,\n    params,\n    data: loaderData[route.id],\n    handle: route.handle\n  };\n}\nfunction flattenRoutes(routes, branches = [], parentsMeta = [], parentPath = \"\") {\n  let flattenRoute = (route, index, relativePath) => {\n    let meta = {\n      relativePath: relativePath === void 0 ? route.path || \"\" : relativePath,\n      caseSensitive: route.caseSensitive === true,\n      childrenIndex: index,\n      route\n    };\n    if (meta.relativePath.startsWith(\"/\")) {\n      invariant(\n        meta.relativePath.startsWith(parentPath),\n        `Absolute route path \"${meta.relativePath}\" nested under path \"${parentPath}\" is not valid. An absolute child route path must start with the combined path of all its parent routes.`\n      );\n      meta.relativePath = meta.relativePath.slice(parentPath.length);\n    }\n    let path = joinPaths([parentPath, meta.relativePath]);\n    let routesMeta = parentsMeta.concat(meta);\n    if (route.children && route.children.length > 0) {\n      invariant(\n        // Our types know better, but runtime JS may not!\n        // @ts-expect-error\n        route.index !== true,\n        `Index routes must not have child routes. Please remove all child routes from route path \"${path}\".`\n      );\n      flattenRoutes(route.children, branches, routesMeta, path);\n    }\n    if (route.path == null && !route.index) {\n      return;\n    }\n    branches.push({\n      path,\n      score: computeScore(path, route.index),\n      routesMeta\n    });\n  };\n  routes.forEach((route, index) => {\n    if (route.path === \"\" || !route.path?.includes(\"?\")) {\n      flattenRoute(route, index);\n    } else {\n      for (let exploded of explodeOptionalSegments(route.path)) {\n        flattenRoute(route, index, exploded);\n      }\n    }\n  });\n  return branches;\n}\nfunction explodeOptionalSegments(path) {\n  let segments = path.split(\"/\");\n  if (segments.length === 0) return [];\n  let [first, ...rest] = segments;\n  let isOptional = first.endsWith(\"?\");\n  let required = first.replace(/\\?$/, \"\");\n  if (rest.length === 0) {\n    return isOptional ? [required, \"\"] : [required];\n  }\n  let restExploded = explodeOptionalSegments(rest.join(\"/\"));\n  let result = [];\n  result.push(\n    ...restExploded.map(\n      (subpath) => subpath === \"\" ? required : [required, subpath].join(\"/\")\n    )\n  );\n  if (isOptional) {\n    result.push(...restExploded);\n  }\n  return result.map(\n    (exploded) => path.startsWith(\"/\") && exploded === \"\" ? \"/\" : exploded\n  );\n}\nfunction rankRouteBranches(branches) {\n  branches.sort(\n    (a, b) => a.score !== b.score ? b.score - a.score : compareIndexes(\n      a.routesMeta.map((meta) => meta.childrenIndex),\n      b.routesMeta.map((meta) => meta.childrenIndex)\n    )\n  );\n}\nvar paramRe = /^:[\\w-]+$/;\nvar dynamicSegmentValue = 3;\nvar indexRouteValue = 2;\nvar emptySegmentValue = 1;\nvar staticSegmentValue = 10;\nvar splatPenalty = -2;\nvar isSplat = (s) => s === \"*\";\nfunction computeScore(path, index) {\n  let segments = path.split(\"/\");\n  let initialScore = segments.length;\n  if (segments.some(isSplat)) {\n    initialScore += splatPenalty;\n  }\n  if (index) {\n    initialScore += indexRouteValue;\n  }\n  return segments.filter((s) => !isSplat(s)).reduce(\n    (score, segment) => score + (paramRe.test(segment) ? dynamicSegmentValue : segment === \"\" ? emptySegmentValue : staticSegmentValue),\n    initialScore\n  );\n}\nfunction compareIndexes(a, b) {\n  let siblings = a.length === b.length && a.slice(0, -1).every((n, i) => n === b[i]);\n  return siblings ? (\n    // If two routes are siblings, we should try to match the earlier sibling\n    // first. This allows people to have fine-grained control over the matching\n    // behavior by simply putting routes with identical paths in the order they\n    // want them tried.\n    a[a.length - 1] - b[b.length - 1]\n  ) : (\n    // Otherwise, it doesn't really make sense to rank non-siblings by index,\n    // so they sort equally.\n    0\n  );\n}\nfunction matchRouteBranch(branch, pathname, allowPartial = false) {\n  let { routesMeta } = branch;\n  let matchedParams = {};\n  let matchedPathname = \"/\";\n  let matches = [];\n  for (let i = 0; i < routesMeta.length; ++i) {\n    let meta = routesMeta[i];\n    let end = i === routesMeta.length - 1;\n    let remainingPathname = matchedPathname === \"/\" ? pathname : pathname.slice(matchedPathname.length) || \"/\";\n    let match = matchPath(\n      { path: meta.relativePath, caseSensitive: meta.caseSensitive, end },\n      remainingPathname\n    );\n    let route = meta.route;\n    if (!match && end && allowPartial && !routesMeta[routesMeta.length - 1].route.index) {\n      match = matchPath(\n        {\n          path: meta.relativePath,\n          caseSensitive: meta.caseSensitive,\n          end: false\n        },\n        remainingPathname\n      );\n    }\n    if (!match) {\n      return null;\n    }\n    Object.assign(matchedParams, match.params);\n    matches.push({\n      // TODO: Can this as be avoided?\n      params: matchedParams,\n      pathname: joinPaths([matchedPathname, match.pathname]),\n      pathnameBase: normalizePathname(\n        joinPaths([matchedPathname, match.pathnameBase])\n      ),\n      route\n    });\n    if (match.pathnameBase !== \"/\") {\n      matchedPathname = joinPaths([matchedPathname, match.pathnameBase]);\n    }\n  }\n  return matches;\n}\nfunction generatePath(originalPath, params = {}) {\n  let path = originalPath;\n  if (path.endsWith(\"*\") && path !== \"*\" && !path.endsWith(\"/*\")) {\n    warning(\n      false,\n      `Route path \"${path}\" will be treated as if it were \"${path.replace(/\\*$/, \"/*\")}\" because the \\`*\\` character must always follow a \\`/\\` in the pattern. To get rid of this warning, please change the route path to \"${path.replace(/\\*$/, \"/*\")}\".`\n    );\n    path = path.replace(/\\*$/, \"/*\");\n  }\n  const prefix = path.startsWith(\"/\") ? \"/\" : \"\";\n  const stringify = (p) => p == null ? \"\" : typeof p === \"string\" ? p : String(p);\n  const segments = path.split(/\\/+/).map((segment, index, array) => {\n    const isLastSegment = index === array.length - 1;\n    if (isLastSegment && segment === \"*\") {\n      const star = \"*\";\n      return stringify(params[star]);\n    }\n    const keyMatch = segment.match(/^:([\\w-]+)(\\??)$/);\n    if (keyMatch) {\n      const [, key, optional] = keyMatch;\n      let param = params[key];\n      invariant(optional === \"?\" || param != null, `Missing \":${key}\" param`);\n      return stringify(param);\n    }\n    return segment.replace(/\\?$/g, \"\");\n  }).filter((segment) => !!segment);\n  return prefix + segments.join(\"/\");\n}\nfunction matchPath(pattern, pathname) {\n  if (typeof pattern === \"string\") {\n    pattern = { path: pattern, caseSensitive: false, end: true };\n  }\n  let [matcher, compiledParams] = compilePath(\n    pattern.path,\n    pattern.caseSensitive,\n    pattern.end\n  );\n  let match = pathname.match(matcher);\n  if (!match) return null;\n  let matchedPathname = match[0];\n  let pathnameBase = matchedPathname.replace(/(.)\\/+$/, \"$1\");\n  let captureGroups = match.slice(1);\n  let params = compiledParams.reduce(\n    (memo2, { paramName, isOptional }, index) => {\n      if (paramName === \"*\") {\n        let splatValue = captureGroups[index] || \"\";\n        pathnameBase = matchedPathname.slice(0, matchedPathname.length - splatValue.length).replace(/(.)\\/+$/, \"$1\");\n      }\n      const value = captureGroups[index];\n      if (isOptional && !value) {\n        memo2[paramName] = void 0;\n      } else {\n        memo2[paramName] = (value || \"\").replace(/%2F/g, \"/\");\n      }\n      return memo2;\n    },\n    {}\n  );\n  return {\n    params,\n    pathname: matchedPathname,\n    pathnameBase,\n    pattern\n  };\n}\nfunction compilePath(path, caseSensitive = false, end = true) {\n  warning(\n    path === \"*\" || !path.endsWith(\"*\") || path.endsWith(\"/*\"),\n    `Route path \"${path}\" will be treated as if it were \"${path.replace(/\\*$/, \"/*\")}\" because the \\`*\\` character must always follow a \\`/\\` in the pattern. To get rid of this warning, please change the route path to \"${path.replace(/\\*$/, \"/*\")}\".`\n  );\n  let params = [];\n  let regexpSource = \"^\" + path.replace(/\\/*\\*?$/, \"\").replace(/^\\/*/, \"/\").replace(/[\\\\.*+^${}|()[\\]]/g, \"\\\\$&\").replace(\n    /\\/:([\\w-]+)(\\?)?/g,\n    (_, paramName, isOptional) => {\n      params.push({ paramName, isOptional: isOptional != null });\n      return isOptional ? \"/?([^\\\\/]+)?\" : \"/([^\\\\/]+)\";\n    }\n  );\n  if (path.endsWith(\"*\")) {\n    params.push({ paramName: \"*\" });\n    regexpSource += path === \"*\" || path === \"/*\" ? \"(.*)$\" : \"(?:\\\\/(.+)|\\\\/*)$\";\n  } else if (end) {\n    regexpSource += \"\\\\/*$\";\n  } else if (path !== \"\" && path !== \"/\") {\n    regexpSource += \"(?:(?=\\\\/|$))\";\n  } else {\n  }\n  let matcher = new RegExp(regexpSource, caseSensitive ? void 0 : \"i\");\n  return [matcher, params];\n}\nfunction decodePath(value) {\n  try {\n    return value.split(\"/\").map((v) => decodeURIComponent(v).replace(/\\//g, \"%2F\")).join(\"/\");\n  } catch (error) {\n    warning(\n      false,\n      `The URL path \"${value}\" could not be decoded because it is is a malformed URL segment. This is probably due to a bad percent encoding (${error}).`\n    );\n    return value;\n  }\n}\nfunction stripBasename(pathname, basename) {\n  if (basename === \"/\") return pathname;\n  if (!pathname.toLowerCase().startsWith(basename.toLowerCase())) {\n    return null;\n  }\n  let startIndex = basename.endsWith(\"/\") ? basename.length - 1 : basename.length;\n  let nextChar = pathname.charAt(startIndex);\n  if (nextChar && nextChar !== \"/\") {\n    return null;\n  }\n  return pathname.slice(startIndex) || \"/\";\n}\nfunction resolvePath(to, fromPathname = \"/\") {\n  let {\n    pathname: toPathname,\n    search = \"\",\n    hash = \"\"\n  } = typeof to === \"string\" ? parsePath(to) : to;\n  let pathname = toPathname ? toPathname.startsWith(\"/\") ? toPathname : resolvePathname(toPathname, fromPathname) : fromPathname;\n  return {\n    pathname,\n    search: normalizeSearch(search),\n    hash: normalizeHash(hash)\n  };\n}\nfunction resolvePathname(relativePath, fromPathname) {\n  let segments = fromPathname.replace(/\\/+$/, \"\").split(\"/\");\n  let relativeSegments = relativePath.split(\"/\");\n  relativeSegments.forEach((segment) => {\n    if (segment === \"..\") {\n      if (segments.length > 1) segments.pop();\n    } else if (segment !== \".\") {\n      segments.push(segment);\n    }\n  });\n  return segments.length > 1 ? segments.join(\"/\") : \"/\";\n}\nfunction getInvalidPathError(char, field, dest, path) {\n  return `Cannot include a '${char}' character in a manually specified \\`to.${field}\\` field [${JSON.stringify(\n    path\n  )}].  Please separate it out to the \\`to.${dest}\\` field. Alternatively you may provide the full path as a string in <Link to=\"...\"> and the router will parse it for you.`;\n}\nfunction getPathContributingMatches(matches) {\n  return matches.filter(\n    (match, index) => index === 0 || match.route.path && match.route.path.length > 0\n  );\n}\nfunction getResolveToMatches(matches) {\n  let pathMatches = getPathContributingMatches(matches);\n  return pathMatches.map(\n    (match, idx) => idx === pathMatches.length - 1 ? match.pathname : match.pathnameBase\n  );\n}\nfunction resolveTo(toArg, routePathnames, locationPathname, isPathRelative = false) {\n  let to;\n  if (typeof toArg === \"string\") {\n    to = parsePath(toArg);\n  } else {\n    to = { ...toArg };\n    invariant(\n      !to.pathname || !to.pathname.includes(\"?\"),\n      getInvalidPathError(\"?\", \"pathname\", \"search\", to)\n    );\n    invariant(\n      !to.pathname || !to.pathname.includes(\"#\"),\n      getInvalidPathError(\"#\", \"pathname\", \"hash\", to)\n    );\n    invariant(\n      !to.search || !to.search.includes(\"#\"),\n      getInvalidPathError(\"#\", \"search\", \"hash\", to)\n    );\n  }\n  let isEmptyPath = toArg === \"\" || to.pathname === \"\";\n  let toPathname = isEmptyPath ? \"/\" : to.pathname;\n  let from;\n  if (toPathname == null) {\n    from = locationPathname;\n  } else {\n    let routePathnameIndex = routePathnames.length - 1;\n    if (!isPathRelative && toPathname.startsWith(\"..\")) {\n      let toSegments = toPathname.split(\"/\");\n      while (toSegments[0] === \"..\") {\n        toSegments.shift();\n        routePathnameIndex -= 1;\n      }\n      to.pathname = toSegments.join(\"/\");\n    }\n    from = routePathnameIndex >= 0 ? routePathnames[routePathnameIndex] : \"/\";\n  }\n  let path = resolvePath(to, from);\n  let hasExplicitTrailingSlash = toPathname && toPathname !== \"/\" && toPathname.endsWith(\"/\");\n  let hasCurrentTrailingSlash = (isEmptyPath || toPathname === \".\") && locationPathname.endsWith(\"/\");\n  if (!path.pathname.endsWith(\"/\") && (hasExplicitTrailingSlash || hasCurrentTrailingSlash)) {\n    path.pathname += \"/\";\n  }\n  return path;\n}\nvar joinPaths = (paths) => paths.join(\"/\").replace(/\\/\\/+/g, \"/\");\nvar normalizePathname = (pathname) => pathname.replace(/\\/+$/, \"\").replace(/^\\/*/, \"/\");\nvar normalizeSearch = (search) => !search || search === \"?\" ? \"\" : search.startsWith(\"?\") ? search : \"?\" + search;\nvar normalizeHash = (hash) => !hash || hash === \"#\" ? \"\" : hash.startsWith(\"#\") ? hash : \"#\" + hash;\nvar DataWithResponseInit = class {\n  constructor(data2, init) {\n    this.type = \"DataWithResponseInit\";\n    this.data = data2;\n    this.init = init || null;\n  }\n};\nfunction data(data2, init) {\n  return new DataWithResponseInit(\n    data2,\n    typeof init === \"number\" ? { status: init } : init\n  );\n}\nvar redirect = (url, init = 302) => {\n  let responseInit = init;\n  if (typeof responseInit === \"number\") {\n    responseInit = { status: responseInit };\n  } else if (typeof responseInit.status === \"undefined\") {\n    responseInit.status = 302;\n  }\n  let headers = new Headers(responseInit.headers);\n  headers.set(\"Location\", url);\n  return new Response(null, {\n    ...responseInit,\n    headers\n  });\n};\nvar redirectDocument = (url, init) => {\n  let response = redirect(url, init);\n  response.headers.set(\"X-Remix-Reload-Document\", \"true\");\n  return response;\n};\nvar replace = (url, init) => {\n  let response = redirect(url, init);\n  response.headers.set(\"X-Remix-Replace\", \"true\");\n  return response;\n};\nvar ErrorResponseImpl = class {\n  constructor(status, statusText, data2, internal = false) {\n    this.status = status;\n    this.statusText = statusText || \"\";\n    this.internal = internal;\n    if (data2 instanceof Error) {\n      this.data = data2.toString();\n      this.error = data2;\n    } else {\n      this.data = data2;\n    }\n  }\n};\nfunction isRouteErrorResponse(error) {\n  return error != null && typeof error.status === \"number\" && typeof error.statusText === \"string\" && typeof error.internal === \"boolean\" && \"data\" in error;\n}\n\n// lib/router/router.ts\nvar validMutationMethodsArr = [\n  \"POST\",\n  \"PUT\",\n  \"PATCH\",\n  \"DELETE\"\n];\nvar validMutationMethods = new Set(\n  validMutationMethodsArr\n);\nvar validRequestMethodsArr = [\n  \"GET\",\n  ...validMutationMethodsArr\n];\nvar validRequestMethods = new Set(validRequestMethodsArr);\nvar redirectStatusCodes = /* @__PURE__ */ new Set([301, 302, 303, 307, 308]);\nvar redirectPreserveMethodStatusCodes = /* @__PURE__ */ new Set([307, 308]);\nvar IDLE_NAVIGATION = {\n  state: \"idle\",\n  location: void 0,\n  formMethod: void 0,\n  formAction: void 0,\n  formEncType: void 0,\n  formData: void 0,\n  json: void 0,\n  text: void 0\n};\nvar IDLE_FETCHER = {\n  state: \"idle\",\n  data: void 0,\n  formMethod: void 0,\n  formAction: void 0,\n  formEncType: void 0,\n  formData: void 0,\n  json: void 0,\n  text: void 0\n};\nvar IDLE_BLOCKER = {\n  state: \"unblocked\",\n  proceed: void 0,\n  reset: void 0,\n  location: void 0\n};\nvar ABSOLUTE_URL_REGEX = /^(?:[a-z][a-z0-9+.-]*:|\\/\\/)/i;\nvar defaultMapRouteProperties = (route) => ({\n  hasErrorBoundary: Boolean(route.hasErrorBoundary)\n});\nvar TRANSITIONS_STORAGE_KEY = \"remix-router-transitions\";\nvar ResetLoaderDataSymbol = Symbol(\"ResetLoaderData\");\nfunction createRouter(init) {\n  const routerWindow = init.window ? init.window : typeof window !== \"undefined\" ? window : void 0;\n  const isBrowser2 = typeof routerWindow !== \"undefined\" && typeof routerWindow.document !== \"undefined\" && typeof routerWindow.document.createElement !== \"undefined\";\n  invariant(\n    init.routes.length > 0,\n    \"You must provide a non-empty routes array to createRouter\"\n  );\n  let mapRouteProperties2 = init.mapRouteProperties || defaultMapRouteProperties;\n  let manifest = {};\n  let dataRoutes = convertRoutesToDataRoutes(\n    init.routes,\n    mapRouteProperties2,\n    void 0,\n    manifest\n  );\n  let inFlightDataRoutes;\n  let basename = init.basename || \"/\";\n  let dataStrategyImpl = init.dataStrategy || defaultDataStrategy;\n  let patchRoutesOnNavigationImpl = init.patchRoutesOnNavigation;\n  let future = {\n    ...init.future\n  };\n  let unlistenHistory = null;\n  let subscribers = /* @__PURE__ */ new Set();\n  let savedScrollPositions2 = null;\n  let getScrollRestorationKey2 = null;\n  let getScrollPosition = null;\n  let initialScrollRestored = init.hydrationData != null;\n  let initialMatches = matchRoutes(dataRoutes, init.history.location, basename);\n  let initialErrors = null;\n  if (initialMatches == null && !patchRoutesOnNavigationImpl) {\n    let error = getInternalRouterError(404, {\n      pathname: init.history.location.pathname\n    });\n    let { matches, route } = getShortCircuitMatches(dataRoutes);\n    initialMatches = matches;\n    initialErrors = { [route.id]: error };\n  }\n  if (initialMatches && !init.hydrationData) {\n    let fogOfWar = checkFogOfWar(\n      initialMatches,\n      dataRoutes,\n      init.history.location.pathname\n    );\n    if (fogOfWar.active) {\n      initialMatches = null;\n    }\n  }\n  let initialized;\n  if (!initialMatches) {\n    initialized = false;\n    initialMatches = [];\n    let fogOfWar = checkFogOfWar(\n      null,\n      dataRoutes,\n      init.history.location.pathname\n    );\n    if (fogOfWar.active && fogOfWar.matches) {\n      initialMatches = fogOfWar.matches;\n    }\n  } else if (initialMatches.some((m) => m.route.lazy)) {\n    initialized = false;\n  } else if (!initialMatches.some((m) => m.route.loader)) {\n    initialized = true;\n  } else {\n    let loaderData = init.hydrationData ? init.hydrationData.loaderData : null;\n    let errors = init.hydrationData ? init.hydrationData.errors : null;\n    if (errors) {\n      let idx = initialMatches.findIndex(\n        (m) => errors[m.route.id] !== void 0\n      );\n      initialized = initialMatches.slice(0, idx + 1).every((m) => !shouldLoadRouteOnHydration(m.route, loaderData, errors));\n    } else {\n      initialized = initialMatches.every(\n        (m) => !shouldLoadRouteOnHydration(m.route, loaderData, errors)\n      );\n    }\n  }\n  let router;\n  let state = {\n    historyAction: init.history.action,\n    location: init.history.location,\n    matches: initialMatches,\n    initialized,\n    navigation: IDLE_NAVIGATION,\n    // Don't restore on initial updateState() if we were SSR'd\n    restoreScrollPosition: init.hydrationData != null ? false : null,\n    preventScrollReset: false,\n    revalidation: \"idle\",\n    loaderData: init.hydrationData && init.hydrationData.loaderData || {},\n    actionData: init.hydrationData && init.hydrationData.actionData || null,\n    errors: init.hydrationData && init.hydrationData.errors || initialErrors,\n    fetchers: /* @__PURE__ */ new Map(),\n    blockers: /* @__PURE__ */ new Map()\n  };\n  let pendingAction = \"POP\" /* Pop */;\n  let pendingPreventScrollReset = false;\n  let pendingNavigationController;\n  let pendingViewTransitionEnabled = false;\n  let appliedViewTransitions = /* @__PURE__ */ new Map();\n  let removePageHideEventListener = null;\n  let isUninterruptedRevalidation = false;\n  let isRevalidationRequired = false;\n  let cancelledFetcherLoads = /* @__PURE__ */ new Set();\n  let fetchControllers = /* @__PURE__ */ new Map();\n  let incrementingLoadId = 0;\n  let pendingNavigationLoadId = -1;\n  let fetchReloadIds = /* @__PURE__ */ new Map();\n  let fetchRedirectIds = /* @__PURE__ */ new Set();\n  let fetchLoadMatches = /* @__PURE__ */ new Map();\n  let activeFetchers = /* @__PURE__ */ new Map();\n  let fetchersQueuedForDeletion = /* @__PURE__ */ new Set();\n  let blockerFunctions = /* @__PURE__ */ new Map();\n  let unblockBlockerHistoryUpdate = void 0;\n  let pendingRevalidationDfd = null;\n  function initialize() {\n    unlistenHistory = init.history.listen(\n      ({ action: historyAction, location, delta }) => {\n        if (unblockBlockerHistoryUpdate) {\n          unblockBlockerHistoryUpdate();\n          unblockBlockerHistoryUpdate = void 0;\n          return;\n        }\n        warning(\n          blockerFunctions.size === 0 || delta != null,\n          \"You are trying to use a blocker on a POP navigation to a location that was not created by @remix-run/router. This will fail silently in production. This can happen if you are navigating outside the router via `window.history.pushState`/`window.location.hash` instead of using router navigation APIs.  This can also happen if you are using createHashRouter and the user manually changes the URL.\"\n        );\n        let blockerKey = shouldBlockNavigation({\n          currentLocation: state.location,\n          nextLocation: location,\n          historyAction\n        });\n        if (blockerKey && delta != null) {\n          let nextHistoryUpdatePromise = new Promise((resolve) => {\n            unblockBlockerHistoryUpdate = resolve;\n          });\n          init.history.go(delta * -1);\n          updateBlocker(blockerKey, {\n            state: \"blocked\",\n            location,\n            proceed() {\n              updateBlocker(blockerKey, {\n                state: \"proceeding\",\n                proceed: void 0,\n                reset: void 0,\n                location\n              });\n              nextHistoryUpdatePromise.then(() => init.history.go(delta));\n            },\n            reset() {\n              let blockers = new Map(state.blockers);\n              blockers.set(blockerKey, IDLE_BLOCKER);\n              updateState({ blockers });\n            }\n          });\n          return;\n        }\n        return startNavigation(historyAction, location);\n      }\n    );\n    if (isBrowser2) {\n      restoreAppliedTransitions(routerWindow, appliedViewTransitions);\n      let _saveAppliedTransitions = () => persistAppliedTransitions(routerWindow, appliedViewTransitions);\n      routerWindow.addEventListener(\"pagehide\", _saveAppliedTransitions);\n      removePageHideEventListener = () => routerWindow.removeEventListener(\"pagehide\", _saveAppliedTransitions);\n    }\n    if (!state.initialized) {\n      startNavigation(\"POP\" /* Pop */, state.location, {\n        initialHydration: true\n      });\n    }\n    return router;\n  }\n  function dispose() {\n    if (unlistenHistory) {\n      unlistenHistory();\n    }\n    if (removePageHideEventListener) {\n      removePageHideEventListener();\n    }\n    subscribers.clear();\n    pendingNavigationController && pendingNavigationController.abort();\n    state.fetchers.forEach((_, key) => deleteFetcher(key));\n    state.blockers.forEach((_, key) => deleteBlocker(key));\n  }\n  function subscribe(fn) {\n    subscribers.add(fn);\n    return () => subscribers.delete(fn);\n  }\n  function updateState(newState, opts = {}) {\n    state = {\n      ...state,\n      ...newState\n    };\n    let unmountedFetchers = [];\n    let mountedFetchers = [];\n    state.fetchers.forEach((fetcher, key) => {\n      if (fetcher.state === \"idle\") {\n        if (fetchersQueuedForDeletion.has(key)) {\n          unmountedFetchers.push(key);\n        } else {\n          mountedFetchers.push(key);\n        }\n      }\n    });\n    [...subscribers].forEach(\n      (subscriber) => subscriber(state, {\n        deletedFetchers: unmountedFetchers,\n        viewTransitionOpts: opts.viewTransitionOpts,\n        flushSync: opts.flushSync === true\n      })\n    );\n    unmountedFetchers.forEach((key) => deleteFetcher(key));\n    mountedFetchers.forEach((key) => state.fetchers.delete(key));\n  }\n  function completeNavigation(location, newState, { flushSync } = {}) {\n    let isActionReload = state.actionData != null && state.navigation.formMethod != null && isMutationMethod(state.navigation.formMethod) && state.navigation.state === \"loading\" && location.state?._isRedirect !== true;\n    let actionData;\n    if (newState.actionData) {\n      if (Object.keys(newState.actionData).length > 0) {\n        actionData = newState.actionData;\n      } else {\n        actionData = null;\n      }\n    } else if (isActionReload) {\n      actionData = state.actionData;\n    } else {\n      actionData = null;\n    }\n    let loaderData = newState.loaderData ? mergeLoaderData(\n      state.loaderData,\n      newState.loaderData,\n      newState.matches || [],\n      newState.errors\n    ) : state.loaderData;\n    let blockers = state.blockers;\n    if (blockers.size > 0) {\n      blockers = new Map(blockers);\n      blockers.forEach((_, k) => blockers.set(k, IDLE_BLOCKER));\n    }\n    let preventScrollReset = pendingPreventScrollReset === true || state.navigation.formMethod != null && isMutationMethod(state.navigation.formMethod) && location.state?._isRedirect !== true;\n    if (inFlightDataRoutes) {\n      dataRoutes = inFlightDataRoutes;\n      inFlightDataRoutes = void 0;\n    }\n    if (isUninterruptedRevalidation) {\n    } else if (pendingAction === \"POP\" /* Pop */) {\n    } else if (pendingAction === \"PUSH\" /* Push */) {\n      init.history.push(location, location.state);\n    } else if (pendingAction === \"REPLACE\" /* Replace */) {\n      init.history.replace(location, location.state);\n    }\n    let viewTransitionOpts;\n    if (pendingAction === \"POP\" /* Pop */) {\n      let priorPaths = appliedViewTransitions.get(state.location.pathname);\n      if (priorPaths && priorPaths.has(location.pathname)) {\n        viewTransitionOpts = {\n          currentLocation: state.location,\n          nextLocation: location\n        };\n      } else if (appliedViewTransitions.has(location.pathname)) {\n        viewTransitionOpts = {\n          currentLocation: location,\n          nextLocation: state.location\n        };\n      }\n    } else if (pendingViewTransitionEnabled) {\n      let toPaths = appliedViewTransitions.get(state.location.pathname);\n      if (toPaths) {\n        toPaths.add(location.pathname);\n      } else {\n        toPaths = /* @__PURE__ */ new Set([location.pathname]);\n        appliedViewTransitions.set(state.location.pathname, toPaths);\n      }\n      viewTransitionOpts = {\n        currentLocation: state.location,\n        nextLocation: location\n      };\n    }\n    updateState(\n      {\n        ...newState,\n        // matches, errors, fetchers go through as-is\n        actionData,\n        loaderData,\n        historyAction: pendingAction,\n        location,\n        initialized: true,\n        navigation: IDLE_NAVIGATION,\n        revalidation: \"idle\",\n        restoreScrollPosition: getSavedScrollPosition(\n          location,\n          newState.matches || state.matches\n        ),\n        preventScrollReset,\n        blockers\n      },\n      {\n        viewTransitionOpts,\n        flushSync: flushSync === true\n      }\n    );\n    pendingAction = \"POP\" /* Pop */;\n    pendingPreventScrollReset = false;\n    pendingViewTransitionEnabled = false;\n    isUninterruptedRevalidation = false;\n    isRevalidationRequired = false;\n    pendingRevalidationDfd?.resolve();\n    pendingRevalidationDfd = null;\n  }\n  async function navigate(to, opts) {\n    if (typeof to === \"number\") {\n      init.history.go(to);\n      return;\n    }\n    let normalizedPath = normalizeTo(\n      state.location,\n      state.matches,\n      basename,\n      to,\n      opts?.fromRouteId,\n      opts?.relative\n    );\n    let { path, submission, error } = normalizeNavigateOptions(\n      false,\n      normalizedPath,\n      opts\n    );\n    let currentLocation = state.location;\n    let nextLocation = createLocation(state.location, path, opts && opts.state);\n    nextLocation = {\n      ...nextLocation,\n      ...init.history.encodeLocation(nextLocation)\n    };\n    let userReplace = opts && opts.replace != null ? opts.replace : void 0;\n    let historyAction = \"PUSH\" /* Push */;\n    if (userReplace === true) {\n      historyAction = \"REPLACE\" /* Replace */;\n    } else if (userReplace === false) {\n    } else if (submission != null && isMutationMethod(submission.formMethod) && submission.formAction === state.location.pathname + state.location.search) {\n      historyAction = \"REPLACE\" /* Replace */;\n    }\n    let preventScrollReset = opts && \"preventScrollReset\" in opts ? opts.preventScrollReset === true : void 0;\n    let flushSync = (opts && opts.flushSync) === true;\n    let blockerKey = shouldBlockNavigation({\n      currentLocation,\n      nextLocation,\n      historyAction\n    });\n    if (blockerKey) {\n      updateBlocker(blockerKey, {\n        state: \"blocked\",\n        location: nextLocation,\n        proceed() {\n          updateBlocker(blockerKey, {\n            state: \"proceeding\",\n            proceed: void 0,\n            reset: void 0,\n            location: nextLocation\n          });\n          navigate(to, opts);\n        },\n        reset() {\n          let blockers = new Map(state.blockers);\n          blockers.set(blockerKey, IDLE_BLOCKER);\n          updateState({ blockers });\n        }\n      });\n      return;\n    }\n    await startNavigation(historyAction, nextLocation, {\n      submission,\n      // Send through the formData serialization error if we have one so we can\n      // render at the right error boundary after we match routes\n      pendingError: error,\n      preventScrollReset,\n      replace: opts && opts.replace,\n      enableViewTransition: opts && opts.viewTransition,\n      flushSync\n    });\n  }\n  function revalidate() {\n    if (!pendingRevalidationDfd) {\n      pendingRevalidationDfd = createDeferred();\n    }\n    interruptActiveLoads();\n    updateState({ revalidation: \"loading\" });\n    let promise = pendingRevalidationDfd.promise;\n    if (state.navigation.state === \"submitting\") {\n      return promise;\n    }\n    if (state.navigation.state === \"idle\") {\n      startNavigation(state.historyAction, state.location, {\n        startUninterruptedRevalidation: true\n      });\n      return promise;\n    }\n    startNavigation(\n      pendingAction || state.historyAction,\n      state.navigation.location,\n      {\n        overrideNavigation: state.navigation,\n        // Proxy through any rending view transition\n        enableViewTransition: pendingViewTransitionEnabled === true\n      }\n    );\n    return promise;\n  }\n  async function startNavigation(historyAction, location, opts) {\n    pendingNavigationController && pendingNavigationController.abort();\n    pendingNavigationController = null;\n    pendingAction = historyAction;\n    isUninterruptedRevalidation = (opts && opts.startUninterruptedRevalidation) === true;\n    saveScrollPosition(state.location, state.matches);\n    pendingPreventScrollReset = (opts && opts.preventScrollReset) === true;\n    pendingViewTransitionEnabled = (opts && opts.enableViewTransition) === true;\n    let routesToUse = inFlightDataRoutes || dataRoutes;\n    let loadingNavigation = opts && opts.overrideNavigation;\n    let matches = matchRoutes(routesToUse, location, basename);\n    let flushSync = (opts && opts.flushSync) === true;\n    let fogOfWar = checkFogOfWar(matches, routesToUse, location.pathname);\n    if (fogOfWar.active && fogOfWar.matches) {\n      matches = fogOfWar.matches;\n    }\n    if (!matches) {\n      let { error, notFoundMatches, route } = handleNavigational404(\n        location.pathname\n      );\n      completeNavigation(\n        location,\n        {\n          matches: notFoundMatches,\n          loaderData: {},\n          errors: {\n            [route.id]: error\n          }\n        },\n        { flushSync }\n      );\n      return;\n    }\n    if (state.initialized && !isRevalidationRequired && isHashChangeOnly(state.location, location) && !(opts && opts.submission && isMutationMethod(opts.submission.formMethod))) {\n      completeNavigation(location, { matches }, { flushSync });\n      return;\n    }\n    pendingNavigationController = new AbortController();\n    let request = createClientSideRequest(\n      init.history,\n      location,\n      pendingNavigationController.signal,\n      opts && opts.submission\n    );\n    let pendingActionResult;\n    if (opts && opts.pendingError) {\n      pendingActionResult = [\n        findNearestBoundary(matches).route.id,\n        { type: \"error\" /* error */, error: opts.pendingError }\n      ];\n    } else if (opts && opts.submission && isMutationMethod(opts.submission.formMethod)) {\n      let actionResult = await handleAction(\n        request,\n        location,\n        opts.submission,\n        matches,\n        fogOfWar.active,\n        { replace: opts.replace, flushSync }\n      );\n      if (actionResult.shortCircuited) {\n        return;\n      }\n      if (actionResult.pendingActionResult) {\n        let [routeId, result] = actionResult.pendingActionResult;\n        if (isErrorResult(result) && isRouteErrorResponse(result.error) && result.error.status === 404) {\n          pendingNavigationController = null;\n          completeNavigation(location, {\n            matches: actionResult.matches,\n            loaderData: {},\n            errors: {\n              [routeId]: result.error\n            }\n          });\n          return;\n        }\n      }\n      matches = actionResult.matches || matches;\n      pendingActionResult = actionResult.pendingActionResult;\n      loadingNavigation = getLoadingNavigation(location, opts.submission);\n      flushSync = false;\n      fogOfWar.active = false;\n      request = createClientSideRequest(\n        init.history,\n        request.url,\n        request.signal\n      );\n    }\n    let {\n      shortCircuited,\n      matches: updatedMatches,\n      loaderData,\n      errors\n    } = await handleLoaders(\n      request,\n      location,\n      matches,\n      fogOfWar.active,\n      loadingNavigation,\n      opts && opts.submission,\n      opts && opts.fetcherSubmission,\n      opts && opts.replace,\n      opts && opts.initialHydration === true,\n      flushSync,\n      pendingActionResult\n    );\n    if (shortCircuited) {\n      return;\n    }\n    pendingNavigationController = null;\n    completeNavigation(location, {\n      matches: updatedMatches || matches,\n      ...getActionDataForCommit(pendingActionResult),\n      loaderData,\n      errors\n    });\n  }\n  async function handleAction(request, location, submission, matches, isFogOfWar, opts = {}) {\n    interruptActiveLoads();\n    let navigation = getSubmittingNavigation(location, submission);\n    updateState({ navigation }, { flushSync: opts.flushSync === true });\n    if (isFogOfWar) {\n      let discoverResult = await discoverRoutes(\n        matches,\n        location.pathname,\n        request.signal\n      );\n      if (discoverResult.type === \"aborted\") {\n        return { shortCircuited: true };\n      } else if (discoverResult.type === \"error\") {\n        let boundaryId = findNearestBoundary(discoverResult.partialMatches).route.id;\n        return {\n          matches: discoverResult.partialMatches,\n          pendingActionResult: [\n            boundaryId,\n            {\n              type: \"error\" /* error */,\n              error: discoverResult.error\n            }\n          ]\n        };\n      } else if (!discoverResult.matches) {\n        let { notFoundMatches, error, route } = handleNavigational404(\n          location.pathname\n        );\n        return {\n          matches: notFoundMatches,\n          pendingActionResult: [\n            route.id,\n            {\n              type: \"error\" /* error */,\n              error\n            }\n          ]\n        };\n      } else {\n        matches = discoverResult.matches;\n      }\n    }\n    let result;\n    let actionMatch = getTargetMatch(matches, location);\n    if (!actionMatch.route.action && !actionMatch.route.lazy) {\n      result = {\n        type: \"error\" /* error */,\n        error: getInternalRouterError(405, {\n          method: request.method,\n          pathname: location.pathname,\n          routeId: actionMatch.route.id\n        })\n      };\n    } else {\n      let results = await callDataStrategy(\n        \"action\",\n        state,\n        request,\n        [actionMatch],\n        matches,\n        null\n      );\n      result = results[actionMatch.route.id];\n      if (request.signal.aborted) {\n        return { shortCircuited: true };\n      }\n    }\n    if (isRedirectResult(result)) {\n      let replace2;\n      if (opts && opts.replace != null) {\n        replace2 = opts.replace;\n      } else {\n        let location2 = normalizeRedirectLocation(\n          result.response.headers.get(\"Location\"),\n          new URL(request.url),\n          basename\n        );\n        replace2 = location2 === state.location.pathname + state.location.search;\n      }\n      await startRedirectNavigation(request, result, true, {\n        submission,\n        replace: replace2\n      });\n      return { shortCircuited: true };\n    }\n    if (isErrorResult(result)) {\n      let boundaryMatch = findNearestBoundary(matches, actionMatch.route.id);\n      if ((opts && opts.replace) !== true) {\n        pendingAction = \"PUSH\" /* Push */;\n      }\n      return {\n        matches,\n        pendingActionResult: [boundaryMatch.route.id, result]\n      };\n    }\n    return {\n      matches,\n      pendingActionResult: [actionMatch.route.id, result]\n    };\n  }\n  async function handleLoaders(request, location, matches, isFogOfWar, overrideNavigation, submission, fetcherSubmission, replace2, initialHydration, flushSync, pendingActionResult) {\n    let loadingNavigation = overrideNavigation || getLoadingNavigation(location, submission);\n    let activeSubmission = submission || fetcherSubmission || getSubmissionFromNavigation(loadingNavigation);\n    let shouldUpdateNavigationState = !isUninterruptedRevalidation && !initialHydration;\n    if (isFogOfWar) {\n      if (shouldUpdateNavigationState) {\n        let actionData = getUpdatedActionData(pendingActionResult);\n        updateState(\n          {\n            navigation: loadingNavigation,\n            ...actionData !== void 0 ? { actionData } : {}\n          },\n          {\n            flushSync\n          }\n        );\n      }\n      let discoverResult = await discoverRoutes(\n        matches,\n        location.pathname,\n        request.signal\n      );\n      if (discoverResult.type === \"aborted\") {\n        return { shortCircuited: true };\n      } else if (discoverResult.type === \"error\") {\n        let boundaryId = findNearestBoundary(discoverResult.partialMatches).route.id;\n        return {\n          matches: discoverResult.partialMatches,\n          loaderData: {},\n          errors: {\n            [boundaryId]: discoverResult.error\n          }\n        };\n      } else if (!discoverResult.matches) {\n        let { error, notFoundMatches, route } = handleNavigational404(\n          location.pathname\n        );\n        return {\n          matches: notFoundMatches,\n          loaderData: {},\n          errors: {\n            [route.id]: error\n          }\n        };\n      } else {\n        matches = discoverResult.matches;\n      }\n    }\n    let routesToUse = inFlightDataRoutes || dataRoutes;\n    let [matchesToLoad, revalidatingFetchers] = getMatchesToLoad(\n      init.history,\n      state,\n      matches,\n      activeSubmission,\n      location,\n      initialHydration === true,\n      isRevalidationRequired,\n      cancelledFetcherLoads,\n      fetchersQueuedForDeletion,\n      fetchLoadMatches,\n      fetchRedirectIds,\n      routesToUse,\n      basename,\n      pendingActionResult\n    );\n    pendingNavigationLoadId = ++incrementingLoadId;\n    if (matchesToLoad.length === 0 && revalidatingFetchers.length === 0) {\n      let updatedFetchers2 = markFetchRedirectsDone();\n      completeNavigation(\n        location,\n        {\n          matches,\n          loaderData: {},\n          // Commit pending error if we're short circuiting\n          errors: pendingActionResult && isErrorResult(pendingActionResult[1]) ? { [pendingActionResult[0]]: pendingActionResult[1].error } : null,\n          ...getActionDataForCommit(pendingActionResult),\n          ...updatedFetchers2 ? { fetchers: new Map(state.fetchers) } : {}\n        },\n        { flushSync }\n      );\n      return { shortCircuited: true };\n    }\n    if (shouldUpdateNavigationState) {\n      let updates = {};\n      if (!isFogOfWar) {\n        updates.navigation = loadingNavigation;\n        let actionData = getUpdatedActionData(pendingActionResult);\n        if (actionData !== void 0) {\n          updates.actionData = actionData;\n        }\n      }\n      if (revalidatingFetchers.length > 0) {\n        updates.fetchers = getUpdatedRevalidatingFetchers(revalidatingFetchers);\n      }\n      updateState(updates, { flushSync });\n    }\n    revalidatingFetchers.forEach((rf) => {\n      abortFetcher(rf.key);\n      if (rf.controller) {\n        fetchControllers.set(rf.key, rf.controller);\n      }\n    });\n    let abortPendingFetchRevalidations = () => revalidatingFetchers.forEach((f) => abortFetcher(f.key));\n    if (pendingNavigationController) {\n      pendingNavigationController.signal.addEventListener(\n        \"abort\",\n        abortPendingFetchRevalidations\n      );\n    }\n    let { loaderResults, fetcherResults } = await callLoadersAndMaybeResolveData(\n      state,\n      matches,\n      matchesToLoad,\n      revalidatingFetchers,\n      request\n    );\n    if (request.signal.aborted) {\n      return { shortCircuited: true };\n    }\n    if (pendingNavigationController) {\n      pendingNavigationController.signal.removeEventListener(\n        \"abort\",\n        abortPendingFetchRevalidations\n      );\n    }\n    revalidatingFetchers.forEach((rf) => fetchControllers.delete(rf.key));\n    let redirect2 = findRedirect(loaderResults);\n    if (redirect2) {\n      await startRedirectNavigation(request, redirect2.result, true, {\n        replace: replace2\n      });\n      return { shortCircuited: true };\n    }\n    redirect2 = findRedirect(fetcherResults);\n    if (redirect2) {\n      fetchRedirectIds.add(redirect2.key);\n      await startRedirectNavigation(request, redirect2.result, true, {\n        replace: replace2\n      });\n      return { shortCircuited: true };\n    }\n    let { loaderData, errors } = processLoaderData(\n      state,\n      matches,\n      loaderResults,\n      pendingActionResult,\n      revalidatingFetchers,\n      fetcherResults\n    );\n    if (initialHydration && state.errors) {\n      errors = { ...state.errors, ...errors };\n    }\n    let updatedFetchers = markFetchRedirectsDone();\n    let didAbortFetchLoads = abortStaleFetchLoads(pendingNavigationLoadId);\n    let shouldUpdateFetchers = updatedFetchers || didAbortFetchLoads || revalidatingFetchers.length > 0;\n    return {\n      matches,\n      loaderData,\n      errors,\n      ...shouldUpdateFetchers ? { fetchers: new Map(state.fetchers) } : {}\n    };\n  }\n  function getUpdatedActionData(pendingActionResult) {\n    if (pendingActionResult && !isErrorResult(pendingActionResult[1])) {\n      return {\n        [pendingActionResult[0]]: pendingActionResult[1].data\n      };\n    } else if (state.actionData) {\n      if (Object.keys(state.actionData).length === 0) {\n        return null;\n      } else {\n        return state.actionData;\n      }\n    }\n  }\n  function getUpdatedRevalidatingFetchers(revalidatingFetchers) {\n    revalidatingFetchers.forEach((rf) => {\n      let fetcher = state.fetchers.get(rf.key);\n      let revalidatingFetcher = getLoadingFetcher(\n        void 0,\n        fetcher ? fetcher.data : void 0\n      );\n      state.fetchers.set(rf.key, revalidatingFetcher);\n    });\n    return new Map(state.fetchers);\n  }\n  async function fetch2(key, routeId, href, opts) {\n    abortFetcher(key);\n    let flushSync = (opts && opts.flushSync) === true;\n    let routesToUse = inFlightDataRoutes || dataRoutes;\n    let normalizedPath = normalizeTo(\n      state.location,\n      state.matches,\n      basename,\n      href,\n      routeId,\n      opts?.relative\n    );\n    let matches = matchRoutes(routesToUse, normalizedPath, basename);\n    let fogOfWar = checkFogOfWar(matches, routesToUse, normalizedPath);\n    if (fogOfWar.active && fogOfWar.matches) {\n      matches = fogOfWar.matches;\n    }\n    if (!matches) {\n      setFetcherError(\n        key,\n        routeId,\n        getInternalRouterError(404, { pathname: normalizedPath }),\n        { flushSync }\n      );\n      return;\n    }\n    let { path, submission, error } = normalizeNavigateOptions(\n      true,\n      normalizedPath,\n      opts\n    );\n    if (error) {\n      setFetcherError(key, routeId, error, { flushSync });\n      return;\n    }\n    let match = getTargetMatch(matches, path);\n    let preventScrollReset = (opts && opts.preventScrollReset) === true;\n    if (submission && isMutationMethod(submission.formMethod)) {\n      await handleFetcherAction(\n        key,\n        routeId,\n        path,\n        match,\n        matches,\n        fogOfWar.active,\n        flushSync,\n        preventScrollReset,\n        submission\n      );\n      return;\n    }\n    fetchLoadMatches.set(key, { routeId, path });\n    await handleFetcherLoader(\n      key,\n      routeId,\n      path,\n      match,\n      matches,\n      fogOfWar.active,\n      flushSync,\n      preventScrollReset,\n      submission\n    );\n  }\n  async function handleFetcherAction(key, routeId, path, match, requestMatches, isFogOfWar, flushSync, preventScrollReset, submission) {\n    interruptActiveLoads();\n    fetchLoadMatches.delete(key);\n    function detectAndHandle405Error(m) {\n      if (!m.route.action && !m.route.lazy) {\n        let error = getInternalRouterError(405, {\n          method: submission.formMethod,\n          pathname: path,\n          routeId\n        });\n        setFetcherError(key, routeId, error, { flushSync });\n        return true;\n      }\n      return false;\n    }\n    if (!isFogOfWar && detectAndHandle405Error(match)) {\n      return;\n    }\n    let existingFetcher = state.fetchers.get(key);\n    updateFetcherState(key, getSubmittingFetcher(submission, existingFetcher), {\n      flushSync\n    });\n    let abortController = new AbortController();\n    let fetchRequest = createClientSideRequest(\n      init.history,\n      path,\n      abortController.signal,\n      submission\n    );\n    if (isFogOfWar) {\n      let discoverResult = await discoverRoutes(\n        requestMatches,\n        path,\n        fetchRequest.signal\n      );\n      if (discoverResult.type === \"aborted\") {\n        return;\n      } else if (discoverResult.type === \"error\") {\n        setFetcherError(key, routeId, discoverResult.error, { flushSync });\n        return;\n      } else if (!discoverResult.matches) {\n        setFetcherError(\n          key,\n          routeId,\n          getInternalRouterError(404, { pathname: path }),\n          { flushSync }\n        );\n        return;\n      } else {\n        requestMatches = discoverResult.matches;\n        match = getTargetMatch(requestMatches, path);\n        if (detectAndHandle405Error(match)) {\n          return;\n        }\n      }\n    }\n    fetchControllers.set(key, abortController);\n    let originatingLoadId = incrementingLoadId;\n    let actionResults = await callDataStrategy(\n      \"action\",\n      state,\n      fetchRequest,\n      [match],\n      requestMatches,\n      key\n    );\n    let actionResult = actionResults[match.route.id];\n    if (fetchRequest.signal.aborted) {\n      if (fetchControllers.get(key) === abortController) {\n        fetchControllers.delete(key);\n      }\n      return;\n    }\n    if (fetchersQueuedForDeletion.has(key)) {\n      if (isRedirectResult(actionResult) || isErrorResult(actionResult)) {\n        updateFetcherState(key, getDoneFetcher(void 0));\n        return;\n      }\n    } else {\n      if (isRedirectResult(actionResult)) {\n        fetchControllers.delete(key);\n        if (pendingNavigationLoadId > originatingLoadId) {\n          updateFetcherState(key, getDoneFetcher(void 0));\n          return;\n        } else {\n          fetchRedirectIds.add(key);\n          updateFetcherState(key, getLoadingFetcher(submission));\n          return startRedirectNavigation(fetchRequest, actionResult, false, {\n            fetcherSubmission: submission,\n            preventScrollReset\n          });\n        }\n      }\n      if (isErrorResult(actionResult)) {\n        setFetcherError(key, routeId, actionResult.error);\n        return;\n      }\n    }\n    let nextLocation = state.navigation.location || state.location;\n    let revalidationRequest = createClientSideRequest(\n      init.history,\n      nextLocation,\n      abortController.signal\n    );\n    let routesToUse = inFlightDataRoutes || dataRoutes;\n    let matches = state.navigation.state !== \"idle\" ? matchRoutes(routesToUse, state.navigation.location, basename) : state.matches;\n    invariant(matches, \"Didn't find any matches after fetcher action\");\n    let loadId = ++incrementingLoadId;\n    fetchReloadIds.set(key, loadId);\n    let loadFetcher = getLoadingFetcher(submission, actionResult.data);\n    state.fetchers.set(key, loadFetcher);\n    let [matchesToLoad, revalidatingFetchers] = getMatchesToLoad(\n      init.history,\n      state,\n      matches,\n      submission,\n      nextLocation,\n      false,\n      isRevalidationRequired,\n      cancelledFetcherLoads,\n      fetchersQueuedForDeletion,\n      fetchLoadMatches,\n      fetchRedirectIds,\n      routesToUse,\n      basename,\n      [match.route.id, actionResult]\n    );\n    revalidatingFetchers.filter((rf) => rf.key !== key).forEach((rf) => {\n      let staleKey = rf.key;\n      let existingFetcher2 = state.fetchers.get(staleKey);\n      let revalidatingFetcher = getLoadingFetcher(\n        void 0,\n        existingFetcher2 ? existingFetcher2.data : void 0\n      );\n      state.fetchers.set(staleKey, revalidatingFetcher);\n      abortFetcher(staleKey);\n      if (rf.controller) {\n        fetchControllers.set(staleKey, rf.controller);\n      }\n    });\n    updateState({ fetchers: new Map(state.fetchers) });\n    let abortPendingFetchRevalidations = () => revalidatingFetchers.forEach((rf) => abortFetcher(rf.key));\n    abortController.signal.addEventListener(\n      \"abort\",\n      abortPendingFetchRevalidations\n    );\n    let { loaderResults, fetcherResults } = await callLoadersAndMaybeResolveData(\n      state,\n      matches,\n      matchesToLoad,\n      revalidatingFetchers,\n      revalidationRequest\n    );\n    if (abortController.signal.aborted) {\n      return;\n    }\n    abortController.signal.removeEventListener(\n      \"abort\",\n      abortPendingFetchRevalidations\n    );\n    fetchReloadIds.delete(key);\n    fetchControllers.delete(key);\n    revalidatingFetchers.forEach((r) => fetchControllers.delete(r.key));\n    let redirect2 = findRedirect(loaderResults);\n    if (redirect2) {\n      return startRedirectNavigation(\n        revalidationRequest,\n        redirect2.result,\n        false,\n        { preventScrollReset }\n      );\n    }\n    redirect2 = findRedirect(fetcherResults);\n    if (redirect2) {\n      fetchRedirectIds.add(redirect2.key);\n      return startRedirectNavigation(\n        revalidationRequest,\n        redirect2.result,\n        false,\n        { preventScrollReset }\n      );\n    }\n    let { loaderData, errors } = processLoaderData(\n      state,\n      matches,\n      loaderResults,\n      void 0,\n      revalidatingFetchers,\n      fetcherResults\n    );\n    if (state.fetchers.has(key)) {\n      let doneFetcher = getDoneFetcher(actionResult.data);\n      state.fetchers.set(key, doneFetcher);\n    }\n    abortStaleFetchLoads(loadId);\n    if (state.navigation.state === \"loading\" && loadId > pendingNavigationLoadId) {\n      invariant(pendingAction, \"Expected pending action\");\n      pendingNavigationController && pendingNavigationController.abort();\n      completeNavigation(state.navigation.location, {\n        matches,\n        loaderData,\n        errors,\n        fetchers: new Map(state.fetchers)\n      });\n    } else {\n      updateState({\n        errors,\n        loaderData: mergeLoaderData(\n          state.loaderData,\n          loaderData,\n          matches,\n          errors\n        ),\n        fetchers: new Map(state.fetchers)\n      });\n      isRevalidationRequired = false;\n    }\n  }\n  async function handleFetcherLoader(key, routeId, path, match, matches, isFogOfWar, flushSync, preventScrollReset, submission) {\n    let existingFetcher = state.fetchers.get(key);\n    updateFetcherState(\n      key,\n      getLoadingFetcher(\n        submission,\n        existingFetcher ? existingFetcher.data : void 0\n      ),\n      { flushSync }\n    );\n    let abortController = new AbortController();\n    let fetchRequest = createClientSideRequest(\n      init.history,\n      path,\n      abortController.signal\n    );\n    if (isFogOfWar) {\n      let discoverResult = await discoverRoutes(\n        matches,\n        path,\n        fetchRequest.signal\n      );\n      if (discoverResult.type === \"aborted\") {\n        return;\n      } else if (discoverResult.type === \"error\") {\n        setFetcherError(key, routeId, discoverResult.error, { flushSync });\n        return;\n      } else if (!discoverResult.matches) {\n        setFetcherError(\n          key,\n          routeId,\n          getInternalRouterError(404, { pathname: path }),\n          { flushSync }\n        );\n        return;\n      } else {\n        matches = discoverResult.matches;\n        match = getTargetMatch(matches, path);\n      }\n    }\n    fetchControllers.set(key, abortController);\n    let originatingLoadId = incrementingLoadId;\n    let results = await callDataStrategy(\n      \"loader\",\n      state,\n      fetchRequest,\n      [match],\n      matches,\n      key\n    );\n    let result = results[match.route.id];\n    if (fetchControllers.get(key) === abortController) {\n      fetchControllers.delete(key);\n    }\n    if (fetchRequest.signal.aborted) {\n      return;\n    }\n    if (fetchersQueuedForDeletion.has(key)) {\n      updateFetcherState(key, getDoneFetcher(void 0));\n      return;\n    }\n    if (isRedirectResult(result)) {\n      if (pendingNavigationLoadId > originatingLoadId) {\n        updateFetcherState(key, getDoneFetcher(void 0));\n        return;\n      } else {\n        fetchRedirectIds.add(key);\n        await startRedirectNavigation(fetchRequest, result, false, {\n          preventScrollReset\n        });\n        return;\n      }\n    }\n    if (isErrorResult(result)) {\n      setFetcherError(key, routeId, result.error);\n      return;\n    }\n    updateFetcherState(key, getDoneFetcher(result.data));\n  }\n  async function startRedirectNavigation(request, redirect2, isNavigation, {\n    submission,\n    fetcherSubmission,\n    preventScrollReset,\n    replace: replace2\n  } = {}) {\n    if (redirect2.response.headers.has(\"X-Remix-Revalidate\")) {\n      isRevalidationRequired = true;\n    }\n    let location = redirect2.response.headers.get(\"Location\");\n    invariant(location, \"Expected a Location header on the redirect Response\");\n    location = normalizeRedirectLocation(\n      location,\n      new URL(request.url),\n      basename\n    );\n    let redirectLocation = createLocation(state.location, location, {\n      _isRedirect: true\n    });\n    if (isBrowser2) {\n      let isDocumentReload = false;\n      if (redirect2.response.headers.has(\"X-Remix-Reload-Document\")) {\n        isDocumentReload = true;\n      } else if (ABSOLUTE_URL_REGEX.test(location)) {\n        const url = init.history.createURL(location);\n        isDocumentReload = // Hard reload if it's an absolute URL to a new origin\n        url.origin !== routerWindow.location.origin || // Hard reload if it's an absolute URL that does not match our basename\n        stripBasename(url.pathname, basename) == null;\n      }\n      if (isDocumentReload) {\n        if (replace2) {\n          routerWindow.location.replace(location);\n        } else {\n          routerWindow.location.assign(location);\n        }\n        return;\n      }\n    }\n    pendingNavigationController = null;\n    let redirectNavigationType = replace2 === true || redirect2.response.headers.has(\"X-Remix-Replace\") ? \"REPLACE\" /* Replace */ : \"PUSH\" /* Push */;\n    let { formMethod, formAction, formEncType } = state.navigation;\n    if (!submission && !fetcherSubmission && formMethod && formAction && formEncType) {\n      submission = getSubmissionFromNavigation(state.navigation);\n    }\n    let activeSubmission = submission || fetcherSubmission;\n    if (redirectPreserveMethodStatusCodes.has(redirect2.response.status) && activeSubmission && isMutationMethod(activeSubmission.formMethod)) {\n      await startNavigation(redirectNavigationType, redirectLocation, {\n        submission: {\n          ...activeSubmission,\n          formAction: location\n        },\n        // Preserve these flags across redirects\n        preventScrollReset: preventScrollReset || pendingPreventScrollReset,\n        enableViewTransition: isNavigation ? pendingViewTransitionEnabled : void 0\n      });\n    } else {\n      let overrideNavigation = getLoadingNavigation(\n        redirectLocation,\n        submission\n      );\n      await startNavigation(redirectNavigationType, redirectLocation, {\n        overrideNavigation,\n        // Send fetcher submissions through for shouldRevalidate\n        fetcherSubmission,\n        // Preserve these flags across redirects\n        preventScrollReset: preventScrollReset || pendingPreventScrollReset,\n        enableViewTransition: isNavigation ? pendingViewTransitionEnabled : void 0\n      });\n    }\n  }\n  async function callDataStrategy(type, state2, request, matchesToLoad, matches, fetcherKey) {\n    let results;\n    let dataResults = {};\n    try {\n      results = await callDataStrategyImpl(\n        dataStrategyImpl,\n        type,\n        state2,\n        request,\n        matchesToLoad,\n        matches,\n        fetcherKey,\n        manifest,\n        mapRouteProperties2\n      );\n    } catch (e) {\n      matchesToLoad.forEach((m) => {\n        dataResults[m.route.id] = {\n          type: \"error\" /* error */,\n          error: e\n        };\n      });\n      return dataResults;\n    }\n    for (let [routeId, result] of Object.entries(results)) {\n      if (isRedirectDataStrategyResult(result)) {\n        let response = result.result;\n        dataResults[routeId] = {\n          type: \"redirect\" /* redirect */,\n          response: normalizeRelativeRoutingRedirectResponse(\n            response,\n            request,\n            routeId,\n            matches,\n            basename\n          )\n        };\n      } else {\n        dataResults[routeId] = await convertDataStrategyResultToDataResult(\n          result\n        );\n      }\n    }\n    return dataResults;\n  }\n  async function callLoadersAndMaybeResolveData(state2, matches, matchesToLoad, fetchersToLoad, request) {\n    let loaderResultsPromise = callDataStrategy(\n      \"loader\",\n      state2,\n      request,\n      matchesToLoad,\n      matches,\n      null\n    );\n    let fetcherResultsPromise = Promise.all(\n      fetchersToLoad.map(async (f) => {\n        if (f.matches && f.match && f.controller) {\n          let results = await callDataStrategy(\n            \"loader\",\n            state2,\n            createClientSideRequest(init.history, f.path, f.controller.signal),\n            [f.match],\n            f.matches,\n            f.key\n          );\n          let result = results[f.match.route.id];\n          return { [f.key]: result };\n        } else {\n          return Promise.resolve({\n            [f.key]: {\n              type: \"error\" /* error */,\n              error: getInternalRouterError(404, {\n                pathname: f.path\n              })\n            }\n          });\n        }\n      })\n    );\n    let loaderResults = await loaderResultsPromise;\n    let fetcherResults = (await fetcherResultsPromise).reduce(\n      (acc, r) => Object.assign(acc, r),\n      {}\n    );\n    return {\n      loaderResults,\n      fetcherResults\n    };\n  }\n  function interruptActiveLoads() {\n    isRevalidationRequired = true;\n    fetchLoadMatches.forEach((_, key) => {\n      if (fetchControllers.has(key)) {\n        cancelledFetcherLoads.add(key);\n      }\n      abortFetcher(key);\n    });\n  }\n  function updateFetcherState(key, fetcher, opts = {}) {\n    state.fetchers.set(key, fetcher);\n    updateState(\n      { fetchers: new Map(state.fetchers) },\n      { flushSync: (opts && opts.flushSync) === true }\n    );\n  }\n  function setFetcherError(key, routeId, error, opts = {}) {\n    let boundaryMatch = findNearestBoundary(state.matches, routeId);\n    deleteFetcher(key);\n    updateState(\n      {\n        errors: {\n          [boundaryMatch.route.id]: error\n        },\n        fetchers: new Map(state.fetchers)\n      },\n      { flushSync: (opts && opts.flushSync) === true }\n    );\n  }\n  function getFetcher(key) {\n    activeFetchers.set(key, (activeFetchers.get(key) || 0) + 1);\n    if (fetchersQueuedForDeletion.has(key)) {\n      fetchersQueuedForDeletion.delete(key);\n    }\n    return state.fetchers.get(key) || IDLE_FETCHER;\n  }\n  function deleteFetcher(key) {\n    let fetcher = state.fetchers.get(key);\n    if (fetchControllers.has(key) && !(fetcher && fetcher.state === \"loading\" && fetchReloadIds.has(key))) {\n      abortFetcher(key);\n    }\n    fetchLoadMatches.delete(key);\n    fetchReloadIds.delete(key);\n    fetchRedirectIds.delete(key);\n    fetchersQueuedForDeletion.delete(key);\n    cancelledFetcherLoads.delete(key);\n    state.fetchers.delete(key);\n  }\n  function queueFetcherForDeletion(key) {\n    let count = (activeFetchers.get(key) || 0) - 1;\n    if (count <= 0) {\n      activeFetchers.delete(key);\n      fetchersQueuedForDeletion.add(key);\n    } else {\n      activeFetchers.set(key, count);\n    }\n    updateState({ fetchers: new Map(state.fetchers) });\n  }\n  function abortFetcher(key) {\n    let controller = fetchControllers.get(key);\n    if (controller) {\n      controller.abort();\n      fetchControllers.delete(key);\n    }\n  }\n  function markFetchersDone(keys) {\n    for (let key of keys) {\n      let fetcher = getFetcher(key);\n      let doneFetcher = getDoneFetcher(fetcher.data);\n      state.fetchers.set(key, doneFetcher);\n    }\n  }\n  function markFetchRedirectsDone() {\n    let doneKeys = [];\n    let updatedFetchers = false;\n    for (let key of fetchRedirectIds) {\n      let fetcher = state.fetchers.get(key);\n      invariant(fetcher, `Expected fetcher: ${key}`);\n      if (fetcher.state === \"loading\") {\n        fetchRedirectIds.delete(key);\n        doneKeys.push(key);\n        updatedFetchers = true;\n      }\n    }\n    markFetchersDone(doneKeys);\n    return updatedFetchers;\n  }\n  function abortStaleFetchLoads(landedId) {\n    let yeetedKeys = [];\n    for (let [key, id] of fetchReloadIds) {\n      if (id < landedId) {\n        let fetcher = state.fetchers.get(key);\n        invariant(fetcher, `Expected fetcher: ${key}`);\n        if (fetcher.state === \"loading\") {\n          abortFetcher(key);\n          fetchReloadIds.delete(key);\n          yeetedKeys.push(key);\n        }\n      }\n    }\n    markFetchersDone(yeetedKeys);\n    return yeetedKeys.length > 0;\n  }\n  function getBlocker(key, fn) {\n    let blocker = state.blockers.get(key) || IDLE_BLOCKER;\n    if (blockerFunctions.get(key) !== fn) {\n      blockerFunctions.set(key, fn);\n    }\n    return blocker;\n  }\n  function deleteBlocker(key) {\n    state.blockers.delete(key);\n    blockerFunctions.delete(key);\n  }\n  function updateBlocker(key, newBlocker) {\n    let blocker = state.blockers.get(key) || IDLE_BLOCKER;\n    invariant(\n      blocker.state === \"unblocked\" && newBlocker.state === \"blocked\" || blocker.state === \"blocked\" && newBlocker.state === \"blocked\" || blocker.state === \"blocked\" && newBlocker.state === \"proceeding\" || blocker.state === \"blocked\" && newBlocker.state === \"unblocked\" || blocker.state === \"proceeding\" && newBlocker.state === \"unblocked\",\n      `Invalid blocker state transition: ${blocker.state} -> ${newBlocker.state}`\n    );\n    let blockers = new Map(state.blockers);\n    blockers.set(key, newBlocker);\n    updateState({ blockers });\n  }\n  function shouldBlockNavigation({\n    currentLocation,\n    nextLocation,\n    historyAction\n  }) {\n    if (blockerFunctions.size === 0) {\n      return;\n    }\n    if (blockerFunctions.size > 1) {\n      warning(false, \"A router only supports one blocker at a time\");\n    }\n    let entries = Array.from(blockerFunctions.entries());\n    let [blockerKey, blockerFunction] = entries[entries.length - 1];\n    let blocker = state.blockers.get(blockerKey);\n    if (blocker && blocker.state === \"proceeding\") {\n      return;\n    }\n    if (blockerFunction({ currentLocation, nextLocation, historyAction })) {\n      return blockerKey;\n    }\n  }\n  function handleNavigational404(pathname) {\n    let error = getInternalRouterError(404, { pathname });\n    let routesToUse = inFlightDataRoutes || dataRoutes;\n    let { matches, route } = getShortCircuitMatches(routesToUse);\n    return { notFoundMatches: matches, route, error };\n  }\n  function enableScrollRestoration(positions, getPosition, getKey) {\n    savedScrollPositions2 = positions;\n    getScrollPosition = getPosition;\n    getScrollRestorationKey2 = getKey || null;\n    if (!initialScrollRestored && state.navigation === IDLE_NAVIGATION) {\n      initialScrollRestored = true;\n      let y = getSavedScrollPosition(state.location, state.matches);\n      if (y != null) {\n        updateState({ restoreScrollPosition: y });\n      }\n    }\n    return () => {\n      savedScrollPositions2 = null;\n      getScrollPosition = null;\n      getScrollRestorationKey2 = null;\n    };\n  }\n  function getScrollKey(location, matches) {\n    if (getScrollRestorationKey2) {\n      let key = getScrollRestorationKey2(\n        location,\n        matches.map((m) => convertRouteMatchToUiMatch(m, state.loaderData))\n      );\n      return key || location.key;\n    }\n    return location.key;\n  }\n  function saveScrollPosition(location, matches) {\n    if (savedScrollPositions2 && getScrollPosition) {\n      let key = getScrollKey(location, matches);\n      savedScrollPositions2[key] = getScrollPosition();\n    }\n  }\n  function getSavedScrollPosition(location, matches) {\n    if (savedScrollPositions2) {\n      let key = getScrollKey(location, matches);\n      let y = savedScrollPositions2[key];\n      if (typeof y === \"number\") {\n        return y;\n      }\n    }\n    return null;\n  }\n  function checkFogOfWar(matches, routesToUse, pathname) {\n    if (patchRoutesOnNavigationImpl) {\n      if (!matches) {\n        let fogMatches = matchRoutesImpl(\n          routesToUse,\n          pathname,\n          basename,\n          true\n        );\n        return { active: true, matches: fogMatches || [] };\n      } else {\n        if (Object.keys(matches[0].params).length > 0) {\n          let partialMatches = matchRoutesImpl(\n            routesToUse,\n            pathname,\n            basename,\n            true\n          );\n          return { active: true, matches: partialMatches };\n        }\n      }\n    }\n    return { active: false, matches: null };\n  }\n  async function discoverRoutes(matches, pathname, signal) {\n    if (!patchRoutesOnNavigationImpl) {\n      return { type: \"success\", matches };\n    }\n    let partialMatches = matches;\n    while (true) {\n      let isNonHMR = inFlightDataRoutes == null;\n      let routesToUse = inFlightDataRoutes || dataRoutes;\n      let localManifest = manifest;\n      try {\n        await patchRoutesOnNavigationImpl({\n          path: pathname,\n          matches: partialMatches,\n          patch: (routeId, children) => {\n            if (signal.aborted) return;\n            patchRoutesImpl(\n              routeId,\n              children,\n              routesToUse,\n              localManifest,\n              mapRouteProperties2\n            );\n          }\n        });\n      } catch (e) {\n        return { type: \"error\", error: e, partialMatches };\n      } finally {\n        if (isNonHMR && !signal.aborted) {\n          dataRoutes = [...dataRoutes];\n        }\n      }\n      if (signal.aborted) {\n        return { type: \"aborted\" };\n      }\n      let newMatches = matchRoutes(routesToUse, pathname, basename);\n      if (newMatches) {\n        return { type: \"success\", matches: newMatches };\n      }\n      let newPartialMatches = matchRoutesImpl(\n        routesToUse,\n        pathname,\n        basename,\n        true\n      );\n      if (!newPartialMatches || partialMatches.length === newPartialMatches.length && partialMatches.every(\n        (m, i) => m.route.id === newPartialMatches[i].route.id\n      )) {\n        return { type: \"success\", matches: null };\n      }\n      partialMatches = newPartialMatches;\n    }\n  }\n  function _internalSetRoutes(newRoutes) {\n    manifest = {};\n    inFlightDataRoutes = convertRoutesToDataRoutes(\n      newRoutes,\n      mapRouteProperties2,\n      void 0,\n      manifest\n    );\n  }\n  function patchRoutes(routeId, children) {\n    let isNonHMR = inFlightDataRoutes == null;\n    let routesToUse = inFlightDataRoutes || dataRoutes;\n    patchRoutesImpl(\n      routeId,\n      children,\n      routesToUse,\n      manifest,\n      mapRouteProperties2\n    );\n    if (isNonHMR) {\n      dataRoutes = [...dataRoutes];\n      updateState({});\n    }\n  }\n  router = {\n    get basename() {\n      return basename;\n    },\n    get future() {\n      return future;\n    },\n    get state() {\n      return state;\n    },\n    get routes() {\n      return dataRoutes;\n    },\n    get window() {\n      return routerWindow;\n    },\n    initialize,\n    subscribe,\n    enableScrollRestoration,\n    navigate,\n    fetch: fetch2,\n    revalidate,\n    // Passthrough to history-aware createHref used by useHref so we get proper\n    // hash-aware URLs in DOM paths\n    createHref: (to) => init.history.createHref(to),\n    encodeLocation: (to) => init.history.encodeLocation(to),\n    getFetcher,\n    deleteFetcher: queueFetcherForDeletion,\n    dispose,\n    getBlocker,\n    deleteBlocker,\n    patchRoutes,\n    _internalFetchControllers: fetchControllers,\n    // TODO: Remove setRoutes, it's temporary to avoid dealing with\n    // updating the tree while validating the update algorithm.\n    _internalSetRoutes\n  };\n  return router;\n}\nfunction createStaticHandler(routes, opts) {\n  invariant(\n    routes.length > 0,\n    \"You must provide a non-empty routes array to createStaticHandler\"\n  );\n  let manifest = {};\n  let basename = (opts ? opts.basename : null) || \"/\";\n  let mapRouteProperties2 = opts?.mapRouteProperties || defaultMapRouteProperties;\n  let dataRoutes = convertRoutesToDataRoutes(\n    routes,\n    mapRouteProperties2,\n    void 0,\n    manifest\n  );\n  async function query(request, {\n    requestContext,\n    skipLoaderErrorBubbling,\n    dataStrategy\n  } = {}) {\n    let url = new URL(request.url);\n    let method = request.method;\n    let location = createLocation(\"\", createPath(url), null, \"default\");\n    let matches = matchRoutes(dataRoutes, location, basename);\n    if (!isValidMethod(method) && method !== \"HEAD\") {\n      let error = getInternalRouterError(405, { method });\n      let { matches: methodNotAllowedMatches, route } = getShortCircuitMatches(dataRoutes);\n      return {\n        basename,\n        location,\n        matches: methodNotAllowedMatches,\n        loaderData: {},\n        actionData: null,\n        errors: {\n          [route.id]: error\n        },\n        statusCode: error.status,\n        loaderHeaders: {},\n        actionHeaders: {}\n      };\n    } else if (!matches) {\n      let error = getInternalRouterError(404, { pathname: location.pathname });\n      let { matches: notFoundMatches, route } = getShortCircuitMatches(dataRoutes);\n      return {\n        basename,\n        location,\n        matches: notFoundMatches,\n        loaderData: {},\n        actionData: null,\n        errors: {\n          [route.id]: error\n        },\n        statusCode: error.status,\n        loaderHeaders: {},\n        actionHeaders: {}\n      };\n    }\n    let result = await queryImpl(\n      request,\n      location,\n      matches,\n      requestContext,\n      dataStrategy || null,\n      skipLoaderErrorBubbling === true,\n      null\n    );\n    if (isResponse(result)) {\n      return result;\n    }\n    return { location, basename, ...result };\n  }\n  async function queryRoute(request, {\n    routeId,\n    requestContext,\n    dataStrategy\n  } = {}) {\n    let url = new URL(request.url);\n    let method = request.method;\n    let location = createLocation(\"\", createPath(url), null, \"default\");\n    let matches = matchRoutes(dataRoutes, location, basename);\n    if (!isValidMethod(method) && method !== \"HEAD\" && method !== \"OPTIONS\") {\n      throw getInternalRouterError(405, { method });\n    } else if (!matches) {\n      throw getInternalRouterError(404, { pathname: location.pathname });\n    }\n    let match = routeId ? matches.find((m) => m.route.id === routeId) : getTargetMatch(matches, location);\n    if (routeId && !match) {\n      throw getInternalRouterError(403, {\n        pathname: location.pathname,\n        routeId\n      });\n    } else if (!match) {\n      throw getInternalRouterError(404, { pathname: location.pathname });\n    }\n    let result = await queryImpl(\n      request,\n      location,\n      matches,\n      requestContext,\n      dataStrategy || null,\n      false,\n      match\n    );\n    if (isResponse(result)) {\n      return result;\n    }\n    let error = result.errors ? Object.values(result.errors)[0] : void 0;\n    if (error !== void 0) {\n      throw error;\n    }\n    if (result.actionData) {\n      return Object.values(result.actionData)[0];\n    }\n    if (result.loaderData) {\n      return Object.values(result.loaderData)[0];\n    }\n    return void 0;\n  }\n  async function queryImpl(request, location, matches, requestContext, dataStrategy, skipLoaderErrorBubbling, routeMatch) {\n    invariant(\n      request.signal,\n      \"query()/queryRoute() requests must contain an AbortController signal\"\n    );\n    try {\n      if (isMutationMethod(request.method)) {\n        let result2 = await submit(\n          request,\n          matches,\n          routeMatch || getTargetMatch(matches, location),\n          requestContext,\n          dataStrategy,\n          skipLoaderErrorBubbling,\n          routeMatch != null\n        );\n        return result2;\n      }\n      let result = await loadRouteData(\n        request,\n        matches,\n        requestContext,\n        dataStrategy,\n        skipLoaderErrorBubbling,\n        routeMatch\n      );\n      return isResponse(result) ? result : {\n        ...result,\n        actionData: null,\n        actionHeaders: {}\n      };\n    } catch (e) {\n      if (isDataStrategyResult(e) && isResponse(e.result)) {\n        if (e.type === \"error\" /* error */) {\n          throw e.result;\n        }\n        return e.result;\n      }\n      if (isRedirectResponse(e)) {\n        return e;\n      }\n      throw e;\n    }\n  }\n  async function submit(request, matches, actionMatch, requestContext, dataStrategy, skipLoaderErrorBubbling, isRouteRequest) {\n    let result;\n    if (!actionMatch.route.action && !actionMatch.route.lazy) {\n      let error = getInternalRouterError(405, {\n        method: request.method,\n        pathname: new URL(request.url).pathname,\n        routeId: actionMatch.route.id\n      });\n      if (isRouteRequest) {\n        throw error;\n      }\n      result = {\n        type: \"error\" /* error */,\n        error\n      };\n    } else {\n      let results = await callDataStrategy(\n        \"action\",\n        request,\n        [actionMatch],\n        matches,\n        isRouteRequest,\n        requestContext,\n        dataStrategy\n      );\n      result = results[actionMatch.route.id];\n      if (request.signal.aborted) {\n        throwStaticHandlerAbortedError(request, isRouteRequest);\n      }\n    }\n    if (isRedirectResult(result)) {\n      throw new Response(null, {\n        status: result.response.status,\n        headers: {\n          Location: result.response.headers.get(\"Location\")\n        }\n      });\n    }\n    if (isRouteRequest) {\n      if (isErrorResult(result)) {\n        throw result.error;\n      }\n      return {\n        matches: [actionMatch],\n        loaderData: {},\n        actionData: { [actionMatch.route.id]: result.data },\n        errors: null,\n        // Note: statusCode + headers are unused here since queryRoute will\n        // return the raw Response or value\n        statusCode: 200,\n        loaderHeaders: {},\n        actionHeaders: {}\n      };\n    }\n    let loaderRequest = new Request(request.url, {\n      headers: request.headers,\n      redirect: request.redirect,\n      signal: request.signal\n    });\n    if (isErrorResult(result)) {\n      let boundaryMatch = skipLoaderErrorBubbling ? actionMatch : findNearestBoundary(matches, actionMatch.route.id);\n      let context2 = await loadRouteData(\n        loaderRequest,\n        matches,\n        requestContext,\n        dataStrategy,\n        skipLoaderErrorBubbling,\n        null,\n        [boundaryMatch.route.id, result]\n      );\n      return {\n        ...context2,\n        statusCode: isRouteErrorResponse(result.error) ? result.error.status : result.statusCode != null ? result.statusCode : 500,\n        actionData: null,\n        actionHeaders: {\n          ...result.headers ? { [actionMatch.route.id]: result.headers } : {}\n        }\n      };\n    }\n    let context = await loadRouteData(\n      loaderRequest,\n      matches,\n      requestContext,\n      dataStrategy,\n      skipLoaderErrorBubbling,\n      null\n    );\n    return {\n      ...context,\n      actionData: {\n        [actionMatch.route.id]: result.data\n      },\n      // action status codes take precedence over loader status codes\n      ...result.statusCode ? { statusCode: result.statusCode } : {},\n      actionHeaders: result.headers ? { [actionMatch.route.id]: result.headers } : {}\n    };\n  }\n  async function loadRouteData(request, matches, requestContext, dataStrategy, skipLoaderErrorBubbling, routeMatch, pendingActionResult) {\n    let isRouteRequest = routeMatch != null;\n    if (isRouteRequest && !routeMatch?.route.loader && !routeMatch?.route.lazy) {\n      throw getInternalRouterError(400, {\n        method: request.method,\n        pathname: new URL(request.url).pathname,\n        routeId: routeMatch?.route.id\n      });\n    }\n    let requestMatches = routeMatch ? [routeMatch] : pendingActionResult && isErrorResult(pendingActionResult[1]) ? getLoaderMatchesUntilBoundary(matches, pendingActionResult[0]) : matches;\n    let matchesToLoad = requestMatches.filter(\n      (m) => m.route.loader || m.route.lazy\n    );\n    if (matchesToLoad.length === 0) {\n      return {\n        matches,\n        // Add a null for all matched routes for proper revalidation on the client\n        loaderData: matches.reduce(\n          (acc, m) => Object.assign(acc, { [m.route.id]: null }),\n          {}\n        ),\n        errors: pendingActionResult && isErrorResult(pendingActionResult[1]) ? {\n          [pendingActionResult[0]]: pendingActionResult[1].error\n        } : null,\n        statusCode: 200,\n        loaderHeaders: {}\n      };\n    }\n    let results = await callDataStrategy(\n      \"loader\",\n      request,\n      matchesToLoad,\n      matches,\n      isRouteRequest,\n      requestContext,\n      dataStrategy\n    );\n    if (request.signal.aborted) {\n      throwStaticHandlerAbortedError(request, isRouteRequest);\n    }\n    let context = processRouteLoaderData(\n      matches,\n      results,\n      pendingActionResult,\n      true,\n      skipLoaderErrorBubbling\n    );\n    let executedLoaders = new Set(\n      matchesToLoad.map((match) => match.route.id)\n    );\n    matches.forEach((match) => {\n      if (!executedLoaders.has(match.route.id)) {\n        context.loaderData[match.route.id] = null;\n      }\n    });\n    return {\n      ...context,\n      matches\n    };\n  }\n  async function callDataStrategy(type, request, matchesToLoad, matches, isRouteRequest, requestContext, dataStrategy) {\n    let results = await callDataStrategyImpl(\n      dataStrategy || defaultDataStrategy,\n      type,\n      null,\n      request,\n      matchesToLoad,\n      matches,\n      null,\n      manifest,\n      mapRouteProperties2,\n      requestContext\n    );\n    let dataResults = {};\n    await Promise.all(\n      matches.map(async (match) => {\n        if (!(match.route.id in results)) {\n          return;\n        }\n        let result = results[match.route.id];\n        if (isRedirectDataStrategyResult(result)) {\n          let response = result.result;\n          throw normalizeRelativeRoutingRedirectResponse(\n            response,\n            request,\n            match.route.id,\n            matches,\n            basename\n          );\n        }\n        if (isResponse(result.result) && isRouteRequest) {\n          throw result;\n        }\n        dataResults[match.route.id] = await convertDataStrategyResultToDataResult(result);\n      })\n    );\n    return dataResults;\n  }\n  return {\n    dataRoutes,\n    query,\n    queryRoute\n  };\n}\nfunction getStaticContextFromError(routes, context, error) {\n  let newContext = {\n    ...context,\n    statusCode: isRouteErrorResponse(error) ? error.status : 500,\n    errors: {\n      [context._deepestRenderedBoundaryId || routes[0].id]: error\n    }\n  };\n  return newContext;\n}\nfunction throwStaticHandlerAbortedError(request, isRouteRequest) {\n  if (request.signal.reason !== void 0) {\n    throw request.signal.reason;\n  }\n  let method = isRouteRequest ? \"queryRoute\" : \"query\";\n  throw new Error(\n    `${method}() call aborted without an \\`AbortSignal.reason\\`: ${request.method} ${request.url}`\n  );\n}\nfunction isSubmissionNavigation(opts) {\n  return opts != null && (\"formData\" in opts && opts.formData != null || \"body\" in opts && opts.body !== void 0);\n}\nfunction normalizeTo(location, matches, basename, to, fromRouteId, relative) {\n  let contextualMatches;\n  let activeRouteMatch;\n  if (fromRouteId) {\n    contextualMatches = [];\n    for (let match of matches) {\n      contextualMatches.push(match);\n      if (match.route.id === fromRouteId) {\n        activeRouteMatch = match;\n        break;\n      }\n    }\n  } else {\n    contextualMatches = matches;\n    activeRouteMatch = matches[matches.length - 1];\n  }\n  let path = resolveTo(\n    to ? to : \".\",\n    getResolveToMatches(contextualMatches),\n    stripBasename(location.pathname, basename) || location.pathname,\n    relative === \"path\"\n  );\n  if (to == null) {\n    path.search = location.search;\n    path.hash = location.hash;\n  }\n  if ((to == null || to === \"\" || to === \".\") && activeRouteMatch) {\n    let nakedIndex = hasNakedIndexQuery(path.search);\n    if (activeRouteMatch.route.index && !nakedIndex) {\n      path.search = path.search ? path.search.replace(/^\\?/, \"?index&\") : \"?index\";\n    } else if (!activeRouteMatch.route.index && nakedIndex) {\n      let params = new URLSearchParams(path.search);\n      let indexValues = params.getAll(\"index\");\n      params.delete(\"index\");\n      indexValues.filter((v) => v).forEach((v) => params.append(\"index\", v));\n      let qs = params.toString();\n      path.search = qs ? `?${qs}` : \"\";\n    }\n  }\n  if (basename !== \"/\") {\n    path.pathname = path.pathname === \"/\" ? basename : joinPaths([basename, path.pathname]);\n  }\n  return createPath(path);\n}\nfunction normalizeNavigateOptions(isFetcher, path, opts) {\n  if (!opts || !isSubmissionNavigation(opts)) {\n    return { path };\n  }\n  if (opts.formMethod && !isValidMethod(opts.formMethod)) {\n    return {\n      path,\n      error: getInternalRouterError(405, { method: opts.formMethod })\n    };\n  }\n  let getInvalidBodyError = () => ({\n    path,\n    error: getInternalRouterError(400, { type: \"invalid-body\" })\n  });\n  let rawFormMethod = opts.formMethod || \"get\";\n  let formMethod = rawFormMethod.toUpperCase();\n  let formAction = stripHashFromPath(path);\n  if (opts.body !== void 0) {\n    if (opts.formEncType === \"text/plain\") {\n      if (!isMutationMethod(formMethod)) {\n        return getInvalidBodyError();\n      }\n      let text = typeof opts.body === \"string\" ? opts.body : opts.body instanceof FormData || opts.body instanceof URLSearchParams ? (\n        // https://html.spec.whatwg.org/multipage/form-control-infrastructure.html#plain-text-form-data\n        Array.from(opts.body.entries()).reduce(\n          (acc, [name, value]) => `${acc}${name}=${value}\n`,\n          \"\"\n        )\n      ) : String(opts.body);\n      return {\n        path,\n        submission: {\n          formMethod,\n          formAction,\n          formEncType: opts.formEncType,\n          formData: void 0,\n          json: void 0,\n          text\n        }\n      };\n    } else if (opts.formEncType === \"application/json\") {\n      if (!isMutationMethod(formMethod)) {\n        return getInvalidBodyError();\n      }\n      try {\n        let json = typeof opts.body === \"string\" ? JSON.parse(opts.body) : opts.body;\n        return {\n          path,\n          submission: {\n            formMethod,\n            formAction,\n            formEncType: opts.formEncType,\n            formData: void 0,\n            json,\n            text: void 0\n          }\n        };\n      } catch (e) {\n        return getInvalidBodyError();\n      }\n    }\n  }\n  invariant(\n    typeof FormData === \"function\",\n    \"FormData is not available in this environment\"\n  );\n  let searchParams;\n  let formData;\n  if (opts.formData) {\n    searchParams = convertFormDataToSearchParams(opts.formData);\n    formData = opts.formData;\n  } else if (opts.body instanceof FormData) {\n    searchParams = convertFormDataToSearchParams(opts.body);\n    formData = opts.body;\n  } else if (opts.body instanceof URLSearchParams) {\n    searchParams = opts.body;\n    formData = convertSearchParamsToFormData(searchParams);\n  } else if (opts.body == null) {\n    searchParams = new URLSearchParams();\n    formData = new FormData();\n  } else {\n    try {\n      searchParams = new URLSearchParams(opts.body);\n      formData = convertSearchParamsToFormData(searchParams);\n    } catch (e) {\n      return getInvalidBodyError();\n    }\n  }\n  let submission = {\n    formMethod,\n    formAction,\n    formEncType: opts && opts.formEncType || \"application/x-www-form-urlencoded\",\n    formData,\n    json: void 0,\n    text: void 0\n  };\n  if (isMutationMethod(submission.formMethod)) {\n    return { path, submission };\n  }\n  let parsedPath = parsePath(path);\n  if (isFetcher && parsedPath.search && hasNakedIndexQuery(parsedPath.search)) {\n    searchParams.append(\"index\", \"\");\n  }\n  parsedPath.search = `?${searchParams}`;\n  return { path: createPath(parsedPath), submission };\n}\nfunction getLoaderMatchesUntilBoundary(matches, boundaryId, includeBoundary = false) {\n  let index = matches.findIndex((m) => m.route.id === boundaryId);\n  if (index >= 0) {\n    return matches.slice(0, includeBoundary ? index + 1 : index);\n  }\n  return matches;\n}\nfunction getMatchesToLoad(history, state, matches, submission, location, initialHydration, isRevalidationRequired, cancelledFetcherLoads, fetchersQueuedForDeletion, fetchLoadMatches, fetchRedirectIds, routesToUse, basename, pendingActionResult) {\n  let actionResult = pendingActionResult ? isErrorResult(pendingActionResult[1]) ? pendingActionResult[1].error : pendingActionResult[1].data : void 0;\n  let currentUrl = history.createURL(state.location);\n  let nextUrl = history.createURL(location);\n  let boundaryMatches = matches;\n  if (initialHydration && state.errors) {\n    boundaryMatches = getLoaderMatchesUntilBoundary(\n      matches,\n      Object.keys(state.errors)[0],\n      true\n    );\n  } else if (pendingActionResult && isErrorResult(pendingActionResult[1])) {\n    boundaryMatches = getLoaderMatchesUntilBoundary(\n      matches,\n      pendingActionResult[0]\n    );\n  }\n  let actionStatus = pendingActionResult ? pendingActionResult[1].statusCode : void 0;\n  let shouldSkipRevalidation = actionStatus && actionStatus >= 400;\n  let navigationMatches = boundaryMatches.filter((match, index) => {\n    let { route } = match;\n    if (route.lazy) {\n      return true;\n    }\n    if (route.loader == null) {\n      return false;\n    }\n    if (initialHydration) {\n      return shouldLoadRouteOnHydration(route, state.loaderData, state.errors);\n    }\n    if (isNewLoader(state.loaderData, state.matches[index], match)) {\n      return true;\n    }\n    let currentRouteMatch = state.matches[index];\n    let nextRouteMatch = match;\n    return shouldRevalidateLoader(match, {\n      currentUrl,\n      currentParams: currentRouteMatch.params,\n      nextUrl,\n      nextParams: nextRouteMatch.params,\n      ...submission,\n      actionResult,\n      actionStatus,\n      defaultShouldRevalidate: shouldSkipRevalidation ? false : (\n        // Forced revalidation due to submission, useRevalidator, or X-Remix-Revalidate\n        isRevalidationRequired || currentUrl.pathname + currentUrl.search === nextUrl.pathname + nextUrl.search || // Search params affect all loaders\n        currentUrl.search !== nextUrl.search || isNewRouteInstance(currentRouteMatch, nextRouteMatch)\n      )\n    });\n  });\n  let revalidatingFetchers = [];\n  fetchLoadMatches.forEach((f, key) => {\n    if (initialHydration || !matches.some((m) => m.route.id === f.routeId) || fetchersQueuedForDeletion.has(key)) {\n      return;\n    }\n    let fetcherMatches = matchRoutes(routesToUse, f.path, basename);\n    if (!fetcherMatches) {\n      revalidatingFetchers.push({\n        key,\n        routeId: f.routeId,\n        path: f.path,\n        matches: null,\n        match: null,\n        controller: null\n      });\n      return;\n    }\n    let fetcher = state.fetchers.get(key);\n    let fetcherMatch = getTargetMatch(fetcherMatches, f.path);\n    let shouldRevalidate = false;\n    if (fetchRedirectIds.has(key)) {\n      shouldRevalidate = false;\n    } else if (cancelledFetcherLoads.has(key)) {\n      cancelledFetcherLoads.delete(key);\n      shouldRevalidate = true;\n    } else if (fetcher && fetcher.state !== \"idle\" && fetcher.data === void 0) {\n      shouldRevalidate = isRevalidationRequired;\n    } else {\n      shouldRevalidate = shouldRevalidateLoader(fetcherMatch, {\n        currentUrl,\n        currentParams: state.matches[state.matches.length - 1].params,\n        nextUrl,\n        nextParams: matches[matches.length - 1].params,\n        ...submission,\n        actionResult,\n        actionStatus,\n        defaultShouldRevalidate: shouldSkipRevalidation ? false : isRevalidationRequired\n      });\n    }\n    if (shouldRevalidate) {\n      revalidatingFetchers.push({\n        key,\n        routeId: f.routeId,\n        path: f.path,\n        matches: fetcherMatches,\n        match: fetcherMatch,\n        controller: new AbortController()\n      });\n    }\n  });\n  return [navigationMatches, revalidatingFetchers];\n}\nfunction shouldLoadRouteOnHydration(route, loaderData, errors) {\n  if (route.lazy) {\n    return true;\n  }\n  if (!route.loader) {\n    return false;\n  }\n  let hasData = loaderData != null && loaderData[route.id] !== void 0;\n  let hasError = errors != null && errors[route.id] !== void 0;\n  if (!hasData && hasError) {\n    return false;\n  }\n  if (typeof route.loader === \"function\" && route.loader.hydrate === true) {\n    return true;\n  }\n  return !hasData && !hasError;\n}\nfunction isNewLoader(currentLoaderData, currentMatch, match) {\n  let isNew = (\n    // [a] -> [a, b]\n    !currentMatch || // [a, b] -> [a, c]\n    match.route.id !== currentMatch.route.id\n  );\n  let isMissingData = !currentLoaderData.hasOwnProperty(match.route.id);\n  return isNew || isMissingData;\n}\nfunction isNewRouteInstance(currentMatch, match) {\n  let currentPath = currentMatch.route.path;\n  return (\n    // param change for this match, /users/123 -> /users/456\n    currentMatch.pathname !== match.pathname || // splat param changed, which is not present in match.path\n    // e.g. /files/images/avatar.jpg -> files/finances.xls\n    currentPath != null && currentPath.endsWith(\"*\") && currentMatch.params[\"*\"] !== match.params[\"*\"]\n  );\n}\nfunction shouldRevalidateLoader(loaderMatch, arg) {\n  if (loaderMatch.route.shouldRevalidate) {\n    let routeChoice = loaderMatch.route.shouldRevalidate(arg);\n    if (typeof routeChoice === \"boolean\") {\n      return routeChoice;\n    }\n  }\n  return arg.defaultShouldRevalidate;\n}\nfunction patchRoutesImpl(routeId, children, routesToUse, manifest, mapRouteProperties2) {\n  let childrenToPatch;\n  if (routeId) {\n    let route = manifest[routeId];\n    invariant(\n      route,\n      `No route found to patch children into: routeId = ${routeId}`\n    );\n    if (!route.children) {\n      route.children = [];\n    }\n    childrenToPatch = route.children;\n  } else {\n    childrenToPatch = routesToUse;\n  }\n  let uniqueChildren = children.filter(\n    (newRoute) => !childrenToPatch.some(\n      (existingRoute) => isSameRoute(newRoute, existingRoute)\n    )\n  );\n  let newRoutes = convertRoutesToDataRoutes(\n    uniqueChildren,\n    mapRouteProperties2,\n    [routeId || \"_\", \"patch\", String(childrenToPatch?.length || \"0\")],\n    manifest\n  );\n  childrenToPatch.push(...newRoutes);\n}\nfunction isSameRoute(newRoute, existingRoute) {\n  if (\"id\" in newRoute && \"id\" in existingRoute && newRoute.id === existingRoute.id) {\n    return true;\n  }\n  if (!(newRoute.index === existingRoute.index && newRoute.path === existingRoute.path && newRoute.caseSensitive === existingRoute.caseSensitive)) {\n    return false;\n  }\n  if ((!newRoute.children || newRoute.children.length === 0) && (!existingRoute.children || existingRoute.children.length === 0)) {\n    return true;\n  }\n  return newRoute.children.every(\n    (aChild, i) => existingRoute.children?.some((bChild) => isSameRoute(aChild, bChild))\n  );\n}\nasync function loadLazyRouteModule(route, mapRouteProperties2, manifest) {\n  if (!route.lazy) {\n    return;\n  }\n  let lazyRoute = await route.lazy();\n  if (!route.lazy) {\n    return;\n  }\n  let routeToUpdate = manifest[route.id];\n  invariant(routeToUpdate, \"No route found in manifest\");\n  let routeUpdates = {};\n  for (let lazyRouteProperty in lazyRoute) {\n    let staticRouteValue = routeToUpdate[lazyRouteProperty];\n    let isPropertyStaticallyDefined = staticRouteValue !== void 0 && // This property isn't static since it should always be updated based\n    // on the route updates\n    lazyRouteProperty !== \"hasErrorBoundary\";\n    warning(\n      !isPropertyStaticallyDefined,\n      `Route \"${routeToUpdate.id}\" has a static property \"${lazyRouteProperty}\" defined but its lazy function is also returning a value for this property. The lazy route property \"${lazyRouteProperty}\" will be ignored.`\n    );\n    if (!isPropertyStaticallyDefined && !immutableRouteKeys.has(lazyRouteProperty)) {\n      routeUpdates[lazyRouteProperty] = lazyRoute[lazyRouteProperty];\n    }\n  }\n  Object.assign(routeToUpdate, routeUpdates);\n  Object.assign(routeToUpdate, {\n    // To keep things framework agnostic, we use the provided `mapRouteProperties`\n    // function to set the framework-aware properties (`element`/`hasErrorBoundary`)\n    // since the logic will differ between frameworks.\n    ...mapRouteProperties2(routeToUpdate),\n    lazy: void 0\n  });\n}\nasync function defaultDataStrategy({\n  matches\n}) {\n  let matchesToLoad = matches.filter((m) => m.shouldLoad);\n  let results = await Promise.all(matchesToLoad.map((m) => m.resolve()));\n  return results.reduce(\n    (acc, result, i) => Object.assign(acc, { [matchesToLoad[i].route.id]: result }),\n    {}\n  );\n}\nasync function callDataStrategyImpl(dataStrategyImpl, type, state, request, matchesToLoad, matches, fetcherKey, manifest, mapRouteProperties2, requestContext) {\n  let loadRouteDefinitionsPromises = matches.map(\n    (m) => m.route.lazy ? loadLazyRouteModule(m.route, mapRouteProperties2, manifest) : void 0\n  );\n  let dsMatches = matches.map((match, i) => {\n    let loadRoutePromise = loadRouteDefinitionsPromises[i];\n    let shouldLoad = matchesToLoad.some((m) => m.route.id === match.route.id);\n    let resolve = async (handlerOverride) => {\n      if (handlerOverride && request.method === \"GET\" && (match.route.lazy || match.route.loader)) {\n        shouldLoad = true;\n      }\n      return shouldLoad ? callLoaderOrAction(\n        type,\n        request,\n        match,\n        loadRoutePromise,\n        handlerOverride,\n        requestContext\n      ) : Promise.resolve({ type: \"data\" /* data */, result: void 0 });\n    };\n    return {\n      ...match,\n      shouldLoad,\n      resolve\n    };\n  });\n  let results = await dataStrategyImpl({\n    matches: dsMatches,\n    request,\n    params: matches[0].params,\n    fetcherKey,\n    context: requestContext\n  });\n  try {\n    await Promise.all(loadRouteDefinitionsPromises);\n  } catch (e) {\n  }\n  return results;\n}\nasync function callLoaderOrAction(type, request, match, loadRoutePromise, handlerOverride, staticContext) {\n  let result;\n  let onReject;\n  let runHandler = (handler) => {\n    let reject;\n    let abortPromise = new Promise((_, r) => reject = r);\n    onReject = () => reject();\n    request.signal.addEventListener(\"abort\", onReject);\n    let actualHandler = (ctx) => {\n      if (typeof handler !== \"function\") {\n        return Promise.reject(\n          new Error(\n            `You cannot call the handler for a route which defines a boolean \"${type}\" [routeId: ${match.route.id}]`\n          )\n        );\n      }\n      return handler(\n        {\n          request,\n          params: match.params,\n          context: staticContext\n        },\n        ...ctx !== void 0 ? [ctx] : []\n      );\n    };\n    let handlerPromise = (async () => {\n      try {\n        let val = await (handlerOverride ? handlerOverride((ctx) => actualHandler(ctx)) : actualHandler());\n        return { type: \"data\", result: val };\n      } catch (e) {\n        return { type: \"error\", result: e };\n      }\n    })();\n    return Promise.race([handlerPromise, abortPromise]);\n  };\n  try {\n    let handler = match.route[type];\n    if (loadRoutePromise) {\n      if (handler) {\n        let handlerError;\n        let [value] = await Promise.all([\n          // If the handler throws, don't let it immediately bubble out,\n          // since we need to let the lazy() execution finish so we know if this\n          // route has a boundary that can handle the error\n          runHandler(handler).catch((e) => {\n            handlerError = e;\n          }),\n          loadRoutePromise\n        ]);\n        if (handlerError !== void 0) {\n          throw handlerError;\n        }\n        result = value;\n      } else {\n        await loadRoutePromise;\n        handler = match.route[type];\n        if (handler) {\n          result = await runHandler(handler);\n        } else if (type === \"action\") {\n          let url = new URL(request.url);\n          let pathname = url.pathname + url.search;\n          throw getInternalRouterError(405, {\n            method: request.method,\n            pathname,\n            routeId: match.route.id\n          });\n        } else {\n          return { type: \"data\" /* data */, result: void 0 };\n        }\n      }\n    } else if (!handler) {\n      let url = new URL(request.url);\n      let pathname = url.pathname + url.search;\n      throw getInternalRouterError(404, {\n        pathname\n      });\n    } else {\n      result = await runHandler(handler);\n    }\n  } catch (e) {\n    return { type: \"error\" /* error */, result: e };\n  } finally {\n    if (onReject) {\n      request.signal.removeEventListener(\"abort\", onReject);\n    }\n  }\n  return result;\n}\nasync function convertDataStrategyResultToDataResult(dataStrategyResult) {\n  let { result, type } = dataStrategyResult;\n  if (isResponse(result)) {\n    let data2;\n    try {\n      let contentType = result.headers.get(\"Content-Type\");\n      if (contentType && /\\bapplication\\/json\\b/.test(contentType)) {\n        if (result.body == null) {\n          data2 = null;\n        } else {\n          data2 = await result.json();\n        }\n      } else {\n        data2 = await result.text();\n      }\n    } catch (e) {\n      return { type: \"error\" /* error */, error: e };\n    }\n    if (type === \"error\" /* error */) {\n      return {\n        type: \"error\" /* error */,\n        error: new ErrorResponseImpl(result.status, result.statusText, data2),\n        statusCode: result.status,\n        headers: result.headers\n      };\n    }\n    return {\n      type: \"data\" /* data */,\n      data: data2,\n      statusCode: result.status,\n      headers: result.headers\n    };\n  }\n  if (type === \"error\" /* error */) {\n    if (isDataWithResponseInit(result)) {\n      if (result.data instanceof Error) {\n        return {\n          type: \"error\" /* error */,\n          error: result.data,\n          statusCode: result.init?.status\n        };\n      }\n      result = new ErrorResponseImpl(\n        result.init?.status || 500,\n        void 0,\n        result.data\n      );\n    }\n    return {\n      type: \"error\" /* error */,\n      error: result,\n      statusCode: isRouteErrorResponse(result) ? result.status : void 0\n    };\n  }\n  if (isDataWithResponseInit(result)) {\n    return {\n      type: \"data\" /* data */,\n      data: result.data,\n      statusCode: result.init?.status,\n      headers: result.init?.headers ? new Headers(result.init.headers) : void 0\n    };\n  }\n  return { type: \"data\" /* data */, data: result };\n}\nfunction normalizeRelativeRoutingRedirectResponse(response, request, routeId, matches, basename) {\n  let location = response.headers.get(\"Location\");\n  invariant(\n    location,\n    \"Redirects returned/thrown from loaders/actions must have a Location header\"\n  );\n  if (!ABSOLUTE_URL_REGEX.test(location)) {\n    let trimmedMatches = matches.slice(\n      0,\n      matches.findIndex((m) => m.route.id === routeId) + 1\n    );\n    location = normalizeTo(\n      new URL(request.url),\n      trimmedMatches,\n      basename,\n      location\n    );\n    response.headers.set(\"Location\", location);\n  }\n  return response;\n}\nfunction normalizeRedirectLocation(location, currentUrl, basename) {\n  if (ABSOLUTE_URL_REGEX.test(location)) {\n    let normalizedLocation = location;\n    let url = normalizedLocation.startsWith(\"//\") ? new URL(currentUrl.protocol + normalizedLocation) : new URL(normalizedLocation);\n    let isSameBasename = stripBasename(url.pathname, basename) != null;\n    if (url.origin === currentUrl.origin && isSameBasename) {\n      return url.pathname + url.search + url.hash;\n    }\n  }\n  return location;\n}\nfunction createClientSideRequest(history, location, signal, submission) {\n  let url = history.createURL(stripHashFromPath(location)).toString();\n  let init = { signal };\n  if (submission && isMutationMethod(submission.formMethod)) {\n    let { formMethod, formEncType } = submission;\n    init.method = formMethod.toUpperCase();\n    if (formEncType === \"application/json\") {\n      init.headers = new Headers({ \"Content-Type\": formEncType });\n      init.body = JSON.stringify(submission.json);\n    } else if (formEncType === \"text/plain\") {\n      init.body = submission.text;\n    } else if (formEncType === \"application/x-www-form-urlencoded\" && submission.formData) {\n      init.body = convertFormDataToSearchParams(submission.formData);\n    } else {\n      init.body = submission.formData;\n    }\n  }\n  return new Request(url, init);\n}\nfunction convertFormDataToSearchParams(formData) {\n  let searchParams = new URLSearchParams();\n  for (let [key, value] of formData.entries()) {\n    searchParams.append(key, typeof value === \"string\" ? value : value.name);\n  }\n  return searchParams;\n}\nfunction convertSearchParamsToFormData(searchParams) {\n  let formData = new FormData();\n  for (let [key, value] of searchParams.entries()) {\n    formData.append(key, value);\n  }\n  return formData;\n}\nfunction processRouteLoaderData(matches, results, pendingActionResult, isStaticHandler = false, skipLoaderErrorBubbling = false) {\n  let loaderData = {};\n  let errors = null;\n  let statusCode;\n  let foundError = false;\n  let loaderHeaders = {};\n  let pendingError = pendingActionResult && isErrorResult(pendingActionResult[1]) ? pendingActionResult[1].error : void 0;\n  matches.forEach((match) => {\n    if (!(match.route.id in results)) {\n      return;\n    }\n    let id = match.route.id;\n    let result = results[id];\n    invariant(\n      !isRedirectResult(result),\n      \"Cannot handle redirect results in processLoaderData\"\n    );\n    if (isErrorResult(result)) {\n      let error = result.error;\n      if (pendingError !== void 0) {\n        error = pendingError;\n        pendingError = void 0;\n      }\n      errors = errors || {};\n      if (skipLoaderErrorBubbling) {\n        errors[id] = error;\n      } else {\n        let boundaryMatch = findNearestBoundary(matches, id);\n        if (errors[boundaryMatch.route.id] == null) {\n          errors[boundaryMatch.route.id] = error;\n        }\n      }\n      if (!isStaticHandler) {\n        loaderData[id] = ResetLoaderDataSymbol;\n      }\n      if (!foundError) {\n        foundError = true;\n        statusCode = isRouteErrorResponse(result.error) ? result.error.status : 500;\n      }\n      if (result.headers) {\n        loaderHeaders[id] = result.headers;\n      }\n    } else {\n      loaderData[id] = result.data;\n      if (result.statusCode && result.statusCode !== 200 && !foundError) {\n        statusCode = result.statusCode;\n      }\n      if (result.headers) {\n        loaderHeaders[id] = result.headers;\n      }\n    }\n  });\n  if (pendingError !== void 0 && pendingActionResult) {\n    errors = { [pendingActionResult[0]]: pendingError };\n    loaderData[pendingActionResult[0]] = void 0;\n  }\n  return {\n    loaderData,\n    errors,\n    statusCode: statusCode || 200,\n    loaderHeaders\n  };\n}\nfunction processLoaderData(state, matches, results, pendingActionResult, revalidatingFetchers, fetcherResults) {\n  let { loaderData, errors } = processRouteLoaderData(\n    matches,\n    results,\n    pendingActionResult\n  );\n  revalidatingFetchers.forEach((rf) => {\n    let { key, match, controller } = rf;\n    let result = fetcherResults[key];\n    invariant(result, \"Did not find corresponding fetcher result\");\n    if (controller && controller.signal.aborted) {\n      return;\n    } else if (isErrorResult(result)) {\n      let boundaryMatch = findNearestBoundary(state.matches, match?.route.id);\n      if (!(errors && errors[boundaryMatch.route.id])) {\n        errors = {\n          ...errors,\n          [boundaryMatch.route.id]: result.error\n        };\n      }\n      state.fetchers.delete(key);\n    } else if (isRedirectResult(result)) {\n      invariant(false, \"Unhandled fetcher revalidation redirect\");\n    } else {\n      let doneFetcher = getDoneFetcher(result.data);\n      state.fetchers.set(key, doneFetcher);\n    }\n  });\n  return { loaderData, errors };\n}\nfunction mergeLoaderData(loaderData, newLoaderData, matches, errors) {\n  let mergedLoaderData = Object.entries(newLoaderData).filter(([, v]) => v !== ResetLoaderDataSymbol).reduce((merged, [k, v]) => {\n    merged[k] = v;\n    return merged;\n  }, {});\n  for (let match of matches) {\n    let id = match.route.id;\n    if (!newLoaderData.hasOwnProperty(id) && loaderData.hasOwnProperty(id) && match.route.loader) {\n      mergedLoaderData[id] = loaderData[id];\n    }\n    if (errors && errors.hasOwnProperty(id)) {\n      break;\n    }\n  }\n  return mergedLoaderData;\n}\nfunction getActionDataForCommit(pendingActionResult) {\n  if (!pendingActionResult) {\n    return {};\n  }\n  return isErrorResult(pendingActionResult[1]) ? {\n    // Clear out prior actionData on errors\n    actionData: {}\n  } : {\n    actionData: {\n      [pendingActionResult[0]]: pendingActionResult[1].data\n    }\n  };\n}\nfunction findNearestBoundary(matches, routeId) {\n  let eligibleMatches = routeId ? matches.slice(0, matches.findIndex((m) => m.route.id === routeId) + 1) : [...matches];\n  return eligibleMatches.reverse().find((m) => m.route.hasErrorBoundary === true) || matches[0];\n}\nfunction getShortCircuitMatches(routes) {\n  let route = routes.length === 1 ? routes[0] : routes.find((r) => r.index || !r.path || r.path === \"/\") || {\n    id: `__shim-error-route__`\n  };\n  return {\n    matches: [\n      {\n        params: {},\n        pathname: \"\",\n        pathnameBase: \"\",\n        route\n      }\n    ],\n    route\n  };\n}\nfunction getInternalRouterError(status, {\n  pathname,\n  routeId,\n  method,\n  type,\n  message\n} = {}) {\n  let statusText = \"Unknown Server Error\";\n  let errorMessage = \"Unknown @remix-run/router error\";\n  if (status === 400) {\n    statusText = \"Bad Request\";\n    if (method && pathname && routeId) {\n      errorMessage = `You made a ${method} request to \"${pathname}\" but did not provide a \\`loader\\` for route \"${routeId}\", so there is no way to handle the request.`;\n    } else if (type === \"invalid-body\") {\n      errorMessage = \"Unable to encode submission body\";\n    }\n  } else if (status === 403) {\n    statusText = \"Forbidden\";\n    errorMessage = `Route \"${routeId}\" does not match URL \"${pathname}\"`;\n  } else if (status === 404) {\n    statusText = \"Not Found\";\n    errorMessage = `No route matches URL \"${pathname}\"`;\n  } else if (status === 405) {\n    statusText = \"Method Not Allowed\";\n    if (method && pathname && routeId) {\n      errorMessage = `You made a ${method.toUpperCase()} request to \"${pathname}\" but did not provide an \\`action\\` for route \"${routeId}\", so there is no way to handle the request.`;\n    } else if (method) {\n      errorMessage = `Invalid request method \"${method.toUpperCase()}\"`;\n    }\n  }\n  return new ErrorResponseImpl(\n    status || 500,\n    statusText,\n    new Error(errorMessage),\n    true\n  );\n}\nfunction findRedirect(results) {\n  let entries = Object.entries(results);\n  for (let i = entries.length - 1; i >= 0; i--) {\n    let [key, result] = entries[i];\n    if (isRedirectResult(result)) {\n      return { key, result };\n    }\n  }\n}\nfunction stripHashFromPath(path) {\n  let parsedPath = typeof path === \"string\" ? parsePath(path) : path;\n  return createPath({ ...parsedPath, hash: \"\" });\n}\nfunction isHashChangeOnly(a, b) {\n  if (a.pathname !== b.pathname || a.search !== b.search) {\n    return false;\n  }\n  if (a.hash === \"\") {\n    return b.hash !== \"\";\n  } else if (a.hash === b.hash) {\n    return true;\n  } else if (b.hash !== \"\") {\n    return true;\n  }\n  return false;\n}\nfunction isDataStrategyResult(result) {\n  return result != null && typeof result === \"object\" && \"type\" in result && \"result\" in result && (result.type === \"data\" /* data */ || result.type === \"error\" /* error */);\n}\nfunction isRedirectDataStrategyResult(result) {\n  return isResponse(result.result) && redirectStatusCodes.has(result.result.status);\n}\nfunction isErrorResult(result) {\n  return result.type === \"error\" /* error */;\n}\nfunction isRedirectResult(result) {\n  return (result && result.type) === \"redirect\" /* redirect */;\n}\nfunction isDataWithResponseInit(value) {\n  return typeof value === \"object\" && value != null && \"type\" in value && \"data\" in value && \"init\" in value && value.type === \"DataWithResponseInit\";\n}\nfunction isResponse(value) {\n  return value != null && typeof value.status === \"number\" && typeof value.statusText === \"string\" && typeof value.headers === \"object\" && typeof value.body !== \"undefined\";\n}\nfunction isRedirectStatusCode(statusCode) {\n  return redirectStatusCodes.has(statusCode);\n}\nfunction isRedirectResponse(result) {\n  return isResponse(result) && isRedirectStatusCode(result.status) && result.headers.has(\"Location\");\n}\nfunction isValidMethod(method) {\n  return validRequestMethods.has(method.toUpperCase());\n}\nfunction isMutationMethod(method) {\n  return validMutationMethods.has(method.toUpperCase());\n}\nfunction hasNakedIndexQuery(search) {\n  return new URLSearchParams(search).getAll(\"index\").some((v) => v === \"\");\n}\nfunction getTargetMatch(matches, location) {\n  let search = typeof location === \"string\" ? parsePath(location).search : location.search;\n  if (matches[matches.length - 1].route.index && hasNakedIndexQuery(search || \"\")) {\n    return matches[matches.length - 1];\n  }\n  let pathMatches = getPathContributingMatches(matches);\n  return pathMatches[pathMatches.length - 1];\n}\nfunction getSubmissionFromNavigation(navigation) {\n  let { formMethod, formAction, formEncType, text, formData, json } = navigation;\n  if (!formMethod || !formAction || !formEncType) {\n    return;\n  }\n  if (text != null) {\n    return {\n      formMethod,\n      formAction,\n      formEncType,\n      formData: void 0,\n      json: void 0,\n      text\n    };\n  } else if (formData != null) {\n    return {\n      formMethod,\n      formAction,\n      formEncType,\n      formData,\n      json: void 0,\n      text: void 0\n    };\n  } else if (json !== void 0) {\n    return {\n      formMethod,\n      formAction,\n      formEncType,\n      formData: void 0,\n      json,\n      text: void 0\n    };\n  }\n}\nfunction getLoadingNavigation(location, submission) {\n  if (submission) {\n    let navigation = {\n      state: \"loading\",\n      location,\n      formMethod: submission.formMethod,\n      formAction: submission.formAction,\n      formEncType: submission.formEncType,\n      formData: submission.formData,\n      json: submission.json,\n      text: submission.text\n    };\n    return navigation;\n  } else {\n    let navigation = {\n      state: \"loading\",\n      location,\n      formMethod: void 0,\n      formAction: void 0,\n      formEncType: void 0,\n      formData: void 0,\n      json: void 0,\n      text: void 0\n    };\n    return navigation;\n  }\n}\nfunction getSubmittingNavigation(location, submission) {\n  let navigation = {\n    state: \"submitting\",\n    location,\n    formMethod: submission.formMethod,\n    formAction: submission.formAction,\n    formEncType: submission.formEncType,\n    formData: submission.formData,\n    json: submission.json,\n    text: submission.text\n  };\n  return navigation;\n}\nfunction getLoadingFetcher(submission, data2) {\n  if (submission) {\n    let fetcher = {\n      state: \"loading\",\n      formMethod: submission.formMethod,\n      formAction: submission.formAction,\n      formEncType: submission.formEncType,\n      formData: submission.formData,\n      json: submission.json,\n      text: submission.text,\n      data: data2\n    };\n    return fetcher;\n  } else {\n    let fetcher = {\n      state: \"loading\",\n      formMethod: void 0,\n      formAction: void 0,\n      formEncType: void 0,\n      formData: void 0,\n      json: void 0,\n      text: void 0,\n      data: data2\n    };\n    return fetcher;\n  }\n}\nfunction getSubmittingFetcher(submission, existingFetcher) {\n  let fetcher = {\n    state: \"submitting\",\n    formMethod: submission.formMethod,\n    formAction: submission.formAction,\n    formEncType: submission.formEncType,\n    formData: submission.formData,\n    json: submission.json,\n    text: submission.text,\n    data: existingFetcher ? existingFetcher.data : void 0\n  };\n  return fetcher;\n}\nfunction getDoneFetcher(data2) {\n  let fetcher = {\n    state: \"idle\",\n    formMethod: void 0,\n    formAction: void 0,\n    formEncType: void 0,\n    formData: void 0,\n    json: void 0,\n    text: void 0,\n    data: data2\n  };\n  return fetcher;\n}\nfunction restoreAppliedTransitions(_window, transitions) {\n  try {\n    let sessionPositions = _window.sessionStorage.getItem(\n      TRANSITIONS_STORAGE_KEY\n    );\n    if (sessionPositions) {\n      let json = JSON.parse(sessionPositions);\n      for (let [k, v] of Object.entries(json || {})) {\n        if (v && Array.isArray(v)) {\n          transitions.set(k, new Set(v || []));\n        }\n      }\n    }\n  } catch (e) {\n  }\n}\nfunction persistAppliedTransitions(_window, transitions) {\n  if (transitions.size > 0) {\n    let json = {};\n    for (let [k, v] of transitions) {\n      json[k] = [...v];\n    }\n    try {\n      _window.sessionStorage.setItem(\n        TRANSITIONS_STORAGE_KEY,\n        JSON.stringify(json)\n      );\n    } catch (error) {\n      warning(\n        false,\n        `Failed to save applied view transitions in sessionStorage (${error}).`\n      );\n    }\n  }\n}\nfunction createDeferred() {\n  let resolve;\n  let reject;\n  let promise = new Promise((res, rej) => {\n    resolve = async (val) => {\n      res(val);\n      try {\n        await promise;\n      } catch (e) {\n      }\n    };\n    reject = async (error) => {\n      rej(error);\n      try {\n        await promise;\n      } catch (e) {\n      }\n    };\n  });\n  return {\n    promise,\n    //@ts-ignore\n    resolve,\n    //@ts-ignore\n    reject\n  };\n}\n\n// lib/components.tsx\nvar React3 = __toESM(__webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react.js\"));\n\n// lib/context.ts\nvar React = __toESM(__webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react.js\"));\nvar DataRouterContext = React.createContext(null);\nDataRouterContext.displayName = \"DataRouter\";\nvar DataRouterStateContext = React.createContext(null);\nDataRouterStateContext.displayName = \"DataRouterState\";\nvar ViewTransitionContext = React.createContext({\n  isTransitioning: false\n});\nViewTransitionContext.displayName = \"ViewTransition\";\nvar FetchersContext = React.createContext(\n  /* @__PURE__ */ new Map()\n);\nFetchersContext.displayName = \"Fetchers\";\nvar AwaitContext = React.createContext(null);\nAwaitContext.displayName = \"Await\";\nvar NavigationContext = React.createContext(\n  null\n);\nNavigationContext.displayName = \"Navigation\";\nvar LocationContext = React.createContext(\n  null\n);\nLocationContext.displayName = \"Location\";\nvar RouteContext = React.createContext({\n  outlet: null,\n  matches: [],\n  isDataRoute: false\n});\nRouteContext.displayName = \"Route\";\nvar RouteErrorContext = React.createContext(null);\nRouteErrorContext.displayName = \"RouteError\";\n\n// lib/hooks.tsx\nvar React2 = __toESM(__webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react.js\"));\nvar ENABLE_DEV_WARNINGS = true;\nfunction useHref(to, { relative } = {}) {\n  invariant(\n    useInRouterContext(),\n    // TODO: This error is probably because they somehow have 2 versions of the\n    // router loaded. We can help them understand how to avoid that.\n    `useHref() may be used only in the context of a <Router> component.`\n  );\n  let { basename, navigator: navigator2 } = React2.useContext(NavigationContext);\n  let { hash, pathname, search } = useResolvedPath(to, { relative });\n  let joinedPathname = pathname;\n  if (basename !== \"/\") {\n    joinedPathname = pathname === \"/\" ? basename : joinPaths([basename, pathname]);\n  }\n  return navigator2.createHref({ pathname: joinedPathname, search, hash });\n}\nfunction useInRouterContext() {\n  return React2.useContext(LocationContext) != null;\n}\nfunction useLocation() {\n  invariant(\n    useInRouterContext(),\n    // TODO: This error is probably because they somehow have 2 versions of the\n    // router loaded. We can help them understand how to avoid that.\n    `useLocation() may be used only in the context of a <Router> component.`\n  );\n  return React2.useContext(LocationContext).location;\n}\nfunction useNavigationType() {\n  return React2.useContext(LocationContext).navigationType;\n}\nfunction useMatch(pattern) {\n  invariant(\n    useInRouterContext(),\n    // TODO: This error is probably because they somehow have 2 versions of the\n    // router loaded. We can help them understand how to avoid that.\n    `useMatch() may be used only in the context of a <Router> component.`\n  );\n  let { pathname } = useLocation();\n  return React2.useMemo(\n    () => matchPath(pattern, decodePath(pathname)),\n    [pathname, pattern]\n  );\n}\nvar navigateEffectWarning = `You should call navigate() in a React.useEffect(), not when your component is first rendered.`;\nfunction useIsomorphicLayoutEffect(cb) {\n  let isStatic = React2.useContext(NavigationContext).static;\n  if (!isStatic) {\n    React2.useLayoutEffect(cb);\n  }\n}\nfunction useNavigate() {\n  let { isDataRoute } = React2.useContext(RouteContext);\n  return isDataRoute ? useNavigateStable() : useNavigateUnstable();\n}\nfunction useNavigateUnstable() {\n  invariant(\n    useInRouterContext(),\n    // TODO: This error is probably because they somehow have 2 versions of the\n    // router loaded. We can help them understand how to avoid that.\n    `useNavigate() may be used only in the context of a <Router> component.`\n  );\n  let dataRouterContext = React2.useContext(DataRouterContext);\n  let { basename, navigator: navigator2 } = React2.useContext(NavigationContext);\n  let { matches } = React2.useContext(RouteContext);\n  let { pathname: locationPathname } = useLocation();\n  let routePathnamesJson = JSON.stringify(getResolveToMatches(matches));\n  let activeRef = React2.useRef(false);\n  useIsomorphicLayoutEffect(() => {\n    activeRef.current = true;\n  });\n  let navigate = React2.useCallback(\n    (to, options = {}) => {\n      warning(activeRef.current, navigateEffectWarning);\n      if (!activeRef.current) return;\n      if (typeof to === \"number\") {\n        navigator2.go(to);\n        return;\n      }\n      let path = resolveTo(\n        to,\n        JSON.parse(routePathnamesJson),\n        locationPathname,\n        options.relative === \"path\"\n      );\n      if (dataRouterContext == null && basename !== \"/\") {\n        path.pathname = path.pathname === \"/\" ? basename : joinPaths([basename, path.pathname]);\n      }\n      (!!options.replace ? navigator2.replace : navigator2.push)(\n        path,\n        options.state,\n        options\n      );\n    },\n    [\n      basename,\n      navigator2,\n      routePathnamesJson,\n      locationPathname,\n      dataRouterContext\n    ]\n  );\n  return navigate;\n}\nvar OutletContext = React2.createContext(null);\nfunction useOutletContext() {\n  return React2.useContext(OutletContext);\n}\nfunction useOutlet(context) {\n  let outlet = React2.useContext(RouteContext).outlet;\n  if (outlet) {\n    return /* @__PURE__ */ React2.createElement(OutletContext.Provider, { value: context }, outlet);\n  }\n  return outlet;\n}\nfunction useParams() {\n  let { matches } = React2.useContext(RouteContext);\n  let routeMatch = matches[matches.length - 1];\n  return routeMatch ? routeMatch.params : {};\n}\nfunction useResolvedPath(to, { relative } = {}) {\n  let { matches } = React2.useContext(RouteContext);\n  let { pathname: locationPathname } = useLocation();\n  let routePathnamesJson = JSON.stringify(getResolveToMatches(matches));\n  return React2.useMemo(\n    () => resolveTo(\n      to,\n      JSON.parse(routePathnamesJson),\n      locationPathname,\n      relative === \"path\"\n    ),\n    [to, routePathnamesJson, locationPathname, relative]\n  );\n}\nfunction useRoutes(routes, locationArg) {\n  return useRoutesImpl(routes, locationArg);\n}\nfunction useRoutesImpl(routes, locationArg, dataRouterState, future) {\n  invariant(\n    useInRouterContext(),\n    // TODO: This error is probably because they somehow have 2 versions of the\n    // router loaded. We can help them understand how to avoid that.\n    `useRoutes() may be used only in the context of a <Router> component.`\n  );\n  let { navigator: navigator2 } = React2.useContext(NavigationContext);\n  let { matches: parentMatches } = React2.useContext(RouteContext);\n  let routeMatch = parentMatches[parentMatches.length - 1];\n  let parentParams = routeMatch ? routeMatch.params : {};\n  let parentPathname = routeMatch ? routeMatch.pathname : \"/\";\n  let parentPathnameBase = routeMatch ? routeMatch.pathnameBase : \"/\";\n  let parentRoute = routeMatch && routeMatch.route;\n  if (ENABLE_DEV_WARNINGS) {\n    let parentPath = parentRoute && parentRoute.path || \"\";\n    warningOnce(\n      parentPathname,\n      !parentRoute || parentPath.endsWith(\"*\") || parentPath.endsWith(\"*?\"),\n      `You rendered descendant <Routes> (or called \\`useRoutes()\\`) at \"${parentPathname}\" (under <Route path=\"${parentPath}\">) but the parent route path has no trailing \"*\". This means if you navigate deeper, the parent won't match anymore and therefore the child routes will never render.\n\nPlease change the parent <Route path=\"${parentPath}\"> to <Route path=\"${parentPath === \"/\" ? \"*\" : `${parentPath}/*`}\">.`\n    );\n  }\n  let locationFromContext = useLocation();\n  let location;\n  if (locationArg) {\n    let parsedLocationArg = typeof locationArg === \"string\" ? parsePath(locationArg) : locationArg;\n    invariant(\n      parentPathnameBase === \"/\" || parsedLocationArg.pathname?.startsWith(parentPathnameBase),\n      `When overriding the location using \\`<Routes location>\\` or \\`useRoutes(routes, location)\\`, the location pathname must begin with the portion of the URL pathname that was matched by all parent routes. The current pathname base is \"${parentPathnameBase}\" but pathname \"${parsedLocationArg.pathname}\" was given in the \\`location\\` prop.`\n    );\n    location = parsedLocationArg;\n  } else {\n    location = locationFromContext;\n  }\n  let pathname = location.pathname || \"/\";\n  let remainingPathname = pathname;\n  if (parentPathnameBase !== \"/\") {\n    let parentSegments = parentPathnameBase.replace(/^\\//, \"\").split(\"/\");\n    let segments = pathname.replace(/^\\//, \"\").split(\"/\");\n    remainingPathname = \"/\" + segments.slice(parentSegments.length).join(\"/\");\n  }\n  let matches = matchRoutes(routes, { pathname: remainingPathname });\n  if (ENABLE_DEV_WARNINGS) {\n    warning(\n      parentRoute || matches != null,\n      `No routes matched location \"${location.pathname}${location.search}${location.hash}\" `\n    );\n    warning(\n      matches == null || matches[matches.length - 1].route.element !== void 0 || matches[matches.length - 1].route.Component !== void 0 || matches[matches.length - 1].route.lazy !== void 0,\n      `Matched leaf route at location \"${location.pathname}${location.search}${location.hash}\" does not have an element or Component. This means it will render an <Outlet /> with a null value by default resulting in an \"empty\" page.`\n    );\n  }\n  let renderedMatches = _renderMatches(\n    matches && matches.map(\n      (match) => Object.assign({}, match, {\n        params: Object.assign({}, parentParams, match.params),\n        pathname: joinPaths([\n          parentPathnameBase,\n          // Re-encode pathnames that were decoded inside matchRoutes\n          navigator2.encodeLocation ? navigator2.encodeLocation(match.pathname).pathname : match.pathname\n        ]),\n        pathnameBase: match.pathnameBase === \"/\" ? parentPathnameBase : joinPaths([\n          parentPathnameBase,\n          // Re-encode pathnames that were decoded inside matchRoutes\n          navigator2.encodeLocation ? navigator2.encodeLocation(match.pathnameBase).pathname : match.pathnameBase\n        ])\n      })\n    ),\n    parentMatches,\n    dataRouterState,\n    future\n  );\n  if (locationArg && renderedMatches) {\n    return /* @__PURE__ */ React2.createElement(\n      LocationContext.Provider,\n      {\n        value: {\n          location: {\n            pathname: \"/\",\n            search: \"\",\n            hash: \"\",\n            state: null,\n            key: \"default\",\n            ...location\n          },\n          navigationType: \"POP\" /* Pop */\n        }\n      },\n      renderedMatches\n    );\n  }\n  return renderedMatches;\n}\nfunction DefaultErrorComponent() {\n  let error = useRouteError();\n  let message = isRouteErrorResponse(error) ? `${error.status} ${error.statusText}` : error instanceof Error ? error.message : JSON.stringify(error);\n  let stack = error instanceof Error ? error.stack : null;\n  let lightgrey = \"rgba(200,200,200, 0.5)\";\n  let preStyles = { padding: \"0.5rem\", backgroundColor: lightgrey };\n  let codeStyles = { padding: \"2px 4px\", backgroundColor: lightgrey };\n  let devInfo = null;\n  if (ENABLE_DEV_WARNINGS) {\n    console.error(\n      \"Error handled by React Router default ErrorBoundary:\",\n      error\n    );\n    devInfo = /* @__PURE__ */ React2.createElement(React2.Fragment, null, /* @__PURE__ */ React2.createElement(\"p\", null, \"\\u{1F4BF} Hey developer \\u{1F44B}\"), /* @__PURE__ */ React2.createElement(\"p\", null, \"You can provide a way better UX than this when your app throws errors by providing your own \", /* @__PURE__ */ React2.createElement(\"code\", { style: codeStyles }, \"ErrorBoundary\"), \" or\", \" \", /* @__PURE__ */ React2.createElement(\"code\", { style: codeStyles }, \"errorElement\"), \" prop on your route.\"));\n  }\n  return /* @__PURE__ */ React2.createElement(React2.Fragment, null, /* @__PURE__ */ React2.createElement(\"h2\", null, \"Unexpected Application Error!\"), /* @__PURE__ */ React2.createElement(\"h3\", { style: { fontStyle: \"italic\" } }, message), stack ? /* @__PURE__ */ React2.createElement(\"pre\", { style: preStyles }, stack) : null, devInfo);\n}\nvar defaultErrorElement = /* @__PURE__ */ React2.createElement(DefaultErrorComponent, null);\nvar RenderErrorBoundary = class extends React2.Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      location: props.location,\n      revalidation: props.revalidation,\n      error: props.error\n    };\n  }\n  static getDerivedStateFromError(error) {\n    return { error };\n  }\n  static getDerivedStateFromProps(props, state) {\n    if (state.location !== props.location || state.revalidation !== \"idle\" && props.revalidation === \"idle\") {\n      return {\n        error: props.error,\n        location: props.location,\n        revalidation: props.revalidation\n      };\n    }\n    return {\n      error: props.error !== void 0 ? props.error : state.error,\n      location: state.location,\n      revalidation: props.revalidation || state.revalidation\n    };\n  }\n  componentDidCatch(error, errorInfo) {\n    console.error(\n      \"React Router caught the following error during render\",\n      error,\n      errorInfo\n    );\n  }\n  render() {\n    return this.state.error !== void 0 ? /* @__PURE__ */ React2.createElement(RouteContext.Provider, { value: this.props.routeContext }, /* @__PURE__ */ React2.createElement(\n      RouteErrorContext.Provider,\n      {\n        value: this.state.error,\n        children: this.props.component\n      }\n    )) : this.props.children;\n  }\n};\nfunction RenderedRoute({ routeContext, match, children }) {\n  let dataRouterContext = React2.useContext(DataRouterContext);\n  if (dataRouterContext && dataRouterContext.static && dataRouterContext.staticContext && (match.route.errorElement || match.route.ErrorBoundary)) {\n    dataRouterContext.staticContext._deepestRenderedBoundaryId = match.route.id;\n  }\n  return /* @__PURE__ */ React2.createElement(RouteContext.Provider, { value: routeContext }, children);\n}\nfunction _renderMatches(matches, parentMatches = [], dataRouterState = null, future = null) {\n  if (matches == null) {\n    if (!dataRouterState) {\n      return null;\n    }\n    if (dataRouterState.errors) {\n      matches = dataRouterState.matches;\n    } else if (parentMatches.length === 0 && !dataRouterState.initialized && dataRouterState.matches.length > 0) {\n      matches = dataRouterState.matches;\n    } else {\n      return null;\n    }\n  }\n  let renderedMatches = matches;\n  let errors = dataRouterState?.errors;\n  if (errors != null) {\n    let errorIndex = renderedMatches.findIndex(\n      (m) => m.route.id && errors?.[m.route.id] !== void 0\n    );\n    invariant(\n      errorIndex >= 0,\n      `Could not find a matching route for errors on route IDs: ${Object.keys(\n        errors\n      ).join(\",\")}`\n    );\n    renderedMatches = renderedMatches.slice(\n      0,\n      Math.min(renderedMatches.length, errorIndex + 1)\n    );\n  }\n  let renderFallback = false;\n  let fallbackIndex = -1;\n  if (dataRouterState) {\n    for (let i = 0; i < renderedMatches.length; i++) {\n      let match = renderedMatches[i];\n      if (match.route.HydrateFallback || match.route.hydrateFallbackElement) {\n        fallbackIndex = i;\n      }\n      if (match.route.id) {\n        let { loaderData, errors: errors2 } = dataRouterState;\n        let needsToRunLoader = match.route.loader && !loaderData.hasOwnProperty(match.route.id) && (!errors2 || errors2[match.route.id] === void 0);\n        if (match.route.lazy || needsToRunLoader) {\n          renderFallback = true;\n          if (fallbackIndex >= 0) {\n            renderedMatches = renderedMatches.slice(0, fallbackIndex + 1);\n          } else {\n            renderedMatches = [renderedMatches[0]];\n          }\n          break;\n        }\n      }\n    }\n  }\n  return renderedMatches.reduceRight((outlet, match, index) => {\n    let error;\n    let shouldRenderHydrateFallback = false;\n    let errorElement = null;\n    let hydrateFallbackElement = null;\n    if (dataRouterState) {\n      error = errors && match.route.id ? errors[match.route.id] : void 0;\n      errorElement = match.route.errorElement || defaultErrorElement;\n      if (renderFallback) {\n        if (fallbackIndex < 0 && index === 0) {\n          warningOnce(\n            \"route-fallback\",\n            false,\n            \"No `HydrateFallback` element provided to render during initial hydration\"\n          );\n          shouldRenderHydrateFallback = true;\n          hydrateFallbackElement = null;\n        } else if (fallbackIndex === index) {\n          shouldRenderHydrateFallback = true;\n          hydrateFallbackElement = match.route.hydrateFallbackElement || null;\n        }\n      }\n    }\n    let matches2 = parentMatches.concat(renderedMatches.slice(0, index + 1));\n    let getChildren = () => {\n      let children;\n      if (error) {\n        children = errorElement;\n      } else if (shouldRenderHydrateFallback) {\n        children = hydrateFallbackElement;\n      } else if (match.route.Component) {\n        children = /* @__PURE__ */ React2.createElement(match.route.Component, null);\n      } else if (match.route.element) {\n        children = match.route.element;\n      } else {\n        children = outlet;\n      }\n      return /* @__PURE__ */ React2.createElement(\n        RenderedRoute,\n        {\n          match,\n          routeContext: {\n            outlet,\n            matches: matches2,\n            isDataRoute: dataRouterState != null\n          },\n          children\n        }\n      );\n    };\n    return dataRouterState && (match.route.ErrorBoundary || match.route.errorElement || index === 0) ? /* @__PURE__ */ React2.createElement(\n      RenderErrorBoundary,\n      {\n        location: dataRouterState.location,\n        revalidation: dataRouterState.revalidation,\n        component: errorElement,\n        error,\n        children: getChildren(),\n        routeContext: { outlet: null, matches: matches2, isDataRoute: true }\n      }\n    ) : getChildren();\n  }, null);\n}\nfunction getDataRouterConsoleError(hookName) {\n  return `${hookName} must be used within a data router.  See https://reactrouter.com/en/main/routers/picking-a-router.`;\n}\nfunction useDataRouterContext(hookName) {\n  let ctx = React2.useContext(DataRouterContext);\n  invariant(ctx, getDataRouterConsoleError(hookName));\n  return ctx;\n}\nfunction useDataRouterState(hookName) {\n  let state = React2.useContext(DataRouterStateContext);\n  invariant(state, getDataRouterConsoleError(hookName));\n  return state;\n}\nfunction useRouteContext(hookName) {\n  let route = React2.useContext(RouteContext);\n  invariant(route, getDataRouterConsoleError(hookName));\n  return route;\n}\nfunction useCurrentRouteId(hookName) {\n  let route = useRouteContext(hookName);\n  let thisRoute = route.matches[route.matches.length - 1];\n  invariant(\n    thisRoute.route.id,\n    `${hookName} can only be used on routes that contain a unique \"id\"`\n  );\n  return thisRoute.route.id;\n}\nfunction useRouteId() {\n  return useCurrentRouteId(\"useRouteId\" /* UseRouteId */);\n}\nfunction useNavigation() {\n  let state = useDataRouterState(\"useNavigation\" /* UseNavigation */);\n  return state.navigation;\n}\nfunction useRevalidator() {\n  let dataRouterContext = useDataRouterContext(\"useRevalidator\" /* UseRevalidator */);\n  let state = useDataRouterState(\"useRevalidator\" /* UseRevalidator */);\n  return React2.useMemo(\n    () => ({\n      async revalidate() {\n        await dataRouterContext.router.revalidate();\n      },\n      state: state.revalidation\n    }),\n    [dataRouterContext.router, state.revalidation]\n  );\n}\nfunction useMatches() {\n  let { matches, loaderData } = useDataRouterState(\n    \"useMatches\" /* UseMatches */\n  );\n  return React2.useMemo(\n    () => matches.map((m) => convertRouteMatchToUiMatch(m, loaderData)),\n    [matches, loaderData]\n  );\n}\nfunction useLoaderData() {\n  let state = useDataRouterState(\"useLoaderData\" /* UseLoaderData */);\n  let routeId = useCurrentRouteId(\"useLoaderData\" /* UseLoaderData */);\n  return state.loaderData[routeId];\n}\nfunction useRouteLoaderData(routeId) {\n  let state = useDataRouterState(\"useRouteLoaderData\" /* UseRouteLoaderData */);\n  return state.loaderData[routeId];\n}\nfunction useActionData() {\n  let state = useDataRouterState(\"useActionData\" /* UseActionData */);\n  let routeId = useCurrentRouteId(\"useLoaderData\" /* UseLoaderData */);\n  return state.actionData ? state.actionData[routeId] : void 0;\n}\nfunction useRouteError() {\n  let error = React2.useContext(RouteErrorContext);\n  let state = useDataRouterState(\"useRouteError\" /* UseRouteError */);\n  let routeId = useCurrentRouteId(\"useRouteError\" /* UseRouteError */);\n  if (error !== void 0) {\n    return error;\n  }\n  return state.errors?.[routeId];\n}\nfunction useAsyncValue() {\n  let value = React2.useContext(AwaitContext);\n  return value?._data;\n}\nfunction useAsyncError() {\n  let value = React2.useContext(AwaitContext);\n  return value?._error;\n}\nvar blockerId = 0;\nfunction useBlocker(shouldBlock) {\n  let { router, basename } = useDataRouterContext(\"useBlocker\" /* UseBlocker */);\n  let state = useDataRouterState(\"useBlocker\" /* UseBlocker */);\n  let [blockerKey, setBlockerKey] = React2.useState(\"\");\n  let blockerFunction = React2.useCallback(\n    (arg) => {\n      if (typeof shouldBlock !== \"function\") {\n        return !!shouldBlock;\n      }\n      if (basename === \"/\") {\n        return shouldBlock(arg);\n      }\n      let { currentLocation, nextLocation, historyAction } = arg;\n      return shouldBlock({\n        currentLocation: {\n          ...currentLocation,\n          pathname: stripBasename(currentLocation.pathname, basename) || currentLocation.pathname\n        },\n        nextLocation: {\n          ...nextLocation,\n          pathname: stripBasename(nextLocation.pathname, basename) || nextLocation.pathname\n        },\n        historyAction\n      });\n    },\n    [basename, shouldBlock]\n  );\n  React2.useEffect(() => {\n    let key = String(++blockerId);\n    setBlockerKey(key);\n    return () => router.deleteBlocker(key);\n  }, [router]);\n  React2.useEffect(() => {\n    if (blockerKey !== \"\") {\n      router.getBlocker(blockerKey, blockerFunction);\n    }\n  }, [router, blockerKey, blockerFunction]);\n  return blockerKey && state.blockers.has(blockerKey) ? state.blockers.get(blockerKey) : IDLE_BLOCKER;\n}\nfunction useNavigateStable() {\n  let { router } = useDataRouterContext(\"useNavigate\" /* UseNavigateStable */);\n  let id = useCurrentRouteId(\"useNavigate\" /* UseNavigateStable */);\n  let activeRef = React2.useRef(false);\n  useIsomorphicLayoutEffect(() => {\n    activeRef.current = true;\n  });\n  let navigate = React2.useCallback(\n    async (to, options = {}) => {\n      warning(activeRef.current, navigateEffectWarning);\n      if (!activeRef.current) return;\n      if (typeof to === \"number\") {\n        router.navigate(to);\n      } else {\n        await router.navigate(to, { fromRouteId: id, ...options });\n      }\n    },\n    [router, id]\n  );\n  return navigate;\n}\nvar alreadyWarned = {};\nfunction warningOnce(key, cond, message) {\n  if (!cond && !alreadyWarned[key]) {\n    alreadyWarned[key] = true;\n    warning(false, message);\n  }\n}\n\n// lib/server-runtime/warnings.ts\nvar alreadyWarned2 = {};\nfunction warnOnce(condition, message) {\n  if (!condition && !alreadyWarned2[message]) {\n    alreadyWarned2[message] = true;\n    console.warn(message);\n  }\n}\n\n// lib/components.tsx\nvar ENABLE_DEV_WARNINGS2 = true;\nfunction mapRouteProperties(route) {\n  let updates = {\n    // Note: this check also occurs in createRoutesFromChildren so update\n    // there if you change this -- please and thank you!\n    hasErrorBoundary: route.hasErrorBoundary || route.ErrorBoundary != null || route.errorElement != null\n  };\n  if (route.Component) {\n    if (ENABLE_DEV_WARNINGS2) {\n      if (route.element) {\n        warning(\n          false,\n          \"You should not include both `Component` and `element` on your route - `Component` will be used.\"\n        );\n      }\n    }\n    Object.assign(updates, {\n      element: React3.createElement(route.Component),\n      Component: void 0\n    });\n  }\n  if (route.HydrateFallback) {\n    if (ENABLE_DEV_WARNINGS2) {\n      if (route.hydrateFallbackElement) {\n        warning(\n          false,\n          \"You should not include both `HydrateFallback` and `hydrateFallbackElement` on your route - `HydrateFallback` will be used.\"\n        );\n      }\n    }\n    Object.assign(updates, {\n      hydrateFallbackElement: React3.createElement(route.HydrateFallback),\n      HydrateFallback: void 0\n    });\n  }\n  if (route.ErrorBoundary) {\n    if (ENABLE_DEV_WARNINGS2) {\n      if (route.errorElement) {\n        warning(\n          false,\n          \"You should not include both `ErrorBoundary` and `errorElement` on your route - `ErrorBoundary` will be used.\"\n        );\n      }\n    }\n    Object.assign(updates, {\n      errorElement: React3.createElement(route.ErrorBoundary),\n      ErrorBoundary: void 0\n    });\n  }\n  return updates;\n}\nfunction createMemoryRouter(routes, opts) {\n  return createRouter({\n    basename: opts?.basename,\n    future: opts?.future,\n    history: createMemoryHistory({\n      initialEntries: opts?.initialEntries,\n      initialIndex: opts?.initialIndex\n    }),\n    hydrationData: opts?.hydrationData,\n    routes,\n    mapRouteProperties,\n    dataStrategy: opts?.dataStrategy,\n    patchRoutesOnNavigation: opts?.patchRoutesOnNavigation\n  }).initialize();\n}\nvar Deferred = class {\n  constructor() {\n    this.status = \"pending\";\n    this.promise = new Promise((resolve, reject) => {\n      this.resolve = (value) => {\n        if (this.status === \"pending\") {\n          this.status = \"resolved\";\n          resolve(value);\n        }\n      };\n      this.reject = (reason) => {\n        if (this.status === \"pending\") {\n          this.status = \"rejected\";\n          reject(reason);\n        }\n      };\n    });\n  }\n};\nfunction RouterProvider({\n  router,\n  flushSync: reactDomFlushSyncImpl\n}) {\n  let [state, setStateImpl] = React3.useState(router.state);\n  let [pendingState, setPendingState] = React3.useState();\n  let [vtContext, setVtContext] = React3.useState({\n    isTransitioning: false\n  });\n  let [renderDfd, setRenderDfd] = React3.useState();\n  let [transition, setTransition] = React3.useState();\n  let [interruption, setInterruption] = React3.useState();\n  let fetcherData = React3.useRef(/* @__PURE__ */ new Map());\n  let setState = React3.useCallback(\n    (newState, { deletedFetchers, flushSync, viewTransitionOpts }) => {\n      deletedFetchers.forEach((key) => fetcherData.current.delete(key));\n      newState.fetchers.forEach((fetcher, key) => {\n        if (fetcher.data !== void 0) {\n          fetcherData.current.set(key, fetcher.data);\n        }\n      });\n      warnOnce(\n        flushSync === false || reactDomFlushSyncImpl != null,\n        'You provided the `flushSync` option to a router update, but you are not using the `<RouterProvider>` from `react-router/dom` so `ReactDOM.flushSync()` is unavailable.  Please update your app to `import { RouterProvider } from \"react-router/dom\"` and ensure you have `react-dom` installed as a dependency to use the `flushSync` option.'\n      );\n      let isViewTransitionAvailable = router.window != null && router.window.document != null && typeof router.window.document.startViewTransition === \"function\";\n      warnOnce(\n        viewTransitionOpts == null || isViewTransitionAvailable,\n        \"You provided the `viewTransition` option to a router update, but you do not appear to be running in a DOM environment as `window.startViewTransition` is not available.\"\n      );\n      if (!viewTransitionOpts || !isViewTransitionAvailable) {\n        if (reactDomFlushSyncImpl && flushSync) {\n          reactDomFlushSyncImpl(() => setStateImpl(newState));\n        } else {\n          React3.startTransition(() => setStateImpl(newState));\n        }\n        return;\n      }\n      if (reactDomFlushSyncImpl && flushSync) {\n        reactDomFlushSyncImpl(() => {\n          if (transition) {\n            renderDfd && renderDfd.resolve();\n            transition.skipTransition();\n          }\n          setVtContext({\n            isTransitioning: true,\n            flushSync: true,\n            currentLocation: viewTransitionOpts.currentLocation,\n            nextLocation: viewTransitionOpts.nextLocation\n          });\n        });\n        let t = router.window.document.startViewTransition(() => {\n          reactDomFlushSyncImpl(() => setStateImpl(newState));\n        });\n        t.finished.finally(() => {\n          reactDomFlushSyncImpl(() => {\n            setRenderDfd(void 0);\n            setTransition(void 0);\n            setPendingState(void 0);\n            setVtContext({ isTransitioning: false });\n          });\n        });\n        reactDomFlushSyncImpl(() => setTransition(t));\n        return;\n      }\n      if (transition) {\n        renderDfd && renderDfd.resolve();\n        transition.skipTransition();\n        setInterruption({\n          state: newState,\n          currentLocation: viewTransitionOpts.currentLocation,\n          nextLocation: viewTransitionOpts.nextLocation\n        });\n      } else {\n        setPendingState(newState);\n        setVtContext({\n          isTransitioning: true,\n          flushSync: false,\n          currentLocation: viewTransitionOpts.currentLocation,\n          nextLocation: viewTransitionOpts.nextLocation\n        });\n      }\n    },\n    [router.window, reactDomFlushSyncImpl, transition, renderDfd]\n  );\n  React3.useLayoutEffect(() => router.subscribe(setState), [router, setState]);\n  React3.useEffect(() => {\n    if (vtContext.isTransitioning && !vtContext.flushSync) {\n      setRenderDfd(new Deferred());\n    }\n  }, [vtContext]);\n  React3.useEffect(() => {\n    if (renderDfd && pendingState && router.window) {\n      let newState = pendingState;\n      let renderPromise = renderDfd.promise;\n      let transition2 = router.window.document.startViewTransition(async () => {\n        React3.startTransition(() => setStateImpl(newState));\n        await renderPromise;\n      });\n      transition2.finished.finally(() => {\n        setRenderDfd(void 0);\n        setTransition(void 0);\n        setPendingState(void 0);\n        setVtContext({ isTransitioning: false });\n      });\n      setTransition(transition2);\n    }\n  }, [pendingState, renderDfd, router.window]);\n  React3.useEffect(() => {\n    if (renderDfd && pendingState && state.location.key === pendingState.location.key) {\n      renderDfd.resolve();\n    }\n  }, [renderDfd, transition, state.location, pendingState]);\n  React3.useEffect(() => {\n    if (!vtContext.isTransitioning && interruption) {\n      setPendingState(interruption.state);\n      setVtContext({\n        isTransitioning: true,\n        flushSync: false,\n        currentLocation: interruption.currentLocation,\n        nextLocation: interruption.nextLocation\n      });\n      setInterruption(void 0);\n    }\n  }, [vtContext.isTransitioning, interruption]);\n  let navigator2 = React3.useMemo(() => {\n    return {\n      createHref: router.createHref,\n      encodeLocation: router.encodeLocation,\n      go: (n) => router.navigate(n),\n      push: (to, state2, opts) => router.navigate(to, {\n        state: state2,\n        preventScrollReset: opts?.preventScrollReset\n      }),\n      replace: (to, state2, opts) => router.navigate(to, {\n        replace: true,\n        state: state2,\n        preventScrollReset: opts?.preventScrollReset\n      })\n    };\n  }, [router]);\n  let basename = router.basename || \"/\";\n  let dataRouterContext = React3.useMemo(\n    () => ({\n      router,\n      navigator: navigator2,\n      static: false,\n      basename\n    }),\n    [router, navigator2, basename]\n  );\n  return /* @__PURE__ */ React3.createElement(React3.Fragment, null, /* @__PURE__ */ React3.createElement(DataRouterContext.Provider, { value: dataRouterContext }, /* @__PURE__ */ React3.createElement(DataRouterStateContext.Provider, { value: state }, /* @__PURE__ */ React3.createElement(FetchersContext.Provider, { value: fetcherData.current }, /* @__PURE__ */ React3.createElement(ViewTransitionContext.Provider, { value: vtContext }, /* @__PURE__ */ React3.createElement(\n    Router,\n    {\n      basename,\n      location: state.location,\n      navigationType: state.historyAction,\n      navigator: navigator2\n    },\n    /* @__PURE__ */ React3.createElement(\n      MemoizedDataRoutes,\n      {\n        routes: router.routes,\n        future: router.future,\n        state\n      }\n    )\n  ))))), null);\n}\nvar MemoizedDataRoutes = React3.memo(DataRoutes);\nfunction DataRoutes({\n  routes,\n  future,\n  state\n}) {\n  return useRoutesImpl(routes, void 0, state, future);\n}\nfunction MemoryRouter({\n  basename,\n  children,\n  initialEntries,\n  initialIndex\n}) {\n  let historyRef = React3.useRef();\n  if (historyRef.current == null) {\n    historyRef.current = createMemoryHistory({\n      initialEntries,\n      initialIndex,\n      v5Compat: true\n    });\n  }\n  let history = historyRef.current;\n  let [state, setStateImpl] = React3.useState({\n    action: history.action,\n    location: history.location\n  });\n  let setState = React3.useCallback(\n    (newState) => {\n      React3.startTransition(() => setStateImpl(newState));\n    },\n    [setStateImpl]\n  );\n  React3.useLayoutEffect(() => history.listen(setState), [history, setState]);\n  return /* @__PURE__ */ React3.createElement(\n    Router,\n    {\n      basename,\n      children,\n      location: state.location,\n      navigationType: state.action,\n      navigator: history\n    }\n  );\n}\nfunction Navigate({\n  to,\n  replace: replace2,\n  state,\n  relative\n}) {\n  invariant(\n    useInRouterContext(),\n    // TODO: This error is probably because they somehow have 2 versions of\n    // the router loaded. We can help them understand how to avoid that.\n    `<Navigate> may be used only in the context of a <Router> component.`\n  );\n  let { static: isStatic } = React3.useContext(NavigationContext);\n  warning(\n    !isStatic,\n    `<Navigate> must not be used on the initial render in a <StaticRouter>. This is a no-op, but you should modify your code so the <Navigate> is only ever rendered in response to some user interaction or state change.`\n  );\n  let { matches } = React3.useContext(RouteContext);\n  let { pathname: locationPathname } = useLocation();\n  let navigate = useNavigate();\n  let path = resolveTo(\n    to,\n    getResolveToMatches(matches),\n    locationPathname,\n    relative === \"path\"\n  );\n  let jsonPath = JSON.stringify(path);\n  React3.useEffect(() => {\n    navigate(JSON.parse(jsonPath), { replace: replace2, state, relative });\n  }, [navigate, jsonPath, relative, replace2, state]);\n  return null;\n}\nfunction Outlet(props) {\n  return useOutlet(props.context);\n}\nfunction Route(_props) {\n  invariant(\n    false,\n    `A <Route> is only ever to be used as the child of <Routes> element, never rendered directly. Please wrap your <Route> in a <Routes>.`\n  );\n}\nfunction Router({\n  basename: basenameProp = \"/\",\n  children = null,\n  location: locationProp,\n  navigationType = \"POP\" /* Pop */,\n  navigator: navigator2,\n  static: staticProp = false\n}) {\n  invariant(\n    !useInRouterContext(),\n    `You cannot render a <Router> inside another <Router>. You should never have more than one in your app.`\n  );\n  let basename = basenameProp.replace(/^\\/*/, \"/\");\n  let navigationContext = React3.useMemo(\n    () => ({\n      basename,\n      navigator: navigator2,\n      static: staticProp,\n      future: {}\n    }),\n    [basename, navigator2, staticProp]\n  );\n  if (typeof locationProp === \"string\") {\n    locationProp = parsePath(locationProp);\n  }\n  let {\n    pathname = \"/\",\n    search = \"\",\n    hash = \"\",\n    state = null,\n    key = \"default\"\n  } = locationProp;\n  let locationContext = React3.useMemo(() => {\n    let trailingPathname = stripBasename(pathname, basename);\n    if (trailingPathname == null) {\n      return null;\n    }\n    return {\n      location: {\n        pathname: trailingPathname,\n        search,\n        hash,\n        state,\n        key\n      },\n      navigationType\n    };\n  }, [basename, pathname, search, hash, state, key, navigationType]);\n  warning(\n    locationContext != null,\n    `<Router basename=\"${basename}\"> is not able to match the URL \"${pathname}${search}${hash}\" because it does not start with the basename, so the <Router> won't render anything.`\n  );\n  if (locationContext == null) {\n    return null;\n  }\n  return /* @__PURE__ */ React3.createElement(NavigationContext.Provider, { value: navigationContext }, /* @__PURE__ */ React3.createElement(LocationContext.Provider, { children, value: locationContext }));\n}\nfunction Routes({\n  children,\n  location\n}) {\n  return useRoutes(createRoutesFromChildren(children), location);\n}\nfunction Await({\n  children,\n  errorElement,\n  resolve\n}) {\n  return /* @__PURE__ */ React3.createElement(AwaitErrorBoundary, { resolve, errorElement }, /* @__PURE__ */ React3.createElement(ResolveAwait, null, children));\n}\nvar AwaitErrorBoundary = class extends React3.Component {\n  constructor(props) {\n    super(props);\n    this.state = { error: null };\n  }\n  static getDerivedStateFromError(error) {\n    return { error };\n  }\n  componentDidCatch(error, errorInfo) {\n    console.error(\n      \"<Await> caught the following error during render\",\n      error,\n      errorInfo\n    );\n  }\n  render() {\n    let { children, errorElement, resolve } = this.props;\n    let promise = null;\n    let status = 0 /* pending */;\n    if (!(resolve instanceof Promise)) {\n      status = 1 /* success */;\n      promise = Promise.resolve();\n      Object.defineProperty(promise, \"_tracked\", { get: () => true });\n      Object.defineProperty(promise, \"_data\", { get: () => resolve });\n    } else if (this.state.error) {\n      status = 2 /* error */;\n      let renderError = this.state.error;\n      promise = Promise.reject().catch(() => {\n      });\n      Object.defineProperty(promise, \"_tracked\", { get: () => true });\n      Object.defineProperty(promise, \"_error\", { get: () => renderError });\n    } else if (resolve._tracked) {\n      promise = resolve;\n      status = \"_error\" in promise ? 2 /* error */ : \"_data\" in promise ? 1 /* success */ : 0 /* pending */;\n    } else {\n      status = 0 /* pending */;\n      Object.defineProperty(resolve, \"_tracked\", { get: () => true });\n      promise = resolve.then(\n        (data2) => Object.defineProperty(resolve, \"_data\", { get: () => data2 }),\n        (error) => Object.defineProperty(resolve, \"_error\", { get: () => error })\n      );\n    }\n    if (status === 2 /* error */ && !errorElement) {\n      throw promise._error;\n    }\n    if (status === 2 /* error */) {\n      return /* @__PURE__ */ React3.createElement(AwaitContext.Provider, { value: promise, children: errorElement });\n    }\n    if (status === 1 /* success */) {\n      return /* @__PURE__ */ React3.createElement(AwaitContext.Provider, { value: promise, children });\n    }\n    throw promise;\n  }\n};\nfunction ResolveAwait({\n  children\n}) {\n  let data2 = useAsyncValue();\n  let toRender = typeof children === \"function\" ? children(data2) : children;\n  return /* @__PURE__ */ React3.createElement(React3.Fragment, null, toRender);\n}\nfunction createRoutesFromChildren(children, parentPath = []) {\n  let routes = [];\n  React3.Children.forEach(children, (element, index) => {\n    if (!React3.isValidElement(element)) {\n      return;\n    }\n    let treePath = [...parentPath, index];\n    if (element.type === React3.Fragment) {\n      routes.push.apply(\n        routes,\n        createRoutesFromChildren(element.props.children, treePath)\n      );\n      return;\n    }\n    invariant(\n      element.type === Route,\n      `[${typeof element.type === \"string\" ? element.type : element.type.name}] is not a <Route> component. All component children of <Routes> must be a <Route> or <React.Fragment>`\n    );\n    invariant(\n      !element.props.index || !element.props.children,\n      \"An index route cannot have child routes.\"\n    );\n    let route = {\n      id: element.props.id || treePath.join(\"-\"),\n      caseSensitive: element.props.caseSensitive,\n      element: element.props.element,\n      Component: element.props.Component,\n      index: element.props.index,\n      path: element.props.path,\n      loader: element.props.loader,\n      action: element.props.action,\n      hydrateFallbackElement: element.props.hydrateFallbackElement,\n      HydrateFallback: element.props.HydrateFallback,\n      errorElement: element.props.errorElement,\n      ErrorBoundary: element.props.ErrorBoundary,\n      hasErrorBoundary: element.props.hasErrorBoundary === true || element.props.ErrorBoundary != null || element.props.errorElement != null,\n      shouldRevalidate: element.props.shouldRevalidate,\n      handle: element.props.handle,\n      lazy: element.props.lazy\n    };\n    if (element.props.children) {\n      route.children = createRoutesFromChildren(\n        element.props.children,\n        treePath\n      );\n    }\n    routes.push(route);\n  });\n  return routes;\n}\nvar createRoutesFromElements = createRoutesFromChildren;\nfunction renderMatches(matches) {\n  return _renderMatches(matches);\n}\n\n// lib/dom/lib.tsx\nvar React10 = __toESM(__webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react.js\"));\n\n// lib/dom/dom.ts\nvar defaultMethod = \"get\";\nvar defaultEncType = \"application/x-www-form-urlencoded\";\nfunction isHtmlElement(object) {\n  return object != null && typeof object.tagName === \"string\";\n}\nfunction isButtonElement(object) {\n  return isHtmlElement(object) && object.tagName.toLowerCase() === \"button\";\n}\nfunction isFormElement(object) {\n  return isHtmlElement(object) && object.tagName.toLowerCase() === \"form\";\n}\nfunction isInputElement(object) {\n  return isHtmlElement(object) && object.tagName.toLowerCase() === \"input\";\n}\nfunction isModifiedEvent(event) {\n  return !!(event.metaKey || event.altKey || event.ctrlKey || event.shiftKey);\n}\nfunction shouldProcessLinkClick(event, target) {\n  return event.button === 0 && // Ignore everything but left clicks\n  (!target || target === \"_self\") && // Let browser handle \"target=_blank\" etc.\n  !isModifiedEvent(event);\n}\nfunction createSearchParams(init = \"\") {\n  return new URLSearchParams(\n    typeof init === \"string\" || Array.isArray(init) || init instanceof URLSearchParams ? init : Object.keys(init).reduce((memo2, key) => {\n      let value = init[key];\n      return memo2.concat(\n        Array.isArray(value) ? value.map((v) => [key, v]) : [[key, value]]\n      );\n    }, [])\n  );\n}\nfunction getSearchParamsForLocation(locationSearch, defaultSearchParams) {\n  let searchParams = createSearchParams(locationSearch);\n  if (defaultSearchParams) {\n    defaultSearchParams.forEach((_, key) => {\n      if (!searchParams.has(key)) {\n        defaultSearchParams.getAll(key).forEach((value) => {\n          searchParams.append(key, value);\n        });\n      }\n    });\n  }\n  return searchParams;\n}\nvar _formDataSupportsSubmitter = null;\nfunction isFormDataSubmitterSupported() {\n  if (_formDataSupportsSubmitter === null) {\n    try {\n      new FormData(\n        document.createElement(\"form\"),\n        // @ts-expect-error if FormData supports the submitter parameter, this will throw\n        0\n      );\n      _formDataSupportsSubmitter = false;\n    } catch (e) {\n      _formDataSupportsSubmitter = true;\n    }\n  }\n  return _formDataSupportsSubmitter;\n}\nvar supportedFormEncTypes = /* @__PURE__ */ new Set([\n  \"application/x-www-form-urlencoded\",\n  \"multipart/form-data\",\n  \"text/plain\"\n]);\nfunction getFormEncType(encType) {\n  if (encType != null && !supportedFormEncTypes.has(encType)) {\n    warning(\n      false,\n      `\"${encType}\" is not a valid \\`encType\\` for \\`<Form>\\`/\\`<fetcher.Form>\\` and will default to \"${defaultEncType}\"`\n    );\n    return null;\n  }\n  return encType;\n}\nfunction getFormSubmissionInfo(target, basename) {\n  let method;\n  let action;\n  let encType;\n  let formData;\n  let body;\n  if (isFormElement(target)) {\n    let attr = target.getAttribute(\"action\");\n    action = attr ? stripBasename(attr, basename) : null;\n    method = target.getAttribute(\"method\") || defaultMethod;\n    encType = getFormEncType(target.getAttribute(\"enctype\")) || defaultEncType;\n    formData = new FormData(target);\n  } else if (isButtonElement(target) || isInputElement(target) && (target.type === \"submit\" || target.type === \"image\")) {\n    let form = target.form;\n    if (form == null) {\n      throw new Error(\n        `Cannot submit a <button> or <input type=\"submit\"> without a <form>`\n      );\n    }\n    let attr = target.getAttribute(\"formaction\") || form.getAttribute(\"action\");\n    action = attr ? stripBasename(attr, basename) : null;\n    method = target.getAttribute(\"formmethod\") || form.getAttribute(\"method\") || defaultMethod;\n    encType = getFormEncType(target.getAttribute(\"formenctype\")) || getFormEncType(form.getAttribute(\"enctype\")) || defaultEncType;\n    formData = new FormData(form, target);\n    if (!isFormDataSubmitterSupported()) {\n      let { name, type, value } = target;\n      if (type === \"image\") {\n        let prefix = name ? `${name}.` : \"\";\n        formData.append(`${prefix}x`, \"0\");\n        formData.append(`${prefix}y`, \"0\");\n      } else if (name) {\n        formData.append(name, value);\n      }\n    }\n  } else if (isHtmlElement(target)) {\n    throw new Error(\n      `Cannot submit element that is not <form>, <button>, or <input type=\"submit|image\">`\n    );\n  } else {\n    method = defaultMethod;\n    action = null;\n    encType = defaultEncType;\n    body = target;\n  }\n  if (formData && encType === \"text/plain\") {\n    body = formData;\n    formData = void 0;\n  }\n  return { action, method: method.toLowerCase(), encType, formData, body };\n}\n\n// lib/dom/ssr/components.tsx\nvar React9 = __toESM(__webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react.js\"));\n\n// lib/dom/ssr/invariant.ts\nfunction invariant2(value, message) {\n  if (value === false || value === null || typeof value === \"undefined\") {\n    throw new Error(message);\n  }\n}\n\n// lib/dom/ssr/routeModules.ts\nasync function loadRouteModule(route, routeModulesCache) {\n  if (route.id in routeModulesCache) {\n    return routeModulesCache[route.id];\n  }\n  try {\n    let routeModule = await import(\n      /* @vite-ignore */\n      /* webpackIgnore: true */\n      route.module\n    );\n    routeModulesCache[route.id] = routeModule;\n    return routeModule;\n  } catch (error) {\n    console.error(\n      `Error loading route module \\`${route.module}\\`, reloading page...`\n    );\n    console.error(error);\n    if (window.__reactRouterContext && window.__reactRouterContext.isSpaMode && // @ts-expect-error\n    void 0) {\n      throw error;\n    }\n    window.location.reload();\n    return new Promise(() => {\n    });\n  }\n}\n\n// lib/dom/ssr/links.ts\nfunction getKeyedLinksForMatches(matches, routeModules, manifest) {\n  let descriptors = matches.map((match) => {\n    let module2 = routeModules[match.route.id];\n    let route = manifest.routes[match.route.id];\n    return [\n      route && route.css ? route.css.map((href) => ({ rel: \"stylesheet\", href })) : [],\n      module2?.links?.() || []\n    ];\n  }).flat(2);\n  let preloads = getCurrentPageModulePreloadHrefs(matches, manifest);\n  return dedupeLinkDescriptors(descriptors, preloads);\n}\nasync function prefetchStyleLinks(route, routeModule) {\n  if (!route.css && !routeModule.links || !isPreloadSupported()) return;\n  let descriptors = [];\n  if (route.css) {\n    descriptors.push(...route.css.map((href) => ({ rel: \"stylesheet\", href })));\n  }\n  if (routeModule.links) {\n    descriptors.push(...routeModule.links());\n  }\n  if (descriptors.length === 0) return;\n  let styleLinks = [];\n  for (let descriptor of descriptors) {\n    if (!isPageLinkDescriptor(descriptor) && descriptor.rel === \"stylesheet\") {\n      styleLinks.push({\n        ...descriptor,\n        rel: \"preload\",\n        as: \"style\"\n      });\n    }\n  }\n  let matchingLinks = styleLinks.filter(\n    (link) => (!link.media || window.matchMedia(link.media).matches) && !document.querySelector(`link[rel=\"stylesheet\"][href=\"${link.href}\"]`)\n  );\n  await Promise.all(matchingLinks.map(prefetchStyleLink));\n}\nasync function prefetchStyleLink(descriptor) {\n  return new Promise((resolve) => {\n    let link = document.createElement(\"link\");\n    Object.assign(link, descriptor);\n    function removeLink() {\n      if (document.head.contains(link)) {\n        document.head.removeChild(link);\n      }\n    }\n    link.onload = () => {\n      removeLink();\n      resolve();\n    };\n    link.onerror = () => {\n      removeLink();\n      resolve();\n    };\n    document.head.appendChild(link);\n  });\n}\nfunction isPageLinkDescriptor(object) {\n  return object != null && typeof object.page === \"string\";\n}\nfunction isHtmlLinkDescriptor(object) {\n  if (object == null) {\n    return false;\n  }\n  if (object.href == null) {\n    return object.rel === \"preload\" && typeof object.imageSrcSet === \"string\" && typeof object.imageSizes === \"string\";\n  }\n  return typeof object.rel === \"string\" && typeof object.href === \"string\";\n}\nasync function getKeyedPrefetchLinks(matches, manifest, routeModules) {\n  let links = await Promise.all(\n    matches.map(async (match) => {\n      let route = manifest.routes[match.route.id];\n      if (route) {\n        let mod = await loadRouteModule(route, routeModules);\n        return mod.links ? mod.links() : [];\n      }\n      return [];\n    })\n  );\n  return dedupeLinkDescriptors(\n    links.flat(1).filter(isHtmlLinkDescriptor).filter((link) => link.rel === \"stylesheet\" || link.rel === \"preload\").map(\n      (link) => link.rel === \"stylesheet\" ? { ...link, rel: \"prefetch\", as: \"style\" } : { ...link, rel: \"prefetch\" }\n    )\n  );\n}\nfunction getNewMatchesForLinks(page, nextMatches, currentMatches, manifest, location, mode) {\n  let isNew = (match, index) => {\n    if (!currentMatches[index]) return true;\n    return match.route.id !== currentMatches[index].route.id;\n  };\n  let matchPathChanged = (match, index) => {\n    return (\n      // param change, /users/123 -> /users/456\n      currentMatches[index].pathname !== match.pathname || // splat param changed, which is not present in match.path\n      // e.g. /files/images/avatar.jpg -> files/finances.xls\n      currentMatches[index].route.path?.endsWith(\"*\") && currentMatches[index].params[\"*\"] !== match.params[\"*\"]\n    );\n  };\n  if (mode === \"assets\") {\n    return nextMatches.filter(\n      (match, index) => isNew(match, index) || matchPathChanged(match, index)\n    );\n  }\n  if (mode === \"data\") {\n    return nextMatches.filter((match, index) => {\n      let manifestRoute = manifest.routes[match.route.id];\n      if (!manifestRoute || !manifestRoute.hasLoader) {\n        return false;\n      }\n      if (isNew(match, index) || matchPathChanged(match, index)) {\n        return true;\n      }\n      if (match.route.shouldRevalidate) {\n        let routeChoice = match.route.shouldRevalidate({\n          currentUrl: new URL(\n            location.pathname + location.search + location.hash,\n            window.origin\n          ),\n          currentParams: currentMatches[0]?.params || {},\n          nextUrl: new URL(page, window.origin),\n          nextParams: match.params,\n          defaultShouldRevalidate: true\n        });\n        if (typeof routeChoice === \"boolean\") {\n          return routeChoice;\n        }\n      }\n      return true;\n    });\n  }\n  return [];\n}\nfunction getModuleLinkHrefs(matches, manifestPatch) {\n  return dedupeHrefs(\n    matches.map((match) => {\n      let route = manifestPatch.routes[match.route.id];\n      if (!route) return [];\n      let hrefs = [route.module];\n      if (route.imports) {\n        hrefs = hrefs.concat(route.imports);\n      }\n      return hrefs;\n    }).flat(1)\n  );\n}\nfunction getCurrentPageModulePreloadHrefs(matches, manifest) {\n  return dedupeHrefs(\n    matches.map((match) => {\n      let route = manifest.routes[match.route.id];\n      if (!route) return [];\n      let hrefs = [route.module];\n      if (route.imports) {\n        hrefs = hrefs.concat(route.imports);\n      }\n      return hrefs;\n    }).flat(1)\n  );\n}\nfunction dedupeHrefs(hrefs) {\n  return [...new Set(hrefs)];\n}\nfunction sortKeys(obj) {\n  let sorted = {};\n  let keys = Object.keys(obj).sort();\n  for (let key of keys) {\n    sorted[key] = obj[key];\n  }\n  return sorted;\n}\nfunction dedupeLinkDescriptors(descriptors, preloads) {\n  let set = /* @__PURE__ */ new Set();\n  let preloadsSet = new Set(preloads);\n  return descriptors.reduce((deduped, descriptor) => {\n    let alreadyModulePreload = preloads && !isPageLinkDescriptor(descriptor) && descriptor.as === \"script\" && descriptor.href && preloadsSet.has(descriptor.href);\n    if (alreadyModulePreload) {\n      return deduped;\n    }\n    let key = JSON.stringify(sortKeys(descriptor));\n    if (!set.has(key)) {\n      set.add(key);\n      deduped.push({ key, link: descriptor });\n    }\n    return deduped;\n  }, []);\n}\nvar _isPreloadSupported;\nfunction isPreloadSupported() {\n  if (_isPreloadSupported !== void 0) {\n    return _isPreloadSupported;\n  }\n  let el = document.createElement(\"link\");\n  _isPreloadSupported = el.relList.supports(\"preload\");\n  el = null;\n  return _isPreloadSupported;\n}\n\n// lib/dom/ssr/markup.ts\nvar ESCAPE_LOOKUP = {\n  \"&\": \"\\\\u0026\",\n  \">\": \"\\\\u003e\",\n  \"<\": \"\\\\u003c\",\n  \"\\u2028\": \"\\\\u2028\",\n  \"\\u2029\": \"\\\\u2029\"\n};\nvar ESCAPE_REGEX = /[&><\\u2028\\u2029]/g;\nfunction escapeHtml(html) {\n  return html.replace(ESCAPE_REGEX, (match) => ESCAPE_LOOKUP[match]);\n}\nfunction createHtml(html) {\n  return { __html: html };\n}\n\n// lib/dom/ssr/single-fetch.tsx\nvar React4 = __toESM(__webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react.js\"));\nvar import_turbo_stream = __webpack_require__(/*! turbo-stream */ \"(ssr)/./node_modules/turbo-stream/dist/turbo-stream.js\");\n\n// lib/dom/ssr/data.ts\nasync function createRequestInit(request) {\n  let init = { signal: request.signal };\n  if (request.method !== \"GET\") {\n    init.method = request.method;\n    let contentType = request.headers.get(\"Content-Type\");\n    if (contentType && /\\bapplication\\/json\\b/.test(contentType)) {\n      init.headers = { \"Content-Type\": contentType };\n      init.body = JSON.stringify(await request.json());\n    } else if (contentType && /\\btext\\/plain\\b/.test(contentType)) {\n      init.headers = { \"Content-Type\": contentType };\n      init.body = await request.text();\n    } else if (contentType && /\\bapplication\\/x-www-form-urlencoded\\b/.test(contentType)) {\n      init.body = new URLSearchParams(await request.text());\n    } else {\n      init.body = await request.formData();\n    }\n  }\n  return init;\n}\n\n// lib/dom/ssr/single-fetch.tsx\nvar SingleFetchRedirectSymbol = Symbol(\"SingleFetchRedirect\");\nfunction StreamTransfer({\n  context,\n  identifier,\n  reader,\n  textDecoder,\n  nonce\n}) {\n  if (!context.renderMeta || !context.renderMeta.didRenderScripts) {\n    return null;\n  }\n  if (!context.renderMeta.streamCache) {\n    context.renderMeta.streamCache = {};\n  }\n  let { streamCache } = context.renderMeta;\n  let promise = streamCache[identifier];\n  if (!promise) {\n    promise = streamCache[identifier] = reader.read().then((result) => {\n      streamCache[identifier].result = {\n        done: result.done,\n        value: textDecoder.decode(result.value, { stream: true })\n      };\n    }).catch((e) => {\n      streamCache[identifier].error = e;\n    });\n  }\n  if (promise.error) {\n    throw promise.error;\n  }\n  if (promise.result === void 0) {\n    throw promise;\n  }\n  let { done, value } = promise.result;\n  let scriptTag = value ? /* @__PURE__ */ React4.createElement(\n    \"script\",\n    {\n      nonce,\n      dangerouslySetInnerHTML: {\n        __html: `window.__reactRouterContext.streamController.enqueue(${escapeHtml(\n          JSON.stringify(value)\n        )});`\n      }\n    }\n  ) : null;\n  if (done) {\n    return /* @__PURE__ */ React4.createElement(React4.Fragment, null, scriptTag, /* @__PURE__ */ React4.createElement(\n      \"script\",\n      {\n        nonce,\n        dangerouslySetInnerHTML: {\n          __html: `window.__reactRouterContext.streamController.close();`\n        }\n      }\n    ));\n  } else {\n    return /* @__PURE__ */ React4.createElement(React4.Fragment, null, scriptTag, /* @__PURE__ */ React4.createElement(React4.Suspense, null, /* @__PURE__ */ React4.createElement(\n      StreamTransfer,\n      {\n        context,\n        identifier: identifier + 1,\n        reader,\n        textDecoder,\n        nonce\n      }\n    )));\n  }\n}\nfunction getSingleFetchDataStrategy(manifest, routeModules, getRouter) {\n  return async ({ request, matches, fetcherKey }) => {\n    if (request.method !== \"GET\") {\n      return singleFetchActionStrategy(request, matches);\n    }\n    if (fetcherKey) {\n      return singleFetchLoaderFetcherStrategy(request, matches);\n    }\n    return singleFetchLoaderNavigationStrategy(\n      manifest,\n      routeModules,\n      getRouter(),\n      request,\n      matches\n    );\n  };\n}\nasync function singleFetchActionStrategy(request, matches) {\n  let actionMatch = matches.find((m) => m.shouldLoad);\n  invariant2(actionMatch, \"No action match found\");\n  let actionStatus = void 0;\n  let result = await actionMatch.resolve(async (handler) => {\n    let result2 = await handler(async () => {\n      let url = singleFetchUrl(request.url);\n      let init = await createRequestInit(request);\n      let { data: data2, status } = await fetchAndDecode(url, init);\n      actionStatus = status;\n      return unwrapSingleFetchResult(\n        data2,\n        actionMatch.route.id\n      );\n    });\n    return result2;\n  });\n  if (isResponse(result.result) || isRouteErrorResponse(result.result)) {\n    return { [actionMatch.route.id]: result };\n  }\n  return {\n    [actionMatch.route.id]: {\n      type: result.type,\n      result: data(result.result, actionStatus)\n    }\n  };\n}\nasync function singleFetchLoaderNavigationStrategy(manifest, routeModules, router, request, matches) {\n  let routesParams = /* @__PURE__ */ new Set();\n  let foundOptOutRoute = false;\n  let routeDfds = matches.map(() => createDeferred2());\n  let routesLoadedPromise = Promise.all(routeDfds.map((d) => d.promise));\n  let singleFetchDfd = createDeferred2();\n  let url = stripIndexParam(singleFetchUrl(request.url));\n  let init = await createRequestInit(request);\n  let results = {};\n  let resolvePromise = Promise.all(\n    matches.map(\n      async (m, i) => m.resolve(async (handler) => {\n        routeDfds[i].resolve();\n        let manifestRoute = manifest.routes[m.route.id];\n        if (!m.shouldLoad) {\n          if (!router.state.initialized) {\n            return;\n          }\n          if (m.route.id in router.state.loaderData && manifestRoute && manifestRoute.hasLoader && routeModules[m.route.id]?.shouldRevalidate) {\n            foundOptOutRoute = true;\n            return;\n          }\n        }\n        if (manifestRoute && manifestRoute.hasClientLoader) {\n          if (manifestRoute.hasLoader) {\n            foundOptOutRoute = true;\n          }\n          try {\n            let result = await fetchSingleLoader(\n              handler,\n              url,\n              init,\n              m.route.id\n            );\n            results[m.route.id] = { type: \"data\", result };\n          } catch (e) {\n            results[m.route.id] = { type: \"error\", result: e };\n          }\n          return;\n        }\n        if (manifestRoute && manifestRoute.hasLoader) {\n          routesParams.add(m.route.id);\n        }\n        try {\n          let result = await handler(async () => {\n            let data2 = await singleFetchDfd.promise;\n            return unwrapSingleFetchResults(data2, m.route.id);\n          });\n          results[m.route.id] = {\n            type: \"data\",\n            result\n          };\n        } catch (e) {\n          results[m.route.id] = {\n            type: \"error\",\n            result: e\n          };\n        }\n      })\n    )\n  );\n  await routesLoadedPromise;\n  if ((!router.state.initialized || routesParams.size === 0) && !window.__reactRouterHdrActive) {\n    singleFetchDfd.resolve({});\n  } else {\n    try {\n      if (foundOptOutRoute && routesParams.size > 0) {\n        url.searchParams.set(\n          \"_routes\",\n          matches.filter((m) => routesParams.has(m.route.id)).map((m) => m.route.id).join(\",\")\n        );\n      }\n      let data2 = await fetchAndDecode(url, init);\n      singleFetchDfd.resolve(data2.data);\n    } catch (e) {\n      singleFetchDfd.reject(e);\n    }\n  }\n  await resolvePromise;\n  return results;\n}\nasync function singleFetchLoaderFetcherStrategy(request, matches) {\n  let fetcherMatch = matches.find((m) => m.shouldLoad);\n  invariant2(fetcherMatch, \"No fetcher match found\");\n  let result = await fetcherMatch.resolve(async (handler) => {\n    let url = stripIndexParam(singleFetchUrl(request.url));\n    let init = await createRequestInit(request);\n    return fetchSingleLoader(handler, url, init, fetcherMatch.route.id);\n  });\n  return { [fetcherMatch.route.id]: result };\n}\nfunction fetchSingleLoader(handler, url, init, routeId) {\n  return handler(async () => {\n    let singleLoaderUrl = new URL(url);\n    singleLoaderUrl.searchParams.set(\"_routes\", routeId);\n    let { data: data2 } = await fetchAndDecode(singleLoaderUrl, init);\n    return unwrapSingleFetchResults(data2, routeId);\n  });\n}\nfunction stripIndexParam(url) {\n  let indexValues = url.searchParams.getAll(\"index\");\n  url.searchParams.delete(\"index\");\n  let indexValuesToKeep = [];\n  for (let indexValue of indexValues) {\n    if (indexValue) {\n      indexValuesToKeep.push(indexValue);\n    }\n  }\n  for (let toKeep of indexValuesToKeep) {\n    url.searchParams.append(\"index\", toKeep);\n  }\n  return url;\n}\nfunction singleFetchUrl(reqUrl) {\n  let url = typeof reqUrl === \"string\" ? new URL(\n    reqUrl,\n    // This can be called during the SSR flow via PrefetchPageLinksImpl so\n    // don't assume window is available\n    typeof window === \"undefined\" ? \"server://singlefetch/\" : window.location.origin\n  ) : reqUrl;\n  if (url.pathname === \"/\") {\n    url.pathname = \"_root.data\";\n  } else {\n    url.pathname = `${url.pathname.replace(/\\/$/, \"\")}.data`;\n  }\n  return url;\n}\nasync function fetchAndDecode(url, init) {\n  let res = await fetch(url, init);\n  if (res.status === 404 && !res.headers.has(\"X-Remix-Response\")) {\n    throw new ErrorResponseImpl(404, \"Not Found\", true);\n  }\n  invariant2(res.body, \"No response body to decode\");\n  try {\n    let decoded = await decodeViaTurboStream(res.body, window);\n    return { status: res.status, data: decoded.value };\n  } catch (e) {\n    throw new Error(\"Unable to decode turbo-stream response\");\n  }\n}\nfunction decodeViaTurboStream(body, global2) {\n  return (0, import_turbo_stream.decode)(body, {\n    plugins: [\n      (type, ...rest) => {\n        if (type === \"SanitizedError\") {\n          let [name, message, stack] = rest;\n          let Constructor = Error;\n          if (name && name in global2 && typeof global2[name] === \"function\") {\n            Constructor = global2[name];\n          }\n          let error = new Constructor(message);\n          error.stack = stack;\n          return { value: error };\n        }\n        if (type === \"ErrorResponse\") {\n          let [data2, status, statusText] = rest;\n          return {\n            value: new ErrorResponseImpl(status, statusText, data2)\n          };\n        }\n        if (type === \"SingleFetchRedirect\") {\n          return { value: { [SingleFetchRedirectSymbol]: rest[0] } };\n        }\n        if (type === \"SingleFetchClassInstance\") {\n          return { value: rest[0] };\n        }\n        if (type === \"SingleFetchFallback\") {\n          return { value: void 0 };\n        }\n      }\n    ]\n  });\n}\nfunction unwrapSingleFetchResults(results, routeId) {\n  let redirect2 = results[SingleFetchRedirectSymbol];\n  if (redirect2) {\n    return unwrapSingleFetchResult(redirect2, routeId);\n  }\n  return results[routeId] !== void 0 ? unwrapSingleFetchResult(results[routeId], routeId) : null;\n}\nfunction unwrapSingleFetchResult(result, routeId) {\n  if (\"error\" in result) {\n    throw result.error;\n  } else if (\"redirect\" in result) {\n    let headers = {};\n    if (result.revalidate) {\n      headers[\"X-Remix-Revalidate\"] = \"yes\";\n    }\n    if (result.reload) {\n      headers[\"X-Remix-Reload-Document\"] = \"yes\";\n    }\n    if (result.replace) {\n      headers[\"X-Remix-Replace\"] = \"yes\";\n    }\n    throw redirect(result.redirect, { status: result.status, headers });\n  } else if (\"data\" in result) {\n    return result.data;\n  } else {\n    throw new Error(`No response found for routeId \"${routeId}\"`);\n  }\n}\nfunction createDeferred2() {\n  let resolve;\n  let reject;\n  let promise = new Promise((res, rej) => {\n    resolve = async (val) => {\n      res(val);\n      try {\n        await promise;\n      } catch (e) {\n      }\n    };\n    reject = async (error) => {\n      rej(error);\n      try {\n        await promise;\n      } catch (e) {\n      }\n    };\n  });\n  return {\n    promise,\n    //@ts-ignore\n    resolve,\n    //@ts-ignore\n    reject\n  };\n}\n\n// lib/dom/ssr/fog-of-war.ts\nvar React8 = __toESM(__webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react.js\"));\n\n// lib/dom/ssr/routes.tsx\nvar React7 = __toESM(__webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react.js\"));\n\n// lib/dom/ssr/errorBoundaries.tsx\nvar React5 = __toESM(__webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react.js\"));\nvar RemixErrorBoundary = class extends React5.Component {\n  constructor(props) {\n    super(props);\n    this.state = { error: props.error || null, location: props.location };\n  }\n  static getDerivedStateFromError(error) {\n    return { error };\n  }\n  static getDerivedStateFromProps(props, state) {\n    if (state.location !== props.location) {\n      return { error: props.error || null, location: props.location };\n    }\n    return { error: props.error || state.error, location: state.location };\n  }\n  render() {\n    if (this.state.error) {\n      return /* @__PURE__ */ React5.createElement(\n        RemixRootDefaultErrorBoundary,\n        {\n          error: this.state.error,\n          isOutsideRemixApp: true\n        }\n      );\n    } else {\n      return this.props.children;\n    }\n  }\n};\nfunction RemixRootDefaultErrorBoundary({\n  error,\n  isOutsideRemixApp\n}) {\n  console.error(error);\n  let heyDeveloper = /* @__PURE__ */ React5.createElement(\n    \"script\",\n    {\n      dangerouslySetInnerHTML: {\n        __html: `\n        console.log(\n          \"\\u{1F4BF} Hey developer \\u{1F44B}. You can provide a way better UX than this when your app throws errors. Check out https://remix.run/guides/errors for more information.\"\n        );\n      `\n      }\n    }\n  );\n  if (isRouteErrorResponse(error)) {\n    return /* @__PURE__ */ React5.createElement(BoundaryShell, { title: \"Unhandled Thrown Response!\" }, /* @__PURE__ */ React5.createElement(\"h1\", { style: { fontSize: \"24px\" } }, error.status, \" \", error.statusText), heyDeveloper);\n  }\n  let errorInstance;\n  if (error instanceof Error) {\n    errorInstance = error;\n  } else {\n    let errorString = error == null ? \"Unknown Error\" : typeof error === \"object\" && \"toString\" in error ? error.toString() : JSON.stringify(error);\n    errorInstance = new Error(errorString);\n  }\n  return /* @__PURE__ */ React5.createElement(\n    BoundaryShell,\n    {\n      title: \"Application Error!\",\n      isOutsideRemixApp\n    },\n    /* @__PURE__ */ React5.createElement(\"h1\", { style: { fontSize: \"24px\" } }, \"Application Error\"),\n    /* @__PURE__ */ React5.createElement(\n      \"pre\",\n      {\n        style: {\n          padding: \"2rem\",\n          background: \"hsla(10, 50%, 50%, 0.1)\",\n          color: \"red\",\n          overflow: \"auto\"\n        }\n      },\n      errorInstance.stack\n    ),\n    heyDeveloper\n  );\n}\nfunction BoundaryShell({\n  title,\n  renderScripts,\n  isOutsideRemixApp,\n  children\n}) {\n  let { routeModules } = useFrameworkContext();\n  if (routeModules.root?.Layout && !isOutsideRemixApp) {\n    return children;\n  }\n  return /* @__PURE__ */ React5.createElement(\"html\", { lang: \"en\" }, /* @__PURE__ */ React5.createElement(\"head\", null, /* @__PURE__ */ React5.createElement(\"meta\", { charSet: \"utf-8\" }), /* @__PURE__ */ React5.createElement(\n    \"meta\",\n    {\n      name: \"viewport\",\n      content: \"width=device-width,initial-scale=1,viewport-fit=cover\"\n    }\n  ), /* @__PURE__ */ React5.createElement(\"title\", null, title)), /* @__PURE__ */ React5.createElement(\"body\", null, /* @__PURE__ */ React5.createElement(\"main\", { style: { fontFamily: \"system-ui, sans-serif\", padding: \"2rem\" } }, children, renderScripts ? /* @__PURE__ */ React5.createElement(Scripts, null) : null)));\n}\n\n// lib/dom/ssr/fallback.tsx\nvar React6 = __toESM(__webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react.js\"));\nfunction RemixRootDefaultHydrateFallback() {\n  return /* @__PURE__ */ React6.createElement(BoundaryShell, { title: \"Loading...\", renderScripts: true }, /* @__PURE__ */ React6.createElement(\n    \"script\",\n    {\n      dangerouslySetInnerHTML: {\n        __html: `\n              console.log(\n                \"\\u{1F4BF} Hey developer \\u{1F44B}. You can provide a way better UX than this \" +\n                \"when your app is loading JS modules and/or running \\`clientLoader\\` \" +\n                \"functions. Check out https://remix.run/route/hydrate-fallback \" +\n                \"for more information.\"\n              );\n            `\n      }\n    }\n  ));\n}\n\n// lib/dom/ssr/routes.tsx\nfunction groupRoutesByParentId(manifest) {\n  let routes = {};\n  Object.values(manifest).forEach((route) => {\n    if (route) {\n      let parentId = route.parentId || \"\";\n      if (!routes[parentId]) {\n        routes[parentId] = [];\n      }\n      routes[parentId].push(route);\n    }\n  });\n  return routes;\n}\nfunction getRouteComponents(route, routeModule, isSpaMode) {\n  let Component4 = getRouteModuleComponent(routeModule);\n  let HydrateFallback = routeModule.HydrateFallback && (!isSpaMode || route.id === \"root\") ? routeModule.HydrateFallback : route.id === \"root\" ? RemixRootDefaultHydrateFallback : void 0;\n  let ErrorBoundary = routeModule.ErrorBoundary ? routeModule.ErrorBoundary : route.id === \"root\" ? () => /* @__PURE__ */ React7.createElement(RemixRootDefaultErrorBoundary, { error: useRouteError() }) : void 0;\n  if (route.id === \"root\" && routeModule.Layout) {\n    return {\n      ...Component4 ? {\n        element: /* @__PURE__ */ React7.createElement(routeModule.Layout, null, /* @__PURE__ */ React7.createElement(Component4, null))\n      } : { Component: Component4 },\n      ...ErrorBoundary ? {\n        errorElement: /* @__PURE__ */ React7.createElement(routeModule.Layout, null, /* @__PURE__ */ React7.createElement(ErrorBoundary, null))\n      } : { ErrorBoundary },\n      ...HydrateFallback ? {\n        hydrateFallbackElement: /* @__PURE__ */ React7.createElement(routeModule.Layout, null, /* @__PURE__ */ React7.createElement(HydrateFallback, null))\n      } : { HydrateFallback }\n    };\n  }\n  return { Component: Component4, ErrorBoundary, HydrateFallback };\n}\nfunction createServerRoutes(manifest, routeModules, future, isSpaMode, parentId = \"\", routesByParentId = groupRoutesByParentId(manifest), spaModeLazyPromise = Promise.resolve({ Component: () => null })) {\n  return (routesByParentId[parentId] || []).map((route) => {\n    let routeModule = routeModules[route.id];\n    invariant2(\n      routeModule,\n      \"No `routeModule` available to create server routes\"\n    );\n    let dataRoute = {\n      ...getRouteComponents(route, routeModule, isSpaMode),\n      caseSensitive: route.caseSensitive,\n      id: route.id,\n      index: route.index,\n      path: route.path,\n      handle: routeModule.handle,\n      // For SPA Mode, all routes are lazy except root.  However we tell the\n      // router root is also lazy here too since we don't need a full\n      // implementation - we just need a `lazy` prop to tell the RR rendering\n      // where to stop which is always at the root route in SPA mode\n      lazy: isSpaMode ? () => spaModeLazyPromise : void 0,\n      // For partial hydration rendering, we need to indicate when the route\n      // has a loader/clientLoader, but it won't ever be called during the static\n      // render, so just give it a no-op function so we can render down to the\n      // proper fallback\n      loader: route.hasLoader || route.hasClientLoader ? () => null : void 0\n      // We don't need action/shouldRevalidate on these routes since they're\n      // for a static render\n    };\n    let children = createServerRoutes(\n      manifest,\n      routeModules,\n      future,\n      isSpaMode,\n      route.id,\n      routesByParentId,\n      spaModeLazyPromise\n    );\n    if (children.length > 0) dataRoute.children = children;\n    return dataRoute;\n  });\n}\nfunction createClientRoutesWithHMRRevalidationOptOut(needsRevalidation, manifest, routeModulesCache, initialState, future, isSpaMode) {\n  return createClientRoutes(\n    manifest,\n    routeModulesCache,\n    initialState,\n    isSpaMode,\n    \"\",\n    groupRoutesByParentId(manifest),\n    needsRevalidation\n  );\n}\nfunction preventInvalidServerHandlerCall(type, route, isSpaMode) {\n  if (isSpaMode) {\n    let fn2 = type === \"action\" ? \"serverAction()\" : \"serverLoader()\";\n    let msg2 = `You cannot call ${fn2} in SPA Mode (routeId: \"${route.id}\")`;\n    console.error(msg2);\n    throw new ErrorResponseImpl(400, \"Bad Request\", new Error(msg2), true);\n  }\n  let fn = type === \"action\" ? \"serverAction()\" : \"serverLoader()\";\n  let msg = `You are trying to call ${fn} on a route that does not have a server ${type} (routeId: \"${route.id}\")`;\n  if (type === \"loader\" && !route.hasLoader || type === \"action\" && !route.hasAction) {\n    console.error(msg);\n    throw new ErrorResponseImpl(400, \"Bad Request\", new Error(msg), true);\n  }\n}\nfunction noActionDefinedError(type, routeId) {\n  let article = type === \"clientAction\" ? \"a\" : \"an\";\n  let msg = `Route \"${routeId}\" does not have ${article} ${type}, but you are trying to submit to it. To fix this, please add ${article} \\`${type}\\` function to the route`;\n  console.error(msg);\n  throw new ErrorResponseImpl(405, \"Method Not Allowed\", new Error(msg), true);\n}\nfunction createClientRoutes(manifest, routeModulesCache, initialState, isSpaMode, parentId = \"\", routesByParentId = groupRoutesByParentId(manifest), needsRevalidation) {\n  return (routesByParentId[parentId] || []).map((route) => {\n    let routeModule = routeModulesCache[route.id];\n    function fetchServerHandler(singleFetch) {\n      invariant2(\n        typeof singleFetch === \"function\",\n        \"No single fetch function available for route handler\"\n      );\n      return singleFetch();\n    }\n    function fetchServerLoader(singleFetch) {\n      if (!route.hasLoader) return Promise.resolve(null);\n      return fetchServerHandler(singleFetch);\n    }\n    function fetchServerAction(singleFetch) {\n      if (!route.hasAction) {\n        throw noActionDefinedError(\"action\", route.id);\n      }\n      return fetchServerHandler(singleFetch);\n    }\n    async function prefetchStylesAndCallHandler(handler) {\n      let cachedModule = routeModulesCache[route.id];\n      let linkPrefetchPromise = cachedModule ? prefetchStyleLinks(route, cachedModule) : Promise.resolve();\n      try {\n        return handler();\n      } finally {\n        await linkPrefetchPromise;\n      }\n    }\n    let dataRoute = {\n      id: route.id,\n      index: route.index,\n      path: route.path\n    };\n    if (routeModule) {\n      Object.assign(dataRoute, {\n        ...dataRoute,\n        ...getRouteComponents(route, routeModule, isSpaMode),\n        handle: routeModule.handle,\n        shouldRevalidate: getShouldRevalidateFunction(\n          routeModule,\n          route.id,\n          needsRevalidation\n        )\n      });\n      let hasInitialData = initialState && initialState.loaderData && route.id in initialState.loaderData;\n      let initialData = hasInitialData ? initialState?.loaderData?.[route.id] : void 0;\n      let hasInitialError = initialState && initialState.errors && route.id in initialState.errors;\n      let initialError = hasInitialError ? initialState?.errors?.[route.id] : void 0;\n      let isHydrationRequest = needsRevalidation == null && (routeModule.clientLoader?.hydrate === true || !route.hasLoader);\n      dataRoute.loader = async ({ request, params }, singleFetch) => {\n        try {\n          let result = await prefetchStylesAndCallHandler(async () => {\n            invariant2(\n              routeModule,\n              \"No `routeModule` available for critical-route loader\"\n            );\n            if (!routeModule.clientLoader) {\n              if (isSpaMode) return null;\n              return fetchServerLoader(singleFetch);\n            }\n            return routeModule.clientLoader({\n              request,\n              params,\n              async serverLoader() {\n                preventInvalidServerHandlerCall(\"loader\", route, isSpaMode);\n                if (isHydrationRequest) {\n                  if (hasInitialData) {\n                    return initialData;\n                  }\n                  if (hasInitialError) {\n                    throw initialError;\n                  }\n                }\n                return fetchServerLoader(singleFetch);\n              }\n            });\n          });\n          return result;\n        } finally {\n          isHydrationRequest = false;\n        }\n      };\n      dataRoute.loader.hydrate = shouldHydrateRouteLoader(\n        route,\n        routeModule,\n        isSpaMode\n      );\n      dataRoute.action = ({ request, params }, singleFetch) => {\n        return prefetchStylesAndCallHandler(async () => {\n          invariant2(\n            routeModule,\n            \"No `routeModule` available for critical-route action\"\n          );\n          if (!routeModule.clientAction) {\n            if (isSpaMode) {\n              throw noActionDefinedError(\"clientAction\", route.id);\n            }\n            return fetchServerAction(singleFetch);\n          }\n          return routeModule.clientAction({\n            request,\n            params,\n            async serverAction() {\n              preventInvalidServerHandlerCall(\"action\", route, isSpaMode);\n              return fetchServerAction(singleFetch);\n            }\n          });\n        });\n      };\n    } else {\n      if (!route.hasClientLoader) {\n        dataRoute.loader = ({ request }, singleFetch) => prefetchStylesAndCallHandler(() => {\n          if (isSpaMode) return Promise.resolve(null);\n          return fetchServerLoader(singleFetch);\n        });\n      }\n      if (!route.hasClientAction) {\n        dataRoute.action = ({ request }, singleFetch) => prefetchStylesAndCallHandler(() => {\n          if (isSpaMode) {\n            throw noActionDefinedError(\"clientAction\", route.id);\n          }\n          return fetchServerAction(singleFetch);\n        });\n      }\n      dataRoute.lazy = async () => {\n        let mod = await loadRouteModuleWithBlockingLinks(\n          route,\n          routeModulesCache\n        );\n        let lazyRoute = { ...mod };\n        if (mod.clientLoader) {\n          let clientLoader = mod.clientLoader;\n          lazyRoute.loader = (args, singleFetch) => clientLoader({\n            ...args,\n            async serverLoader() {\n              preventInvalidServerHandlerCall(\"loader\", route, isSpaMode);\n              return fetchServerLoader(singleFetch);\n            }\n          });\n        }\n        if (mod.clientAction) {\n          let clientAction = mod.clientAction;\n          lazyRoute.action = (args, singleFetch) => clientAction({\n            ...args,\n            async serverAction() {\n              preventInvalidServerHandlerCall(\"action\", route, isSpaMode);\n              return fetchServerAction(singleFetch);\n            }\n          });\n        }\n        return {\n          ...lazyRoute.loader ? { loader: lazyRoute.loader } : {},\n          ...lazyRoute.action ? { action: lazyRoute.action } : {},\n          hasErrorBoundary: lazyRoute.hasErrorBoundary,\n          shouldRevalidate: getShouldRevalidateFunction(\n            lazyRoute,\n            route.id,\n            needsRevalidation\n          ),\n          handle: lazyRoute.handle,\n          // No need to wrap these in layout since the root route is never\n          // loaded via route.lazy()\n          Component: lazyRoute.Component,\n          ErrorBoundary: lazyRoute.ErrorBoundary\n        };\n      };\n    }\n    let children = createClientRoutes(\n      manifest,\n      routeModulesCache,\n      initialState,\n      isSpaMode,\n      route.id,\n      routesByParentId,\n      needsRevalidation\n    );\n    if (children.length > 0) dataRoute.children = children;\n    return dataRoute;\n  });\n}\nfunction getShouldRevalidateFunction(route, routeId, needsRevalidation) {\n  if (needsRevalidation) {\n    return wrapShouldRevalidateForHdr(\n      routeId,\n      route.shouldRevalidate,\n      needsRevalidation\n    );\n  }\n  if (route.shouldRevalidate) {\n    let fn = route.shouldRevalidate;\n    return (opts) => fn({ ...opts, defaultShouldRevalidate: true });\n  }\n  return route.shouldRevalidate;\n}\nfunction wrapShouldRevalidateForHdr(routeId, routeShouldRevalidate, needsRevalidation) {\n  let handledRevalidation = false;\n  return (arg) => {\n    if (!handledRevalidation) {\n      handledRevalidation = true;\n      return needsRevalidation.has(routeId);\n    }\n    return routeShouldRevalidate ? routeShouldRevalidate(arg) : arg.defaultShouldRevalidate;\n  };\n}\nasync function loadRouteModuleWithBlockingLinks(route, routeModules) {\n  let routeModule = await loadRouteModule(route, routeModules);\n  await prefetchStyleLinks(route, routeModule);\n  return {\n    Component: getRouteModuleComponent(routeModule),\n    ErrorBoundary: routeModule.ErrorBoundary,\n    clientAction: routeModule.clientAction,\n    clientLoader: routeModule.clientLoader,\n    handle: routeModule.handle,\n    links: routeModule.links,\n    meta: routeModule.meta,\n    shouldRevalidate: routeModule.shouldRevalidate\n  };\n}\nfunction getRouteModuleComponent(routeModule) {\n  if (routeModule.default == null) return void 0;\n  let isEmptyObject = typeof routeModule.default === \"object\" && Object.keys(routeModule.default).length === 0;\n  if (!isEmptyObject) {\n    return routeModule.default;\n  }\n}\nfunction shouldHydrateRouteLoader(route, routeModule, isSpaMode) {\n  return isSpaMode && route.id !== \"root\" || routeModule.clientLoader != null && (routeModule.clientLoader.hydrate === true || route.hasLoader !== true);\n}\n\n// lib/dom/ssr/fog-of-war.ts\nvar nextPaths = /* @__PURE__ */ new Set();\nvar discoveredPathsMaxSize = 1e3;\nvar discoveredPaths = /* @__PURE__ */ new Set();\nvar URL_LIMIT = 7680;\nfunction isFogOfWarEnabled(isSpaMode) {\n  return !isSpaMode;\n}\nfunction getPartialManifest(manifest, router) {\n  let routeIds = new Set(router.state.matches.map((m) => m.route.id));\n  let segments = router.state.location.pathname.split(\"/\").filter(Boolean);\n  let paths = [\"/\"];\n  segments.pop();\n  while (segments.length > 0) {\n    paths.push(`/${segments.join(\"/\")}`);\n    segments.pop();\n  }\n  paths.forEach((path) => {\n    let matches = matchRoutes(router.routes, path, router.basename);\n    if (matches) {\n      matches.forEach((m) => routeIds.add(m.route.id));\n    }\n  });\n  let initialRoutes = [...routeIds].reduce(\n    (acc, id) => Object.assign(acc, { [id]: manifest.routes[id] }),\n    {}\n  );\n  return {\n    ...manifest,\n    routes: initialRoutes\n  };\n}\nfunction getPatchRoutesOnNavigationFunction(manifest, routeModules, isSpaMode, basename) {\n  if (!isFogOfWarEnabled(isSpaMode)) {\n    return void 0;\n  }\n  return async ({ path, patch }) => {\n    if (discoveredPaths.has(path)) {\n      return;\n    }\n    await fetchAndApplyManifestPatches(\n      [path],\n      manifest,\n      routeModules,\n      isSpaMode,\n      basename,\n      patch\n    );\n  };\n}\nfunction useFogOFWarDiscovery(router, manifest, routeModules, isSpaMode) {\n  React8.useEffect(() => {\n    if (!isFogOfWarEnabled(isSpaMode) || navigator.connection?.saveData === true) {\n      return;\n    }\n    function registerElement(el) {\n      let path = el.tagName === \"FORM\" ? el.getAttribute(\"action\") : el.getAttribute(\"href\");\n      if (!path) {\n        return;\n      }\n      let url = new URL(path, window.location.origin);\n      if (!discoveredPaths.has(url.pathname)) {\n        nextPaths.add(url.pathname);\n      }\n    }\n    async function fetchPatches() {\n      let lazyPaths = Array.from(nextPaths.keys()).filter((path) => {\n        if (discoveredPaths.has(path)) {\n          nextPaths.delete(path);\n          return false;\n        }\n        return true;\n      });\n      if (lazyPaths.length === 0) {\n        return;\n      }\n      try {\n        await fetchAndApplyManifestPatches(\n          lazyPaths,\n          manifest,\n          routeModules,\n          isSpaMode,\n          router.basename,\n          router.patchRoutes\n        );\n      } catch (e) {\n        console.error(\"Failed to fetch manifest patches\", e);\n      }\n    }\n    document.body.querySelectorAll(\"a[data-discover], form[data-discover]\").forEach((el) => registerElement(el));\n    fetchPatches();\n    let debouncedFetchPatches = debounce(fetchPatches, 100);\n    function isElement(node) {\n      return node.nodeType === Node.ELEMENT_NODE;\n    }\n    let observer = new MutationObserver((records) => {\n      let elements = /* @__PURE__ */ new Set();\n      records.forEach((r) => {\n        [r.target, ...r.addedNodes].forEach((node) => {\n          if (!isElement(node)) return;\n          if (node.tagName === \"A\" && node.getAttribute(\"data-discover\")) {\n            elements.add(node);\n          } else if (node.tagName === \"FORM\" && node.getAttribute(\"data-discover\")) {\n            elements.add(node);\n          }\n          if (node.tagName !== \"A\") {\n            node.querySelectorAll(\"a[data-discover], form[data-discover]\").forEach((el) => elements.add(el));\n          }\n        });\n      });\n      elements.forEach((el) => registerElement(el));\n      debouncedFetchPatches();\n    });\n    observer.observe(document.documentElement, {\n      subtree: true,\n      childList: true,\n      attributes: true,\n      attributeFilter: [\"data-discover\", \"href\", \"action\"]\n    });\n    return () => observer.disconnect();\n  }, [isSpaMode, manifest, routeModules, router]);\n}\nasync function fetchAndApplyManifestPatches(paths, manifest, routeModules, isSpaMode, basename, patchRoutes) {\n  let manifestPath = `${basename != null ? basename : \"/\"}/__manifest`.replace(\n    /\\/+/g,\n    \"/\"\n  );\n  let url = new URL(manifestPath, window.location.origin);\n  paths.sort().forEach((path) => url.searchParams.append(\"p\", path));\n  url.searchParams.set(\"version\", manifest.version);\n  if (url.toString().length > URL_LIMIT) {\n    nextPaths.clear();\n    return;\n  }\n  let res = await fetch(url);\n  if (!res.ok) {\n    throw new Error(`${res.status} ${res.statusText}`);\n  } else if (res.status >= 400) {\n    throw new Error(await res.text());\n  }\n  let serverPatches = await res.json();\n  let knownRoutes = new Set(Object.keys(manifest.routes));\n  let patches = Object.values(serverPatches).reduce((acc, route) => {\n    if (route && !knownRoutes.has(route.id)) {\n      acc[route.id] = route;\n    }\n    return acc;\n  }, {});\n  Object.assign(manifest.routes, patches);\n  paths.forEach((p) => addToFifoQueue(p, discoveredPaths));\n  let parentIds = /* @__PURE__ */ new Set();\n  Object.values(patches).forEach((patch) => {\n    if (patch && (!patch.parentId || !patches[patch.parentId])) {\n      parentIds.add(patch.parentId);\n    }\n  });\n  parentIds.forEach(\n    (parentId) => patchRoutes(\n      parentId || null,\n      createClientRoutes(patches, routeModules, null, isSpaMode, parentId)\n    )\n  );\n}\nfunction addToFifoQueue(path, queue) {\n  if (queue.size >= discoveredPathsMaxSize) {\n    let first = queue.values().next().value;\n    queue.delete(first);\n  }\n  queue.add(path);\n}\nfunction debounce(callback, wait) {\n  let timeoutId;\n  return (...args) => {\n    window.clearTimeout(timeoutId);\n    timeoutId = window.setTimeout(() => callback(...args), wait);\n  };\n}\n\n// lib/dom/ssr/components.tsx\nfunction useDataRouterContext2() {\n  let context = React9.useContext(DataRouterContext);\n  invariant2(\n    context,\n    \"You must render this element inside a <DataRouterContext.Provider> element\"\n  );\n  return context;\n}\nfunction useDataRouterStateContext() {\n  let context = React9.useContext(DataRouterStateContext);\n  invariant2(\n    context,\n    \"You must render this element inside a <DataRouterStateContext.Provider> element\"\n  );\n  return context;\n}\nvar FrameworkContext = React9.createContext(void 0);\nFrameworkContext.displayName = \"FrameworkContext\";\nfunction useFrameworkContext() {\n  let context = React9.useContext(FrameworkContext);\n  invariant2(\n    context,\n    \"You must render this element inside a <HydratedRouter> element\"\n  );\n  return context;\n}\nfunction usePrefetchBehavior(prefetch, theirElementProps) {\n  let frameworkContext = React9.useContext(FrameworkContext);\n  let [maybePrefetch, setMaybePrefetch] = React9.useState(false);\n  let [shouldPrefetch, setShouldPrefetch] = React9.useState(false);\n  let { onFocus, onBlur, onMouseEnter, onMouseLeave, onTouchStart } = theirElementProps;\n  let ref = React9.useRef(null);\n  React9.useEffect(() => {\n    if (prefetch === \"render\") {\n      setShouldPrefetch(true);\n    }\n    if (prefetch === \"viewport\") {\n      let callback = (entries) => {\n        entries.forEach((entry) => {\n          setShouldPrefetch(entry.isIntersecting);\n        });\n      };\n      let observer = new IntersectionObserver(callback, { threshold: 0.5 });\n      if (ref.current) observer.observe(ref.current);\n      return () => {\n        observer.disconnect();\n      };\n    }\n  }, [prefetch]);\n  React9.useEffect(() => {\n    if (maybePrefetch) {\n      let id = setTimeout(() => {\n        setShouldPrefetch(true);\n      }, 100);\n      return () => {\n        clearTimeout(id);\n      };\n    }\n  }, [maybePrefetch]);\n  let setIntent = () => {\n    setMaybePrefetch(true);\n  };\n  let cancelIntent = () => {\n    setMaybePrefetch(false);\n    setShouldPrefetch(false);\n  };\n  if (!frameworkContext) {\n    return [false, ref, {}];\n  }\n  if (prefetch !== \"intent\") {\n    return [shouldPrefetch, ref, {}];\n  }\n  return [\n    shouldPrefetch,\n    ref,\n    {\n      onFocus: composeEventHandlers(onFocus, setIntent),\n      onBlur: composeEventHandlers(onBlur, cancelIntent),\n      onMouseEnter: composeEventHandlers(onMouseEnter, setIntent),\n      onMouseLeave: composeEventHandlers(onMouseLeave, cancelIntent),\n      onTouchStart: composeEventHandlers(onTouchStart, setIntent)\n    }\n  ];\n}\nfunction composeEventHandlers(theirHandler, ourHandler) {\n  return (event) => {\n    theirHandler && theirHandler(event);\n    if (!event.defaultPrevented) {\n      ourHandler(event);\n    }\n  };\n}\nfunction getActiveMatches(matches, errors, isSpaMode) {\n  if (isSpaMode && !isHydrated) {\n    return [matches[0]];\n  }\n  if (errors) {\n    let errorIdx = matches.findIndex((m) => errors[m.route.id] !== void 0);\n    return matches.slice(0, errorIdx + 1);\n  }\n  return matches;\n}\nfunction Links() {\n  let { isSpaMode, manifest, routeModules, criticalCss } = useFrameworkContext();\n  let { errors, matches: routerMatches } = useDataRouterStateContext();\n  let matches = getActiveMatches(routerMatches, errors, isSpaMode);\n  let keyedLinks = React9.useMemo(\n    () => getKeyedLinksForMatches(matches, routeModules, manifest),\n    [matches, routeModules, manifest]\n  );\n  return /* @__PURE__ */ React9.createElement(React9.Fragment, null, criticalCss ? /* @__PURE__ */ React9.createElement(\"style\", { dangerouslySetInnerHTML: { __html: criticalCss } }) : null, keyedLinks.map(\n    ({ key, link }) => isPageLinkDescriptor(link) ? /* @__PURE__ */ React9.createElement(PrefetchPageLinks, { key, ...link }) : /* @__PURE__ */ React9.createElement(\"link\", { key, ...link })\n  ));\n}\nfunction PrefetchPageLinks({\n  page,\n  ...dataLinkProps\n}) {\n  let { router } = useDataRouterContext2();\n  let matches = React9.useMemo(\n    () => matchRoutes(router.routes, page, router.basename),\n    [router.routes, page, router.basename]\n  );\n  if (!matches) {\n    return null;\n  }\n  return /* @__PURE__ */ React9.createElement(PrefetchPageLinksImpl, { page, matches, ...dataLinkProps });\n}\nfunction useKeyedPrefetchLinks(matches) {\n  let { manifest, routeModules } = useFrameworkContext();\n  let [keyedPrefetchLinks, setKeyedPrefetchLinks] = React9.useState([]);\n  React9.useEffect(() => {\n    let interrupted = false;\n    void getKeyedPrefetchLinks(matches, manifest, routeModules).then(\n      (links) => {\n        if (!interrupted) {\n          setKeyedPrefetchLinks(links);\n        }\n      }\n    );\n    return () => {\n      interrupted = true;\n    };\n  }, [matches, manifest, routeModules]);\n  return keyedPrefetchLinks;\n}\nfunction PrefetchPageLinksImpl({\n  page,\n  matches: nextMatches,\n  ...linkProps\n}) {\n  let location = useLocation();\n  let { manifest, routeModules } = useFrameworkContext();\n  let { loaderData, matches } = useDataRouterStateContext();\n  let newMatchesForData = React9.useMemo(\n    () => getNewMatchesForLinks(\n      page,\n      nextMatches,\n      matches,\n      manifest,\n      location,\n      \"data\"\n    ),\n    [page, nextMatches, matches, manifest, location]\n  );\n  let newMatchesForAssets = React9.useMemo(\n    () => getNewMatchesForLinks(\n      page,\n      nextMatches,\n      matches,\n      manifest,\n      location,\n      \"assets\"\n    ),\n    [page, nextMatches, matches, manifest, location]\n  );\n  let dataHrefs = React9.useMemo(() => {\n    if (page === location.pathname + location.search + location.hash) {\n      return [];\n    }\n    let routesParams = /* @__PURE__ */ new Set();\n    let foundOptOutRoute = false;\n    nextMatches.forEach((m) => {\n      let manifestRoute = manifest.routes[m.route.id];\n      if (!manifestRoute || !manifestRoute.hasLoader) {\n        return;\n      }\n      if (!newMatchesForData.some((m2) => m2.route.id === m.route.id) && m.route.id in loaderData && routeModules[m.route.id]?.shouldRevalidate) {\n        foundOptOutRoute = true;\n      } else if (manifestRoute.hasClientLoader) {\n        foundOptOutRoute = true;\n      } else {\n        routesParams.add(m.route.id);\n      }\n    });\n    if (routesParams.size === 0) {\n      return [];\n    }\n    let url = singleFetchUrl(page);\n    if (foundOptOutRoute && routesParams.size > 0) {\n      url.searchParams.set(\n        \"_routes\",\n        nextMatches.filter((m) => routesParams.has(m.route.id)).map((m) => m.route.id).join(\",\")\n      );\n    }\n    return [url.pathname + url.search];\n  }, [\n    loaderData,\n    location,\n    manifest,\n    newMatchesForData,\n    nextMatches,\n    page,\n    routeModules\n  ]);\n  let moduleHrefs = React9.useMemo(\n    () => getModuleLinkHrefs(newMatchesForAssets, manifest),\n    [newMatchesForAssets, manifest]\n  );\n  let keyedPrefetchLinks = useKeyedPrefetchLinks(newMatchesForAssets);\n  return /* @__PURE__ */ React9.createElement(React9.Fragment, null, dataHrefs.map((href) => /* @__PURE__ */ React9.createElement(\"link\", { key: href, rel: \"prefetch\", as: \"fetch\", href, ...linkProps })), moduleHrefs.map((href) => /* @__PURE__ */ React9.createElement(\"link\", { key: href, rel: \"modulepreload\", href, ...linkProps })), keyedPrefetchLinks.map(({ key, link }) => (\n    // these don't spread `linkProps` because they are full link descriptors\n    // already with their own props\n    /* @__PURE__ */ React9.createElement(\"link\", { key, ...link })\n  )));\n}\nfunction Meta() {\n  let { isSpaMode, routeModules } = useFrameworkContext();\n  let {\n    errors,\n    matches: routerMatches,\n    loaderData\n  } = useDataRouterStateContext();\n  let location = useLocation();\n  let _matches = getActiveMatches(routerMatches, errors, isSpaMode);\n  let error = null;\n  if (errors) {\n    error = errors[_matches[_matches.length - 1].route.id];\n  }\n  let meta = [];\n  let leafMeta = null;\n  let matches = [];\n  for (let i = 0; i < _matches.length; i++) {\n    let _match = _matches[i];\n    let routeId = _match.route.id;\n    let data2 = loaderData[routeId];\n    let params = _match.params;\n    let routeModule = routeModules[routeId];\n    let routeMeta = [];\n    let match = {\n      id: routeId,\n      data: data2,\n      meta: [],\n      params: _match.params,\n      pathname: _match.pathname,\n      handle: _match.route.handle,\n      error\n    };\n    matches[i] = match;\n    if (routeModule?.meta) {\n      routeMeta = typeof routeModule.meta === \"function\" ? routeModule.meta({\n        data: data2,\n        params,\n        location,\n        matches,\n        error\n      }) : Array.isArray(routeModule.meta) ? [...routeModule.meta] : routeModule.meta;\n    } else if (leafMeta) {\n      routeMeta = [...leafMeta];\n    }\n    routeMeta = routeMeta || [];\n    if (!Array.isArray(routeMeta)) {\n      throw new Error(\n        \"The route at \" + _match.route.path + \" returns an invalid value. All route meta functions must return an array of meta objects.\\n\\nTo reference the meta function API, see https://remix.run/route/meta\"\n      );\n    }\n    match.meta = routeMeta;\n    matches[i] = match;\n    meta = [...routeMeta];\n    leafMeta = meta;\n  }\n  return /* @__PURE__ */ React9.createElement(React9.Fragment, null, meta.flat().map((metaProps) => {\n    if (!metaProps) {\n      return null;\n    }\n    if (\"tagName\" in metaProps) {\n      let { tagName, ...rest } = metaProps;\n      if (!isValidMetaTag(tagName)) {\n        console.warn(\n          `A meta object uses an invalid tagName: ${tagName}. Expected either 'link' or 'meta'`\n        );\n        return null;\n      }\n      let Comp = tagName;\n      return /* @__PURE__ */ React9.createElement(Comp, { key: JSON.stringify(rest), ...rest });\n    }\n    if (\"title\" in metaProps) {\n      return /* @__PURE__ */ React9.createElement(\"title\", { key: \"title\" }, String(metaProps.title));\n    }\n    if (\"charset\" in metaProps) {\n      metaProps.charSet ?? (metaProps.charSet = metaProps.charset);\n      delete metaProps.charset;\n    }\n    if (\"charSet\" in metaProps && metaProps.charSet != null) {\n      return typeof metaProps.charSet === \"string\" ? /* @__PURE__ */ React9.createElement(\"meta\", { key: \"charSet\", charSet: metaProps.charSet }) : null;\n    }\n    if (\"script:ld+json\" in metaProps) {\n      try {\n        let json = JSON.stringify(metaProps[\"script:ld+json\"]);\n        return /* @__PURE__ */ React9.createElement(\n          \"script\",\n          {\n            key: `script:ld+json:${json}`,\n            type: \"application/ld+json\",\n            dangerouslySetInnerHTML: { __html: json }\n          }\n        );\n      } catch (err) {\n        return null;\n      }\n    }\n    return /* @__PURE__ */ React9.createElement(\"meta\", { key: JSON.stringify(metaProps), ...metaProps });\n  }));\n}\nfunction isValidMetaTag(tagName) {\n  return typeof tagName === \"string\" && /^(meta|link)$/.test(tagName);\n}\nvar isHydrated = false;\nfunction Scripts(props) {\n  let { manifest, serverHandoffString, isSpaMode, renderMeta } = useFrameworkContext();\n  let { router, static: isStatic, staticContext } = useDataRouterContext2();\n  let { matches: routerMatches } = useDataRouterStateContext();\n  let enableFogOfWar = isFogOfWarEnabled(isSpaMode);\n  if (renderMeta) {\n    renderMeta.didRenderScripts = true;\n  }\n  let matches = getActiveMatches(routerMatches, null, isSpaMode);\n  React9.useEffect(() => {\n    isHydrated = true;\n  }, []);\n  let initialScripts = React9.useMemo(() => {\n    let streamScript = \"window.__reactRouterContext.stream = new ReadableStream({start(controller){window.__reactRouterContext.streamController = controller;}}).pipeThrough(new TextEncoderStream());\";\n    let contextScript = staticContext ? `window.__reactRouterContext = ${serverHandoffString};${streamScript}` : \" \";\n    let routeModulesScript = !isStatic ? \" \" : `${manifest.hmr?.runtime ? `import ${JSON.stringify(manifest.hmr.runtime)};` : \"\"}${!enableFogOfWar ? `import ${JSON.stringify(manifest.url)}` : \"\"};\n${matches.map(\n      (match, index) => `import * as route${index} from ${JSON.stringify(\n        manifest.routes[match.route.id].module\n      )};`\n    ).join(\"\\n\")}\n  ${enableFogOfWar ? (\n      // Inline a minimal manifest with the SSR matches\n      `window.__reactRouterManifest = ${JSON.stringify(\n        getPartialManifest(manifest, router),\n        null,\n        2\n      )};`\n    ) : \"\"}\n  window.__reactRouterRouteModules = {${matches.map((match, index) => `${JSON.stringify(match.route.id)}:route${index}`).join(\",\")}};\n\nimport(${JSON.stringify(manifest.entry.module)});`;\n    return /* @__PURE__ */ React9.createElement(React9.Fragment, null, /* @__PURE__ */ React9.createElement(\n      \"script\",\n      {\n        ...props,\n        suppressHydrationWarning: true,\n        dangerouslySetInnerHTML: createHtml(contextScript),\n        type: void 0\n      }\n    ), /* @__PURE__ */ React9.createElement(\n      \"script\",\n      {\n        ...props,\n        suppressHydrationWarning: true,\n        dangerouslySetInnerHTML: createHtml(routeModulesScript),\n        type: \"module\",\n        async: true\n      }\n    ));\n  }, []);\n  let routePreloads = matches.map((match) => {\n    let route = manifest.routes[match.route.id];\n    return route ? (route.imports || []).concat([route.module]) : [];\n  }).flat(1);\n  let preloads = isHydrated ? [] : manifest.entry.imports.concat(routePreloads);\n  return isHydrated ? null : /* @__PURE__ */ React9.createElement(React9.Fragment, null, !enableFogOfWar ? /* @__PURE__ */ React9.createElement(\n    \"link\",\n    {\n      rel: \"modulepreload\",\n      href: manifest.url,\n      crossOrigin: props.crossOrigin\n    }\n  ) : null, /* @__PURE__ */ React9.createElement(\n    \"link\",\n    {\n      rel: \"modulepreload\",\n      href: manifest.entry.module,\n      crossOrigin: props.crossOrigin\n    }\n  ), dedupe(preloads).map((path) => /* @__PURE__ */ React9.createElement(\n    \"link\",\n    {\n      key: path,\n      rel: \"modulepreload\",\n      href: path,\n      crossOrigin: props.crossOrigin\n    }\n  )), initialScripts);\n}\nfunction dedupe(array) {\n  return [...new Set(array)];\n}\nfunction mergeRefs(...refs) {\n  return (value) => {\n    refs.forEach((ref) => {\n      if (typeof ref === \"function\") {\n        ref(value);\n      } else if (ref != null) {\n        ref.current = value;\n      }\n    });\n  };\n}\n\n// lib/dom/lib.tsx\nvar isBrowser = typeof window !== \"undefined\" && typeof window.document !== \"undefined\" && typeof window.document.createElement !== \"undefined\";\ntry {\n  if (isBrowser) {\n    window.__reactRouterVersion = \"7.1.0\";\n  }\n} catch (e) {\n}\nfunction createBrowserRouter(routes, opts) {\n  return createRouter({\n    basename: opts?.basename,\n    future: opts?.future,\n    history: createBrowserHistory({ window: opts?.window }),\n    hydrationData: opts?.hydrationData || parseHydrationData(),\n    routes,\n    mapRouteProperties,\n    dataStrategy: opts?.dataStrategy,\n    patchRoutesOnNavigation: opts?.patchRoutesOnNavigation,\n    window: opts?.window\n  }).initialize();\n}\nfunction createHashRouter(routes, opts) {\n  return createRouter({\n    basename: opts?.basename,\n    future: opts?.future,\n    history: createHashHistory({ window: opts?.window }),\n    hydrationData: opts?.hydrationData || parseHydrationData(),\n    routes,\n    mapRouteProperties,\n    dataStrategy: opts?.dataStrategy,\n    patchRoutesOnNavigation: opts?.patchRoutesOnNavigation,\n    window: opts?.window\n  }).initialize();\n}\nfunction parseHydrationData() {\n  let state = window?.__staticRouterHydrationData;\n  if (state && state.errors) {\n    state = {\n      ...state,\n      errors: deserializeErrors(state.errors)\n    };\n  }\n  return state;\n}\nfunction deserializeErrors(errors) {\n  if (!errors) return null;\n  let entries = Object.entries(errors);\n  let serialized = {};\n  for (let [key, val] of entries) {\n    if (val && val.__type === \"RouteErrorResponse\") {\n      serialized[key] = new ErrorResponseImpl(\n        val.status,\n        val.statusText,\n        val.data,\n        val.internal === true\n      );\n    } else if (val && val.__type === \"Error\") {\n      if (val.__subType) {\n        let ErrorConstructor = window[val.__subType];\n        if (typeof ErrorConstructor === \"function\") {\n          try {\n            let error = new ErrorConstructor(val.message);\n            error.stack = \"\";\n            serialized[key] = error;\n          } catch (e) {\n          }\n        }\n      }\n      if (serialized[key] == null) {\n        let error = new Error(val.message);\n        error.stack = \"\";\n        serialized[key] = error;\n      }\n    } else {\n      serialized[key] = val;\n    }\n  }\n  return serialized;\n}\nfunction BrowserRouter({\n  basename,\n  children,\n  window: window2\n}) {\n  let historyRef = React10.useRef();\n  if (historyRef.current == null) {\n    historyRef.current = createBrowserHistory({ window: window2, v5Compat: true });\n  }\n  let history = historyRef.current;\n  let [state, setStateImpl] = React10.useState({\n    action: history.action,\n    location: history.location\n  });\n  let setState = React10.useCallback(\n    (newState) => {\n      React10.startTransition(() => setStateImpl(newState));\n    },\n    [setStateImpl]\n  );\n  React10.useLayoutEffect(() => history.listen(setState), [history, setState]);\n  return /* @__PURE__ */ React10.createElement(\n    Router,\n    {\n      basename,\n      children,\n      location: state.location,\n      navigationType: state.action,\n      navigator: history\n    }\n  );\n}\nfunction HashRouter({ basename, children, window: window2 }) {\n  let historyRef = React10.useRef();\n  if (historyRef.current == null) {\n    historyRef.current = createHashHistory({ window: window2, v5Compat: true });\n  }\n  let history = historyRef.current;\n  let [state, setStateImpl] = React10.useState({\n    action: history.action,\n    location: history.location\n  });\n  let setState = React10.useCallback(\n    (newState) => {\n      React10.startTransition(() => setStateImpl(newState));\n    },\n    [setStateImpl]\n  );\n  React10.useLayoutEffect(() => history.listen(setState), [history, setState]);\n  return /* @__PURE__ */ React10.createElement(\n    Router,\n    {\n      basename,\n      children,\n      location: state.location,\n      navigationType: state.action,\n      navigator: history\n    }\n  );\n}\nfunction HistoryRouter({\n  basename,\n  children,\n  history\n}) {\n  let [state, setStateImpl] = React10.useState({\n    action: history.action,\n    location: history.location\n  });\n  let setState = React10.useCallback(\n    (newState) => {\n      React10.startTransition(() => setStateImpl(newState));\n    },\n    [setStateImpl]\n  );\n  React10.useLayoutEffect(() => history.listen(setState), [history, setState]);\n  return /* @__PURE__ */ React10.createElement(\n    Router,\n    {\n      basename,\n      children,\n      location: state.location,\n      navigationType: state.action,\n      navigator: history\n    }\n  );\n}\nHistoryRouter.displayName = \"unstable_HistoryRouter\";\nvar ABSOLUTE_URL_REGEX2 = /^(?:[a-z][a-z0-9+.-]*:|\\/\\/)/i;\nvar Link = React10.forwardRef(\n  function LinkWithRef({\n    onClick,\n    discover = \"render\",\n    prefetch = \"none\",\n    relative,\n    reloadDocument,\n    replace: replace2,\n    state,\n    target,\n    to,\n    preventScrollReset,\n    viewTransition,\n    ...rest\n  }, forwardedRef) {\n    let { basename } = React10.useContext(NavigationContext);\n    let isAbsolute = typeof to === \"string\" && ABSOLUTE_URL_REGEX2.test(to);\n    let absoluteHref;\n    let isExternal = false;\n    if (typeof to === \"string\" && isAbsolute) {\n      absoluteHref = to;\n      if (isBrowser) {\n        try {\n          let currentUrl = new URL(window.location.href);\n          let targetUrl = to.startsWith(\"//\") ? new URL(currentUrl.protocol + to) : new URL(to);\n          let path = stripBasename(targetUrl.pathname, basename);\n          if (targetUrl.origin === currentUrl.origin && path != null) {\n            to = path + targetUrl.search + targetUrl.hash;\n          } else {\n            isExternal = true;\n          }\n        } catch (e) {\n          warning(\n            false,\n            `<Link to=\"${to}\"> contains an invalid URL which will probably break when clicked - please update to a valid URL path.`\n          );\n        }\n      }\n    }\n    let href = useHref(to, { relative });\n    let [shouldPrefetch, prefetchRef, prefetchHandlers] = usePrefetchBehavior(\n      prefetch,\n      rest\n    );\n    let internalOnClick = useLinkClickHandler(to, {\n      replace: replace2,\n      state,\n      target,\n      preventScrollReset,\n      relative,\n      viewTransition\n    });\n    function handleClick(event) {\n      if (onClick) onClick(event);\n      if (!event.defaultPrevented) {\n        internalOnClick(event);\n      }\n    }\n    let link = (\n      // eslint-disable-next-line jsx-a11y/anchor-has-content\n      /* @__PURE__ */ React10.createElement(\n        \"a\",\n        {\n          ...rest,\n          ...prefetchHandlers,\n          href: absoluteHref || href,\n          onClick: isExternal || reloadDocument ? onClick : handleClick,\n          ref: mergeRefs(forwardedRef, prefetchRef),\n          target,\n          \"data-discover\": !isAbsolute && discover === \"render\" ? \"true\" : void 0\n        }\n      )\n    );\n    return shouldPrefetch && !isAbsolute ? /* @__PURE__ */ React10.createElement(React10.Fragment, null, link, /* @__PURE__ */ React10.createElement(PrefetchPageLinks, { page: href })) : link;\n  }\n);\nLink.displayName = \"Link\";\nvar NavLink = React10.forwardRef(\n  function NavLinkWithRef({\n    \"aria-current\": ariaCurrentProp = \"page\",\n    caseSensitive = false,\n    className: classNameProp = \"\",\n    end = false,\n    style: styleProp,\n    to,\n    viewTransition,\n    children,\n    ...rest\n  }, ref) {\n    let path = useResolvedPath(to, { relative: rest.relative });\n    let location = useLocation();\n    let routerState = React10.useContext(DataRouterStateContext);\n    let { navigator: navigator2, basename } = React10.useContext(NavigationContext);\n    let isTransitioning = routerState != null && // Conditional usage is OK here because the usage of a data router is static\n    // eslint-disable-next-line react-hooks/rules-of-hooks\n    useViewTransitionState(path) && viewTransition === true;\n    let toPathname = navigator2.encodeLocation ? navigator2.encodeLocation(path).pathname : path.pathname;\n    let locationPathname = location.pathname;\n    let nextLocationPathname = routerState && routerState.navigation && routerState.navigation.location ? routerState.navigation.location.pathname : null;\n    if (!caseSensitive) {\n      locationPathname = locationPathname.toLowerCase();\n      nextLocationPathname = nextLocationPathname ? nextLocationPathname.toLowerCase() : null;\n      toPathname = toPathname.toLowerCase();\n    }\n    if (nextLocationPathname && basename) {\n      nextLocationPathname = stripBasename(nextLocationPathname, basename) || nextLocationPathname;\n    }\n    const endSlashPosition = toPathname !== \"/\" && toPathname.endsWith(\"/\") ? toPathname.length - 1 : toPathname.length;\n    let isActive = locationPathname === toPathname || !end && locationPathname.startsWith(toPathname) && locationPathname.charAt(endSlashPosition) === \"/\";\n    let isPending = nextLocationPathname != null && (nextLocationPathname === toPathname || !end && nextLocationPathname.startsWith(toPathname) && nextLocationPathname.charAt(toPathname.length) === \"/\");\n    let renderProps = {\n      isActive,\n      isPending,\n      isTransitioning\n    };\n    let ariaCurrent = isActive ? ariaCurrentProp : void 0;\n    let className;\n    if (typeof classNameProp === \"function\") {\n      className = classNameProp(renderProps);\n    } else {\n      className = [\n        classNameProp,\n        isActive ? \"active\" : null,\n        isPending ? \"pending\" : null,\n        isTransitioning ? \"transitioning\" : null\n      ].filter(Boolean).join(\" \");\n    }\n    let style = typeof styleProp === \"function\" ? styleProp(renderProps) : styleProp;\n    return /* @__PURE__ */ React10.createElement(\n      Link,\n      {\n        ...rest,\n        \"aria-current\": ariaCurrent,\n        className,\n        ref,\n        style,\n        to,\n        viewTransition\n      },\n      typeof children === \"function\" ? children(renderProps) : children\n    );\n  }\n);\nNavLink.displayName = \"NavLink\";\nvar Form = React10.forwardRef(\n  ({\n    discover = \"render\",\n    fetcherKey,\n    navigate,\n    reloadDocument,\n    replace: replace2,\n    state,\n    method = defaultMethod,\n    action,\n    onSubmit,\n    relative,\n    preventScrollReset,\n    viewTransition,\n    ...props\n  }, forwardedRef) => {\n    let submit = useSubmit();\n    let formAction = useFormAction(action, { relative });\n    let formMethod = method.toLowerCase() === \"get\" ? \"get\" : \"post\";\n    let isAbsolute = typeof action === \"string\" && ABSOLUTE_URL_REGEX2.test(action);\n    let submitHandler = (event) => {\n      onSubmit && onSubmit(event);\n      if (event.defaultPrevented) return;\n      event.preventDefault();\n      let submitter = event.nativeEvent.submitter;\n      let submitMethod = submitter?.getAttribute(\"formmethod\") || method;\n      submit(submitter || event.currentTarget, {\n        fetcherKey,\n        method: submitMethod,\n        navigate,\n        replace: replace2,\n        state,\n        relative,\n        preventScrollReset,\n        viewTransition\n      });\n    };\n    return /* @__PURE__ */ React10.createElement(\n      \"form\",\n      {\n        ref: forwardedRef,\n        method: formMethod,\n        action: formAction,\n        onSubmit: reloadDocument ? onSubmit : submitHandler,\n        ...props,\n        \"data-discover\": !isAbsolute && discover === \"render\" ? \"true\" : void 0\n      }\n    );\n  }\n);\nForm.displayName = \"Form\";\nfunction ScrollRestoration({\n  getKey,\n  storageKey,\n  ...props\n}) {\n  let remixContext = React10.useContext(FrameworkContext);\n  let { basename } = React10.useContext(NavigationContext);\n  let location = useLocation();\n  let matches = useMatches();\n  useScrollRestoration({ getKey, storageKey });\n  let ssrKey = React10.useMemo(\n    () => {\n      if (!remixContext || !getKey) return null;\n      let userKey = getScrollRestorationKey(\n        location,\n        matches,\n        basename,\n        getKey\n      );\n      return userKey !== location.key ? userKey : null;\n    },\n    // Nah, we only need this the first time for the SSR render\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    []\n  );\n  if (!remixContext || remixContext.isSpaMode) {\n    return null;\n  }\n  let restoreScroll = ((storageKey2, restoreKey) => {\n    if (!window.history.state || !window.history.state.key) {\n      let key = Math.random().toString(32).slice(2);\n      window.history.replaceState({ key }, \"\");\n    }\n    try {\n      let positions = JSON.parse(sessionStorage.getItem(storageKey2) || \"{}\");\n      let storedY = positions[restoreKey || window.history.state.key];\n      if (typeof storedY === \"number\") {\n        window.scrollTo(0, storedY);\n      }\n    } catch (error) {\n      console.error(error);\n      sessionStorage.removeItem(storageKey2);\n    }\n  }).toString();\n  return /* @__PURE__ */ React10.createElement(\n    \"script\",\n    {\n      ...props,\n      suppressHydrationWarning: true,\n      dangerouslySetInnerHTML: {\n        __html: `(${restoreScroll})(${JSON.stringify(\n          storageKey || SCROLL_RESTORATION_STORAGE_KEY\n        )}, ${JSON.stringify(ssrKey)})`\n      }\n    }\n  );\n}\nScrollRestoration.displayName = \"ScrollRestoration\";\nfunction getDataRouterConsoleError2(hookName) {\n  return `${hookName} must be used within a data router.  See https://reactrouter.com/en/main/routers/picking-a-router.`;\n}\nfunction useDataRouterContext3(hookName) {\n  let ctx = React10.useContext(DataRouterContext);\n  invariant(ctx, getDataRouterConsoleError2(hookName));\n  return ctx;\n}\nfunction useDataRouterState2(hookName) {\n  let state = React10.useContext(DataRouterStateContext);\n  invariant(state, getDataRouterConsoleError2(hookName));\n  return state;\n}\nfunction useLinkClickHandler(to, {\n  target,\n  replace: replaceProp,\n  state,\n  preventScrollReset,\n  relative,\n  viewTransition\n} = {}) {\n  let navigate = useNavigate();\n  let location = useLocation();\n  let path = useResolvedPath(to, { relative });\n  return React10.useCallback(\n    (event) => {\n      if (shouldProcessLinkClick(event, target)) {\n        event.preventDefault();\n        let replace2 = replaceProp !== void 0 ? replaceProp : createPath(location) === createPath(path);\n        navigate(to, {\n          replace: replace2,\n          state,\n          preventScrollReset,\n          relative,\n          viewTransition\n        });\n      }\n    },\n    [\n      location,\n      navigate,\n      path,\n      replaceProp,\n      state,\n      target,\n      to,\n      preventScrollReset,\n      relative,\n      viewTransition\n    ]\n  );\n}\nfunction useSearchParams(defaultInit) {\n  warning(\n    typeof URLSearchParams !== \"undefined\",\n    `You cannot use the \\`useSearchParams\\` hook in a browser that does not support the URLSearchParams API. If you need to support Internet Explorer 11, we recommend you load a polyfill such as https://github.com/ungap/url-search-params.`\n  );\n  let defaultSearchParamsRef = React10.useRef(createSearchParams(defaultInit));\n  let hasSetSearchParamsRef = React10.useRef(false);\n  let location = useLocation();\n  let searchParams = React10.useMemo(\n    () => (\n      // Only merge in the defaults if we haven't yet called setSearchParams.\n      // Once we call that we want those to take precedence, otherwise you can't\n      // remove a param with setSearchParams({}) if it has an initial value\n      getSearchParamsForLocation(\n        location.search,\n        hasSetSearchParamsRef.current ? null : defaultSearchParamsRef.current\n      )\n    ),\n    [location.search]\n  );\n  let navigate = useNavigate();\n  let setSearchParams = React10.useCallback(\n    (nextInit, navigateOptions) => {\n      const newSearchParams = createSearchParams(\n        typeof nextInit === \"function\" ? nextInit(searchParams) : nextInit\n      );\n      hasSetSearchParamsRef.current = true;\n      navigate(\"?\" + newSearchParams, navigateOptions);\n    },\n    [navigate, searchParams]\n  );\n  return [searchParams, setSearchParams];\n}\nvar fetcherId = 0;\nvar getUniqueFetcherId = () => `__${String(++fetcherId)}__`;\nfunction useSubmit() {\n  let { router } = useDataRouterContext3(\"useSubmit\" /* UseSubmit */);\n  let { basename } = React10.useContext(NavigationContext);\n  let currentRouteId = useRouteId();\n  return React10.useCallback(\n    async (target, options = {}) => {\n      let { action, method, encType, formData, body } = getFormSubmissionInfo(\n        target,\n        basename\n      );\n      if (options.navigate === false) {\n        let key = options.fetcherKey || getUniqueFetcherId();\n        await router.fetch(key, currentRouteId, options.action || action, {\n          preventScrollReset: options.preventScrollReset,\n          formData,\n          body,\n          formMethod: options.method || method,\n          formEncType: options.encType || encType,\n          flushSync: options.flushSync\n        });\n      } else {\n        await router.navigate(options.action || action, {\n          preventScrollReset: options.preventScrollReset,\n          formData,\n          body,\n          formMethod: options.method || method,\n          formEncType: options.encType || encType,\n          replace: options.replace,\n          state: options.state,\n          fromRouteId: currentRouteId,\n          flushSync: options.flushSync,\n          viewTransition: options.viewTransition\n        });\n      }\n    },\n    [router, basename, currentRouteId]\n  );\n}\nfunction useFormAction(action, { relative } = {}) {\n  let { basename } = React10.useContext(NavigationContext);\n  let routeContext = React10.useContext(RouteContext);\n  invariant(routeContext, \"useFormAction must be used inside a RouteContext\");\n  let [match] = routeContext.matches.slice(-1);\n  let path = { ...useResolvedPath(action ? action : \".\", { relative }) };\n  let location = useLocation();\n  if (action == null) {\n    path.search = location.search;\n    let params = new URLSearchParams(path.search);\n    let indexValues = params.getAll(\"index\");\n    let hasNakedIndexParam = indexValues.some((v) => v === \"\");\n    if (hasNakedIndexParam) {\n      params.delete(\"index\");\n      indexValues.filter((v) => v).forEach((v) => params.append(\"index\", v));\n      let qs = params.toString();\n      path.search = qs ? `?${qs}` : \"\";\n    }\n  }\n  if ((!action || action === \".\") && match.route.index) {\n    path.search = path.search ? path.search.replace(/^\\?/, \"?index&\") : \"?index\";\n  }\n  if (basename !== \"/\") {\n    path.pathname = path.pathname === \"/\" ? basename : joinPaths([basename, path.pathname]);\n  }\n  return createPath(path);\n}\nfunction useFetcher({\n  key\n} = {}) {\n  let { router } = useDataRouterContext3(\"useFetcher\" /* UseFetcher */);\n  let state = useDataRouterState2(\"useFetcher\" /* UseFetcher */);\n  let fetcherData = React10.useContext(FetchersContext);\n  let route = React10.useContext(RouteContext);\n  let routeId = route.matches[route.matches.length - 1]?.route.id;\n  invariant(fetcherData, `useFetcher must be used inside a FetchersContext`);\n  invariant(route, `useFetcher must be used inside a RouteContext`);\n  invariant(\n    routeId != null,\n    `useFetcher can only be used on routes that contain a unique \"id\"`\n  );\n  let defaultKey = React10.useId();\n  let [fetcherKey, setFetcherKey] = React10.useState(key || defaultKey);\n  if (key && key !== fetcherKey) {\n    setFetcherKey(key);\n  }\n  React10.useEffect(() => {\n    router.getFetcher(fetcherKey);\n    return () => router.deleteFetcher(fetcherKey);\n  }, [router, fetcherKey]);\n  let load = React10.useCallback(\n    async (href, opts) => {\n      invariant(routeId, \"No routeId available for fetcher.load()\");\n      await router.fetch(fetcherKey, routeId, href, opts);\n    },\n    [fetcherKey, routeId, router]\n  );\n  let submitImpl = useSubmit();\n  let submit = React10.useCallback(\n    async (target, opts) => {\n      await submitImpl(target, {\n        ...opts,\n        navigate: false,\n        fetcherKey\n      });\n    },\n    [fetcherKey, submitImpl]\n  );\n  let FetcherForm = React10.useMemo(() => {\n    let FetcherForm2 = React10.forwardRef(\n      (props, ref) => {\n        return /* @__PURE__ */ React10.createElement(Form, { ...props, navigate: false, fetcherKey, ref });\n      }\n    );\n    FetcherForm2.displayName = \"fetcher.Form\";\n    return FetcherForm2;\n  }, [fetcherKey]);\n  let fetcher = state.fetchers.get(fetcherKey) || IDLE_FETCHER;\n  let data2 = fetcherData.get(fetcherKey);\n  let fetcherWithComponents = React10.useMemo(\n    () => ({\n      Form: FetcherForm,\n      submit,\n      load,\n      ...fetcher,\n      data: data2\n    }),\n    [FetcherForm, submit, load, fetcher, data2]\n  );\n  return fetcherWithComponents;\n}\nfunction useFetchers() {\n  let state = useDataRouterState2(\"useFetchers\" /* UseFetchers */);\n  return Array.from(state.fetchers.entries()).map(([key, fetcher]) => ({\n    ...fetcher,\n    key\n  }));\n}\nvar SCROLL_RESTORATION_STORAGE_KEY = \"react-router-scroll-positions\";\nvar savedScrollPositions = {};\nfunction getScrollRestorationKey(location, matches, basename, getKey) {\n  let key = null;\n  if (getKey) {\n    if (basename !== \"/\") {\n      key = getKey(\n        {\n          ...location,\n          pathname: stripBasename(location.pathname, basename) || location.pathname\n        },\n        matches\n      );\n    } else {\n      key = getKey(location, matches);\n    }\n  }\n  if (key == null) {\n    key = location.key;\n  }\n  return key;\n}\nfunction useScrollRestoration({\n  getKey,\n  storageKey\n} = {}) {\n  let { router } = useDataRouterContext3(\"useScrollRestoration\" /* UseScrollRestoration */);\n  let { restoreScrollPosition, preventScrollReset } = useDataRouterState2(\n    \"useScrollRestoration\" /* UseScrollRestoration */\n  );\n  let { basename } = React10.useContext(NavigationContext);\n  let location = useLocation();\n  let matches = useMatches();\n  let navigation = useNavigation();\n  React10.useEffect(() => {\n    window.history.scrollRestoration = \"manual\";\n    return () => {\n      window.history.scrollRestoration = \"auto\";\n    };\n  }, []);\n  usePageHide(\n    React10.useCallback(() => {\n      if (navigation.state === \"idle\") {\n        let key = getScrollRestorationKey(location, matches, basename, getKey);\n        savedScrollPositions[key] = window.scrollY;\n      }\n      try {\n        sessionStorage.setItem(\n          storageKey || SCROLL_RESTORATION_STORAGE_KEY,\n          JSON.stringify(savedScrollPositions)\n        );\n      } catch (error) {\n        warning(\n          false,\n          `Failed to save scroll positions in sessionStorage, <ScrollRestoration /> will not work properly (${error}).`\n        );\n      }\n      window.history.scrollRestoration = \"auto\";\n    }, [navigation.state, getKey, basename, location, matches, storageKey])\n  );\n  if (typeof document !== \"undefined\") {\n    React10.useLayoutEffect(() => {\n      try {\n        let sessionPositions = sessionStorage.getItem(\n          storageKey || SCROLL_RESTORATION_STORAGE_KEY\n        );\n        if (sessionPositions) {\n          savedScrollPositions = JSON.parse(sessionPositions);\n        }\n      } catch (e) {\n      }\n    }, [storageKey]);\n    React10.useLayoutEffect(() => {\n      let disableScrollRestoration = router?.enableScrollRestoration(\n        savedScrollPositions,\n        () => window.scrollY,\n        getKey ? (location2, matches2) => getScrollRestorationKey(location2, matches2, basename, getKey) : void 0\n      );\n      return () => disableScrollRestoration && disableScrollRestoration();\n    }, [router, basename, getKey]);\n    React10.useLayoutEffect(() => {\n      if (restoreScrollPosition === false) {\n        return;\n      }\n      if (typeof restoreScrollPosition === \"number\") {\n        window.scrollTo(0, restoreScrollPosition);\n        return;\n      }\n      if (location.hash) {\n        let el = document.getElementById(\n          decodeURIComponent(location.hash.slice(1))\n        );\n        if (el) {\n          el.scrollIntoView();\n          return;\n        }\n      }\n      if (preventScrollReset === true) {\n        return;\n      }\n      window.scrollTo(0, 0);\n    }, [location, restoreScrollPosition, preventScrollReset]);\n  }\n}\nfunction useBeforeUnload(callback, options) {\n  let { capture } = options || {};\n  React10.useEffect(() => {\n    let opts = capture != null ? { capture } : void 0;\n    window.addEventListener(\"beforeunload\", callback, opts);\n    return () => {\n      window.removeEventListener(\"beforeunload\", callback, opts);\n    };\n  }, [callback, capture]);\n}\nfunction usePageHide(callback, options) {\n  let { capture } = options || {};\n  React10.useEffect(() => {\n    let opts = capture != null ? { capture } : void 0;\n    window.addEventListener(\"pagehide\", callback, opts);\n    return () => {\n      window.removeEventListener(\"pagehide\", callback, opts);\n    };\n  }, [callback, capture]);\n}\nfunction usePrompt({\n  when,\n  message\n}) {\n  let blocker = useBlocker(when);\n  React10.useEffect(() => {\n    if (blocker.state === \"blocked\") {\n      let proceed = window.confirm(message);\n      if (proceed) {\n        setTimeout(blocker.proceed, 0);\n      } else {\n        blocker.reset();\n      }\n    }\n  }, [blocker, message]);\n  React10.useEffect(() => {\n    if (blocker.state === \"blocked\" && !when) {\n      blocker.reset();\n    }\n  }, [blocker, when]);\n}\nfunction useViewTransitionState(to, opts = {}) {\n  let vtContext = React10.useContext(ViewTransitionContext);\n  invariant(\n    vtContext != null,\n    \"`useViewTransitionState` must be used within `react-router-dom`'s `RouterProvider`.  Did you accidentally import `RouterProvider` from `react-router`?\"\n  );\n  let { basename } = useDataRouterContext3(\n    \"useViewTransitionState\" /* useViewTransitionState */\n  );\n  let path = useResolvedPath(to, { relative: opts.relative });\n  if (!vtContext.isTransitioning) {\n    return false;\n  }\n  let currentPath = stripBasename(vtContext.currentLocation.pathname, basename) || vtContext.currentLocation.pathname;\n  let nextPath = stripBasename(vtContext.nextLocation.pathname, basename) || vtContext.nextLocation.pathname;\n  return matchPath(path.pathname, nextPath) != null || matchPath(path.pathname, currentPath) != null;\n}\n\n// lib/dom/server.tsx\nvar React11 = __toESM(__webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react.js\"));\nfunction StaticRouter({\n  basename,\n  children,\n  location: locationProp = \"/\"\n}) {\n  if (typeof locationProp === \"string\") {\n    locationProp = parsePath(locationProp);\n  }\n  let action = \"POP\" /* Pop */;\n  let location = {\n    pathname: locationProp.pathname || \"/\",\n    search: locationProp.search || \"\",\n    hash: locationProp.hash || \"\",\n    state: locationProp.state != null ? locationProp.state : null,\n    key: locationProp.key || \"default\"\n  };\n  let staticNavigator = getStatelessNavigator();\n  return /* @__PURE__ */ React11.createElement(\n    Router,\n    {\n      basename,\n      children,\n      location,\n      navigationType: action,\n      navigator: staticNavigator,\n      static: true\n    }\n  );\n}\nfunction StaticRouterProvider({\n  context,\n  router,\n  hydrate = true,\n  nonce\n}) {\n  invariant(\n    router && context,\n    \"You must provide `router` and `context` to <StaticRouterProvider>\"\n  );\n  let dataRouterContext = {\n    router,\n    navigator: getStatelessNavigator(),\n    static: true,\n    staticContext: context,\n    basename: context.basename || \"/\"\n  };\n  let fetchersContext = /* @__PURE__ */ new Map();\n  let hydrateScript = \"\";\n  if (hydrate !== false) {\n    let data2 = {\n      loaderData: context.loaderData,\n      actionData: context.actionData,\n      errors: serializeErrors(context.errors)\n    };\n    let json = htmlEscape(JSON.stringify(JSON.stringify(data2)));\n    hydrateScript = `window.__staticRouterHydrationData = JSON.parse(${json});`;\n  }\n  let { state } = dataRouterContext.router;\n  return /* @__PURE__ */ React11.createElement(React11.Fragment, null, /* @__PURE__ */ React11.createElement(DataRouterContext.Provider, { value: dataRouterContext }, /* @__PURE__ */ React11.createElement(DataRouterStateContext.Provider, { value: state }, /* @__PURE__ */ React11.createElement(FetchersContext.Provider, { value: fetchersContext }, /* @__PURE__ */ React11.createElement(ViewTransitionContext.Provider, { value: { isTransitioning: false } }, /* @__PURE__ */ React11.createElement(\n    Router,\n    {\n      basename: dataRouterContext.basename,\n      location: state.location,\n      navigationType: state.historyAction,\n      navigator: dataRouterContext.navigator,\n      static: dataRouterContext.static\n    },\n    /* @__PURE__ */ React11.createElement(\n      DataRoutes2,\n      {\n        routes: router.routes,\n        future: router.future,\n        state\n      }\n    )\n  ))))), hydrateScript ? /* @__PURE__ */ React11.createElement(\n    \"script\",\n    {\n      suppressHydrationWarning: true,\n      nonce,\n      dangerouslySetInnerHTML: { __html: hydrateScript }\n    }\n  ) : null);\n}\nfunction DataRoutes2({\n  routes,\n  future,\n  state\n}) {\n  return useRoutesImpl(routes, void 0, state, future);\n}\nfunction serializeErrors(errors) {\n  if (!errors) return null;\n  let entries = Object.entries(errors);\n  let serialized = {};\n  for (let [key, val] of entries) {\n    if (isRouteErrorResponse(val)) {\n      serialized[key] = { ...val, __type: \"RouteErrorResponse\" };\n    } else if (val instanceof Error) {\n      serialized[key] = {\n        message: val.message,\n        __type: \"Error\",\n        // If this is a subclass (i.e., ReferenceError), send up the type so we\n        // can re-create the same type during hydration.\n        ...val.name !== \"Error\" ? {\n          __subType: val.name\n        } : {}\n      };\n    } else {\n      serialized[key] = val;\n    }\n  }\n  return serialized;\n}\nfunction getStatelessNavigator() {\n  return {\n    createHref,\n    encodeLocation,\n    push(to) {\n      throw new Error(\n        `You cannot use navigator.push() on the server because it is a stateless environment. This error was probably triggered when you did a \\`navigate(${JSON.stringify(to)})\\` somewhere in your app.`\n      );\n    },\n    replace(to) {\n      throw new Error(\n        `You cannot use navigator.replace() on the server because it is a stateless environment. This error was probably triggered when you did a \\`navigate(${JSON.stringify(to)}, { replace: true })\\` somewhere in your app.`\n      );\n    },\n    go(delta) {\n      throw new Error(\n        `You cannot use navigator.go() on the server because it is a stateless environment. This error was probably triggered when you did a \\`navigate(${delta})\\` somewhere in your app.`\n      );\n    },\n    back() {\n      throw new Error(\n        `You cannot use navigator.back() on the server because it is a stateless environment.`\n      );\n    },\n    forward() {\n      throw new Error(\n        `You cannot use navigator.forward() on the server because it is a stateless environment.`\n      );\n    }\n  };\n}\nfunction createStaticHandler2(routes, opts) {\n  return createStaticHandler(routes, {\n    ...opts,\n    mapRouteProperties\n  });\n}\nfunction createStaticRouter(routes, context, opts = {}) {\n  let manifest = {};\n  let dataRoutes = convertRoutesToDataRoutes(\n    routes,\n    mapRouteProperties,\n    void 0,\n    manifest\n  );\n  let matches = context.matches.map((match) => {\n    let route = manifest[match.route.id] || match.route;\n    return {\n      ...match,\n      route\n    };\n  });\n  let msg = (method) => `You cannot use router.${method}() on the server because it is a stateless environment`;\n  return {\n    get basename() {\n      return context.basename;\n    },\n    get future() {\n      return {\n        ...opts?.future\n      };\n    },\n    get state() {\n      return {\n        historyAction: \"POP\" /* Pop */,\n        location: context.location,\n        matches,\n        loaderData: context.loaderData,\n        actionData: context.actionData,\n        errors: context.errors,\n        initialized: true,\n        navigation: IDLE_NAVIGATION,\n        restoreScrollPosition: null,\n        preventScrollReset: false,\n        revalidation: \"idle\",\n        fetchers: /* @__PURE__ */ new Map(),\n        blockers: /* @__PURE__ */ new Map()\n      };\n    },\n    get routes() {\n      return dataRoutes;\n    },\n    get window() {\n      return void 0;\n    },\n    initialize() {\n      throw msg(\"initialize\");\n    },\n    subscribe() {\n      throw msg(\"subscribe\");\n    },\n    enableScrollRestoration() {\n      throw msg(\"enableScrollRestoration\");\n    },\n    navigate() {\n      throw msg(\"navigate\");\n    },\n    fetch() {\n      throw msg(\"fetch\");\n    },\n    revalidate() {\n      throw msg(\"revalidate\");\n    },\n    createHref,\n    encodeLocation,\n    getFetcher() {\n      return IDLE_FETCHER;\n    },\n    deleteFetcher() {\n      throw msg(\"deleteFetcher\");\n    },\n    dispose() {\n      throw msg(\"dispose\");\n    },\n    getBlocker() {\n      return IDLE_BLOCKER;\n    },\n    deleteBlocker() {\n      throw msg(\"deleteBlocker\");\n    },\n    patchRoutes() {\n      throw msg(\"patchRoutes\");\n    },\n    _internalFetchControllers: /* @__PURE__ */ new Map(),\n    _internalSetRoutes() {\n      throw msg(\"_internalSetRoutes\");\n    }\n  };\n}\nfunction createHref(to) {\n  return typeof to === \"string\" ? to : createPath(to);\n}\nfunction encodeLocation(to) {\n  let href = typeof to === \"string\" ? to : createPath(to);\n  href = href.replace(/ $/, \"%20\");\n  let encoded = ABSOLUTE_URL_REGEX3.test(href) ? new URL(href) : new URL(href, \"http://localhost\");\n  return {\n    pathname: encoded.pathname,\n    search: encoded.search,\n    hash: encoded.hash\n  };\n}\nvar ABSOLUTE_URL_REGEX3 = /^(?:[a-z][a-z0-9+.-]*:|\\/\\/)/i;\nvar ESCAPE_LOOKUP2 = {\n  \"&\": \"\\\\u0026\",\n  \">\": \"\\\\u003e\",\n  \"<\": \"\\\\u003c\",\n  \"\\u2028\": \"\\\\u2028\",\n  \"\\u2029\": \"\\\\u2029\"\n};\nvar ESCAPE_REGEX2 = /[&><\\u2028\\u2029]/g;\nfunction htmlEscape(str) {\n  return str.replace(ESCAPE_REGEX2, (match) => ESCAPE_LOOKUP2[match]);\n}\n\n// lib/dom/ssr/server.tsx\nvar React12 = __toESM(__webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react.js\"));\nfunction ServerRouter({\n  context,\n  url,\n  nonce\n}) {\n  if (typeof url === \"string\") {\n    url = new URL(url);\n  }\n  let { manifest, routeModules, criticalCss, serverHandoffString } = context;\n  let routes = createServerRoutes(\n    manifest.routes,\n    routeModules,\n    context.future,\n    context.isSpaMode\n  );\n  context.staticHandlerContext.loaderData = {\n    ...context.staticHandlerContext.loaderData\n  };\n  for (let match of context.staticHandlerContext.matches) {\n    let routeId = match.route.id;\n    let route = routeModules[routeId];\n    let manifestRoute = context.manifest.routes[routeId];\n    if (route && manifestRoute && shouldHydrateRouteLoader(manifestRoute, route, context.isSpaMode) && (route.HydrateFallback || !manifestRoute.hasLoader)) {\n      delete context.staticHandlerContext.loaderData[routeId];\n    }\n  }\n  let router = createStaticRouter(routes, context.staticHandlerContext);\n  return /* @__PURE__ */ React12.createElement(React12.Fragment, null, /* @__PURE__ */ React12.createElement(\n    FrameworkContext.Provider,\n    {\n      value: {\n        manifest,\n        routeModules,\n        criticalCss,\n        serverHandoffString,\n        future: context.future,\n        isSpaMode: context.isSpaMode,\n        serializeError: context.serializeError,\n        renderMeta: context.renderMeta\n      }\n    },\n    /* @__PURE__ */ React12.createElement(RemixErrorBoundary, { location: router.state.location }, /* @__PURE__ */ React12.createElement(\n      StaticRouterProvider,\n      {\n        router,\n        context: context.staticHandlerContext,\n        hydrate: false\n      }\n    ))\n  ), context.serverHandoffStream ? /* @__PURE__ */ React12.createElement(React12.Suspense, null, /* @__PURE__ */ React12.createElement(\n    StreamTransfer,\n    {\n      context,\n      identifier: 0,\n      reader: context.serverHandoffStream.getReader(),\n      textDecoder: new TextDecoder(),\n      nonce\n    }\n  )) : null);\n}\n\n// lib/dom/ssr/routes-test-stub.tsx\nvar React13 = __toESM(__webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react.js\"));\nfunction createRoutesStub(routes, context = {}) {\n  return function RoutesTestStub({\n    initialEntries,\n    initialIndex,\n    hydrationData,\n    future\n  }) {\n    let routerRef = React13.useRef();\n    let remixContextRef = React13.useRef();\n    if (routerRef.current == null) {\n      remixContextRef.current = {\n        future: {},\n        manifest: {\n          routes: {},\n          entry: { imports: [], module: \"\" },\n          url: \"\",\n          version: \"\"\n        },\n        routeModules: {},\n        isSpaMode: false\n      };\n      let patched = processRoutes(\n        // @ts-expect-error loader/action context types don't match :/\n        convertRoutesToDataRoutes(routes, (r) => r),\n        context,\n        remixContextRef.current.manifest,\n        remixContextRef.current.routeModules\n      );\n      routerRef.current = createMemoryRouter(patched, {\n        initialEntries,\n        initialIndex,\n        hydrationData\n      });\n    }\n    return /* @__PURE__ */ React13.createElement(FrameworkContext.Provider, { value: remixContextRef.current }, /* @__PURE__ */ React13.createElement(RouterProvider, { router: routerRef.current }));\n  };\n}\nfunction processRoutes(routes, context, manifest, routeModules, parentId) {\n  return routes.map((route) => {\n    if (!route.id) {\n      throw new Error(\n        \"Expected a route.id in @remix-run/testing processRoutes() function\"\n      );\n    }\n    let { loader, action } = route;\n    let newRoute = {\n      id: route.id,\n      path: route.path,\n      index: route.index,\n      Component: route.Component,\n      HydrateFallback: route.HydrateFallback,\n      ErrorBoundary: route.ErrorBoundary,\n      action: action ? (args) => action({ ...args, context }) : void 0,\n      loader: loader ? (args) => loader({ ...args, context }) : void 0,\n      handle: route.handle,\n      shouldRevalidate: route.shouldRevalidate\n    };\n    let entryRoute = {\n      id: route.id,\n      path: route.path,\n      index: route.index,\n      parentId,\n      hasAction: route.action != null,\n      hasLoader: route.loader != null,\n      // When testing routes, you should just be stubbing loader/action, not\n      // trying to re-implement the full loader/clientLoader/SSR/hydration flow.\n      // That is better tested via E2E tests.\n      hasClientAction: false,\n      hasClientLoader: false,\n      hasErrorBoundary: route.ErrorBoundary != null,\n      module: \"build/stub-path-to-module.js\"\n      // any need for this?\n    };\n    manifest.routes[newRoute.id] = entryRoute;\n    routeModules[route.id] = {\n      default: route.Component || Outlet,\n      ErrorBoundary: route.ErrorBoundary || void 0,\n      handle: route.handle,\n      links: route.links,\n      meta: route.meta,\n      shouldRevalidate: route.shouldRevalidate\n    };\n    if (route.children) {\n      newRoute.children = processRoutes(\n        route.children,\n        context,\n        manifest,\n        routeModules,\n        newRoute.id\n      );\n    }\n    return newRoute;\n  });\n}\n\n// lib/server-runtime/cookies.ts\nvar import_cookie = __webpack_require__(/*! cookie */ \"(ssr)/./node_modules/cookie/dist/index.js\");\n\n// lib/server-runtime/crypto.ts\nvar encoder = new TextEncoder();\nvar sign = async (value, secret) => {\n  let data2 = encoder.encode(value);\n  let key = await createKey2(secret, [\"sign\"]);\n  let signature = await crypto.subtle.sign(\"HMAC\", key, data2);\n  let hash = btoa(String.fromCharCode(...new Uint8Array(signature))).replace(\n    /=+$/,\n    \"\"\n  );\n  return value + \".\" + hash;\n};\nvar unsign = async (cookie, secret) => {\n  let index = cookie.lastIndexOf(\".\");\n  let value = cookie.slice(0, index);\n  let hash = cookie.slice(index + 1);\n  let data2 = encoder.encode(value);\n  let key = await createKey2(secret, [\"verify\"]);\n  let signature = byteStringToUint8Array(atob(hash));\n  let valid = await crypto.subtle.verify(\"HMAC\", key, signature, data2);\n  return valid ? value : false;\n};\nvar createKey2 = async (secret, usages) => crypto.subtle.importKey(\n  \"raw\",\n  encoder.encode(secret),\n  { name: \"HMAC\", hash: \"SHA-256\" },\n  false,\n  usages\n);\nfunction byteStringToUint8Array(byteString) {\n  let array = new Uint8Array(byteString.length);\n  for (let i = 0; i < byteString.length; i++) {\n    array[i] = byteString.charCodeAt(i);\n  }\n  return array;\n}\n\n// lib/server-runtime/cookies.ts\nvar createCookie = (name, cookieOptions = {}) => {\n  let { secrets = [], ...options } = {\n    path: \"/\",\n    sameSite: \"lax\",\n    ...cookieOptions\n  };\n  warnOnceAboutExpiresCookie(name, options.expires);\n  return {\n    get name() {\n      return name;\n    },\n    get isSigned() {\n      return secrets.length > 0;\n    },\n    get expires() {\n      return typeof options.maxAge !== \"undefined\" ? new Date(Date.now() + options.maxAge * 1e3) : options.expires;\n    },\n    async parse(cookieHeader, parseOptions) {\n      if (!cookieHeader) return null;\n      let cookies = (0, import_cookie.parse)(cookieHeader, { ...options, ...parseOptions });\n      if (name in cookies) {\n        let value = cookies[name];\n        if (typeof value === \"string\" && value !== \"\") {\n          let decoded = await decodeCookieValue(value, secrets);\n          return decoded;\n        } else {\n          return \"\";\n        }\n      } else {\n        return null;\n      }\n    },\n    async serialize(value, serializeOptions) {\n      return (0, import_cookie.serialize)(\n        name,\n        value === \"\" ? \"\" : await encodeCookieValue(value, secrets),\n        {\n          ...options,\n          ...serializeOptions\n        }\n      );\n    }\n  };\n};\nvar isCookie = (object) => {\n  return object != null && typeof object.name === \"string\" && typeof object.isSigned === \"boolean\" && typeof object.parse === \"function\" && typeof object.serialize === \"function\";\n};\nasync function encodeCookieValue(value, secrets) {\n  let encoded = encodeData(value);\n  if (secrets.length > 0) {\n    encoded = await sign(encoded, secrets[0]);\n  }\n  return encoded;\n}\nasync function decodeCookieValue(value, secrets) {\n  if (secrets.length > 0) {\n    for (let secret of secrets) {\n      let unsignedValue = await unsign(value, secret);\n      if (unsignedValue !== false) {\n        return decodeData(unsignedValue);\n      }\n    }\n    return null;\n  }\n  return decodeData(value);\n}\nfunction encodeData(value) {\n  return btoa(myUnescape(encodeURIComponent(JSON.stringify(value))));\n}\nfunction decodeData(value) {\n  try {\n    return JSON.parse(decodeURIComponent(myEscape(atob(value))));\n  } catch (error) {\n    return {};\n  }\n}\nfunction myEscape(value) {\n  let str = value.toString();\n  let result = \"\";\n  let index = 0;\n  let chr, code;\n  while (index < str.length) {\n    chr = str.charAt(index++);\n    if (/[\\w*+\\-./@]/.exec(chr)) {\n      result += chr;\n    } else {\n      code = chr.charCodeAt(0);\n      if (code < 256) {\n        result += \"%\" + hex(code, 2);\n      } else {\n        result += \"%u\" + hex(code, 4).toUpperCase();\n      }\n    }\n  }\n  return result;\n}\nfunction hex(code, length) {\n  let result = code.toString(16);\n  while (result.length < length) result = \"0\" + result;\n  return result;\n}\nfunction myUnescape(value) {\n  let str = value.toString();\n  let result = \"\";\n  let index = 0;\n  let chr, part;\n  while (index < str.length) {\n    chr = str.charAt(index++);\n    if (chr === \"%\") {\n      if (str.charAt(index) === \"u\") {\n        part = str.slice(index + 1, index + 5);\n        if (/^[\\da-f]{4}$/i.exec(part)) {\n          result += String.fromCharCode(parseInt(part, 16));\n          index += 5;\n          continue;\n        }\n      } else {\n        part = str.slice(index, index + 2);\n        if (/^[\\da-f]{2}$/i.exec(part)) {\n          result += String.fromCharCode(parseInt(part, 16));\n          index += 2;\n          continue;\n        }\n      }\n    }\n    result += chr;\n  }\n  return result;\n}\nfunction warnOnceAboutExpiresCookie(name, expires) {\n  warnOnce(\n    !expires,\n    `The \"${name}\" cookie has an \"expires\" property set. This will cause the expires value to not be updated when the session is committed. Instead, you should set the expires value when serializing the cookie. You can use \\`commitSession(session, { expires })\\` if using a session storage object, or \\`cookie.serialize(\"value\", { expires })\\` if you're using the cookie directly.`\n  );\n}\n\n// lib/server-runtime/entry.ts\nfunction createEntryRouteModules(manifest) {\n  return Object.keys(manifest).reduce((memo2, routeId) => {\n    let route = manifest[routeId];\n    if (route) {\n      memo2[routeId] = route.module;\n    }\n    return memo2;\n  }, {});\n}\n\n// lib/server-runtime/mode.ts\nvar ServerMode = /* @__PURE__ */ ((ServerMode2) => {\n  ServerMode2[\"Development\"] = \"development\";\n  ServerMode2[\"Production\"] = \"production\";\n  ServerMode2[\"Test\"] = \"test\";\n  return ServerMode2;\n})(ServerMode || {});\nfunction isServerMode(value) {\n  return value === \"development\" /* Development */ || value === \"production\" /* Production */ || value === \"test\" /* Test */;\n}\n\n// lib/server-runtime/errors.ts\nfunction sanitizeError(error, serverMode) {\n  if (error instanceof Error && serverMode !== \"development\" /* Development */) {\n    let sanitized = new Error(\"Unexpected Server Error\");\n    sanitized.stack = void 0;\n    return sanitized;\n  }\n  return error;\n}\nfunction sanitizeErrors(errors, serverMode) {\n  return Object.entries(errors).reduce((acc, [routeId, error]) => {\n    return Object.assign(acc, { [routeId]: sanitizeError(error, serverMode) });\n  }, {});\n}\nfunction serializeError(error, serverMode) {\n  let sanitized = sanitizeError(error, serverMode);\n  return {\n    message: sanitized.message,\n    stack: sanitized.stack\n  };\n}\nfunction serializeErrors2(errors, serverMode) {\n  if (!errors) return null;\n  let entries = Object.entries(errors);\n  let serialized = {};\n  for (let [key, val] of entries) {\n    if (isRouteErrorResponse(val)) {\n      serialized[key] = { ...val, __type: \"RouteErrorResponse\" };\n    } else if (val instanceof Error) {\n      let sanitized = sanitizeError(val, serverMode);\n      serialized[key] = {\n        message: sanitized.message,\n        stack: sanitized.stack,\n        __type: \"Error\",\n        // If this is a subclass (i.e., ReferenceError), send up the type so we\n        // can re-create the same type during hydration.  This will only apply\n        // in dev mode since all production errors are sanitized to normal\n        // Error instances\n        ...sanitized.name !== \"Error\" ? {\n          __subType: sanitized.name\n        } : {}\n      };\n    } else {\n      serialized[key] = val;\n    }\n  }\n  return serialized;\n}\n\n// lib/server-runtime/routeMatching.ts\nfunction matchServerRoutes(routes, pathname, basename) {\n  let matches = matchRoutes(\n    routes,\n    pathname,\n    basename\n  );\n  if (!matches) return null;\n  return matches.map((match) => ({\n    params: match.params,\n    pathname: match.pathname,\n    route: match.route\n  }));\n}\n\n// lib/server-runtime/data.ts\nasync function callRouteHandler(handler, args) {\n  let result = await handler({\n    request: stripRoutesParam(stripIndexParam2(args.request)),\n    params: args.params,\n    context: args.context\n  });\n  if (isDataWithResponseInit(result) && result.init && result.init.status && isRedirectStatusCode(result.init.status)) {\n    throw new Response(null, result.init);\n  }\n  return result;\n}\nfunction stripIndexParam2(request) {\n  let url = new URL(request.url);\n  let indexValues = url.searchParams.getAll(\"index\");\n  url.searchParams.delete(\"index\");\n  let indexValuesToKeep = [];\n  for (let indexValue of indexValues) {\n    if (indexValue) {\n      indexValuesToKeep.push(indexValue);\n    }\n  }\n  for (let toKeep of indexValuesToKeep) {\n    url.searchParams.append(\"index\", toKeep);\n  }\n  let init = {\n    method: request.method,\n    body: request.body,\n    headers: request.headers,\n    signal: request.signal\n  };\n  if (init.body) {\n    init.duplex = \"half\";\n  }\n  return new Request(url.href, init);\n}\nfunction stripRoutesParam(request) {\n  let url = new URL(request.url);\n  url.searchParams.delete(\"_routes\");\n  let init = {\n    method: request.method,\n    body: request.body,\n    headers: request.headers,\n    signal: request.signal\n  };\n  if (init.body) {\n    init.duplex = \"half\";\n  }\n  return new Request(url.href, init);\n}\n\n// lib/server-runtime/invariant.ts\nfunction invariant3(value, message) {\n  if (value === false || value === null || typeof value === \"undefined\") {\n    console.error(\n      \"The following error is a bug in React Router; please open an issue! https://github.com/remix-run/react-router/issues/new/choose\"\n    );\n    throw new Error(message);\n  }\n}\n\n// lib/server-runtime/routes.ts\nfunction groupRoutesByParentId2(manifest) {\n  let routes = {};\n  Object.values(manifest).forEach((route) => {\n    if (route) {\n      let parentId = route.parentId || \"\";\n      if (!routes[parentId]) {\n        routes[parentId] = [];\n      }\n      routes[parentId].push(route);\n    }\n  });\n  return routes;\n}\nfunction createRoutes(manifest, parentId = \"\", routesByParentId = groupRoutesByParentId2(manifest)) {\n  return (routesByParentId[parentId] || []).map((route) => ({\n    ...route,\n    children: createRoutes(manifest, route.id, routesByParentId)\n  }));\n}\nfunction createStaticHandlerDataRoutes(manifest, future, parentId = \"\", routesByParentId = groupRoutesByParentId2(manifest)) {\n  return (routesByParentId[parentId] || []).map((route) => {\n    let commonRoute = {\n      // Always include root due to default boundaries\n      hasErrorBoundary: route.id === \"root\" || route.module.ErrorBoundary != null,\n      id: route.id,\n      path: route.path,\n      // Need to use RR's version in the param typed here to permit the optional\n      // context even though we know it'll always be provided in remix\n      loader: route.module.loader ? async (args) => {\n        if (args.request.headers.has(\"X-React-Router-Prerender-Data\")) {\n          const preRenderedData = args.request.headers.get(\n            \"X-React-Router-Prerender-Data\"\n          );\n          let encoded = preRenderedData ? decodeURI(preRenderedData) : preRenderedData;\n          invariant3(encoded, \"Missing prerendered data for route\");\n          let uint8array = new TextEncoder().encode(encoded);\n          let stream = new ReadableStream({\n            start(controller) {\n              controller.enqueue(uint8array);\n              controller.close();\n            }\n          });\n          let decoded = await decodeViaTurboStream(stream, global);\n          let data2 = decoded.value;\n          invariant3(\n            data2 && route.id in data2,\n            \"Unable to decode prerendered data\"\n          );\n          let result = data2[route.id];\n          invariant3(\"data\" in result, \"Unable to process prerendered data\");\n          return result.data;\n        }\n        let val = await callRouteHandler(route.module.loader, args);\n        return val;\n      } : void 0,\n      action: route.module.action ? (args) => callRouteHandler(route.module.action, args) : void 0,\n      handle: route.module.handle\n    };\n    return route.index ? {\n      index: true,\n      ...commonRoute\n    } : {\n      caseSensitive: route.caseSensitive,\n      children: createStaticHandlerDataRoutes(\n        manifest,\n        future,\n        route.id,\n        routesByParentId\n      ),\n      ...commonRoute\n    };\n  });\n}\n\n// lib/server-runtime/markup.ts\nvar ESCAPE_LOOKUP3 = {\n  \"&\": \"\\\\u0026\",\n  \">\": \"\\\\u003e\",\n  \"<\": \"\\\\u003c\",\n  \"\\u2028\": \"\\\\u2028\",\n  \"\\u2029\": \"\\\\u2029\"\n};\nvar ESCAPE_REGEX3 = /[&><\\u2028\\u2029]/g;\nfunction escapeHtml2(html) {\n  return html.replace(ESCAPE_REGEX3, (match) => ESCAPE_LOOKUP3[match]);\n}\n\n// lib/server-runtime/serverHandoff.ts\nfunction createServerHandoffString(serverHandoff) {\n  return escapeHtml2(JSON.stringify(serverHandoff));\n}\n\n// lib/server-runtime/dev.ts\nvar globalDevServerHooksKey = \"__reactRouterDevServerHooks\";\nfunction setDevServerHooks(devServerHooks) {\n  globalThis[globalDevServerHooksKey] = devServerHooks;\n}\nfunction getDevServerHooks() {\n  return globalThis[globalDevServerHooksKey];\n}\n\n// lib/server-runtime/single-fetch.ts\nvar import_turbo_stream2 = __webpack_require__(/*! turbo-stream */ \"(ssr)/./node_modules/turbo-stream/dist/turbo-stream.js\");\n\n// lib/server-runtime/headers.ts\nvar import_set_cookie_parser = __webpack_require__(/*! set-cookie-parser */ \"(ssr)/./node_modules/set-cookie-parser/lib/set-cookie.js\");\nfunction getDocumentHeaders(build, context) {\n  let boundaryIdx = context.errors ? context.matches.findIndex((m) => context.errors[m.route.id]) : -1;\n  let matches = boundaryIdx >= 0 ? context.matches.slice(0, boundaryIdx + 1) : context.matches;\n  let errorHeaders;\n  if (boundaryIdx >= 0) {\n    let { actionHeaders, actionData, loaderHeaders, loaderData } = context;\n    context.matches.slice(boundaryIdx).some((match) => {\n      let id = match.route.id;\n      if (actionHeaders[id] && (!actionData || !actionData.hasOwnProperty(id))) {\n        errorHeaders = actionHeaders[id];\n      } else if (loaderHeaders[id] && !loaderData.hasOwnProperty(id)) {\n        errorHeaders = loaderHeaders[id];\n      }\n      return errorHeaders != null;\n    });\n  }\n  return matches.reduce((parentHeaders, match, idx) => {\n    let { id } = match.route;\n    let route = build.routes[id];\n    invariant3(route, `Route with id \"${id}\" not found in build`);\n    let routeModule = route.module;\n    let loaderHeaders = context.loaderHeaders[id] || new Headers();\n    let actionHeaders = context.actionHeaders[id] || new Headers();\n    let includeErrorHeaders = errorHeaders != null && idx === matches.length - 1;\n    let includeErrorCookies = includeErrorHeaders && errorHeaders !== loaderHeaders && errorHeaders !== actionHeaders;\n    if (routeModule.headers == null) {\n      let headers2 = new Headers(parentHeaders);\n      if (includeErrorCookies) {\n        prependCookies(errorHeaders, headers2);\n      }\n      prependCookies(actionHeaders, headers2);\n      prependCookies(loaderHeaders, headers2);\n      return headers2;\n    }\n    let headers = new Headers(\n      routeModule.headers ? typeof routeModule.headers === \"function\" ? routeModule.headers({\n        loaderHeaders,\n        parentHeaders,\n        actionHeaders,\n        errorHeaders: includeErrorHeaders ? errorHeaders : void 0\n      }) : routeModule.headers : void 0\n    );\n    if (includeErrorCookies) {\n      prependCookies(errorHeaders, headers);\n    }\n    prependCookies(actionHeaders, headers);\n    prependCookies(loaderHeaders, headers);\n    prependCookies(parentHeaders, headers);\n    return headers;\n  }, new Headers());\n}\nfunction prependCookies(parentHeaders, childHeaders) {\n  let parentSetCookieString = parentHeaders.get(\"Set-Cookie\");\n  if (parentSetCookieString) {\n    let cookies = (0, import_set_cookie_parser.splitCookiesString)(parentSetCookieString);\n    cookies.forEach((cookie) => {\n      childHeaders.append(\"Set-Cookie\", cookie);\n    });\n  }\n}\n\n// lib/server-runtime/single-fetch.ts\nvar SINGLE_FETCH_REDIRECT_STATUS = 202;\nfunction getSingleFetchDataStrategy2({\n  isActionDataRequest,\n  loadRouteIds\n} = {}) {\n  return async ({ request, matches }) => {\n    if (isActionDataRequest && request.method === \"GET\") {\n      return {};\n    }\n    let matchesToLoad = loadRouteIds ? matches.filter((m) => loadRouteIds.includes(m.route.id)) : matches;\n    let results = await Promise.all(\n      matchesToLoad.map((match) => match.resolve())\n    );\n    return results.reduce(\n      (acc, result, i) => Object.assign(acc, { [matchesToLoad[i].route.id]: result }),\n      {}\n    );\n  };\n}\nasync function singleFetchAction(build, serverMode, staticHandler, request, handlerUrl, loadContext, handleError) {\n  try {\n    let handlerRequest = new Request(handlerUrl, {\n      method: request.method,\n      body: request.body,\n      headers: request.headers,\n      signal: request.signal,\n      ...request.body ? { duplex: \"half\" } : void 0\n    });\n    let result = await staticHandler.query(handlerRequest, {\n      requestContext: loadContext,\n      skipLoaderErrorBubbling: true,\n      dataStrategy: getSingleFetchDataStrategy2({\n        isActionDataRequest: true\n      })\n    });\n    if (isResponse(result)) {\n      return {\n        result: getSingleFetchRedirect(\n          result.status,\n          result.headers,\n          build.basename\n        ),\n        headers: result.headers,\n        status: SINGLE_FETCH_REDIRECT_STATUS\n      };\n    }\n    let context = result;\n    let headers = getDocumentHeaders(build, context);\n    if (isRedirectStatusCode(context.statusCode) && headers.has(\"Location\")) {\n      return {\n        result: getSingleFetchRedirect(\n          context.statusCode,\n          headers,\n          build.basename\n        ),\n        headers,\n        status: SINGLE_FETCH_REDIRECT_STATUS\n      };\n    }\n    if (context.errors) {\n      Object.values(context.errors).forEach((err) => {\n        if (!isRouteErrorResponse(err) || err.error) {\n          handleError(err);\n        }\n      });\n      context.errors = sanitizeErrors(context.errors, serverMode);\n    }\n    let singleFetchResult;\n    if (context.errors) {\n      singleFetchResult = { error: Object.values(context.errors)[0] };\n    } else {\n      singleFetchResult = { data: Object.values(context.actionData || {})[0] };\n    }\n    return {\n      result: singleFetchResult,\n      headers,\n      status: context.statusCode\n    };\n  } catch (error) {\n    handleError(error);\n    return {\n      result: { error },\n      headers: new Headers(),\n      status: 500\n    };\n  }\n}\nasync function singleFetchLoaders(build, serverMode, staticHandler, request, handlerUrl, loadContext, handleError) {\n  try {\n    let handlerRequest = new Request(handlerUrl, {\n      headers: request.headers,\n      signal: request.signal\n    });\n    let loadRouteIds = new URL(request.url).searchParams.get(\"_routes\")?.split(\",\") || void 0;\n    let result = await staticHandler.query(handlerRequest, {\n      requestContext: loadContext,\n      skipLoaderErrorBubbling: true,\n      dataStrategy: getSingleFetchDataStrategy2({\n        loadRouteIds\n      })\n    });\n    if (isResponse(result)) {\n      return {\n        result: {\n          [SingleFetchRedirectSymbol]: getSingleFetchRedirect(\n            result.status,\n            result.headers,\n            build.basename\n          )\n        },\n        headers: result.headers,\n        status: SINGLE_FETCH_REDIRECT_STATUS\n      };\n    }\n    let context = result;\n    let headers = getDocumentHeaders(build, context);\n    if (isRedirectStatusCode(context.statusCode) && headers.has(\"Location\")) {\n      return {\n        result: {\n          [SingleFetchRedirectSymbol]: getSingleFetchRedirect(\n            context.statusCode,\n            headers,\n            build.basename\n          )\n        },\n        headers,\n        status: SINGLE_FETCH_REDIRECT_STATUS\n      };\n    }\n    if (context.errors) {\n      Object.values(context.errors).forEach((err) => {\n        if (!isRouteErrorResponse(err) || err.error) {\n          handleError(err);\n        }\n      });\n      context.errors = sanitizeErrors(context.errors, serverMode);\n    }\n    let results = {};\n    let loadedMatches = loadRouteIds ? context.matches.filter(\n      (m) => m.route.loader && loadRouteIds.includes(m.route.id)\n    ) : context.matches;\n    loadedMatches.forEach((m) => {\n      let { id } = m.route;\n      if (context.errors && context.errors.hasOwnProperty(id)) {\n        results[id] = { error: context.errors[id] };\n      } else if (context.loaderData.hasOwnProperty(id)) {\n        results[id] = { data: context.loaderData[id] };\n      }\n    });\n    return {\n      result: results,\n      headers,\n      status: context.statusCode\n    };\n  } catch (error) {\n    handleError(error);\n    return {\n      result: { root: { error } },\n      headers: new Headers(),\n      status: 500\n    };\n  }\n}\nfunction getSingleFetchRedirect(status, headers, basename) {\n  let redirect2 = headers.get(\"Location\");\n  if (basename) {\n    redirect2 = stripBasename(redirect2, basename) || redirect2;\n  }\n  return {\n    redirect: redirect2,\n    status,\n    revalidate: (\n      // Technically X-Remix-Revalidate isn't needed here - that was an implementation\n      // detail of ?_data requests as our way to tell the front end to revalidate when\n      // we didn't have a response body to include that information in.\n      // With single fetch, we tell the front end via this revalidate boolean field.\n      // However, we're respecting it for now because it may be something folks have\n      // used in their own responses\n      // TODO(v3): Consider removing or making this official public API\n      headers.has(\"X-Remix-Revalidate\") || headers.has(\"Set-Cookie\")\n    ),\n    reload: headers.has(\"X-Remix-Reload-Document\"),\n    replace: headers.has(\"X-Remix-Replace\")\n  };\n}\nfunction encodeViaTurboStream(data2, requestSignal, streamTimeout, serverMode) {\n  let controller = new AbortController();\n  let timeoutId = setTimeout(\n    () => controller.abort(new Error(\"Server Timeout\")),\n    typeof streamTimeout === \"number\" ? streamTimeout : 4950\n  );\n  requestSignal.addEventListener(\"abort\", () => clearTimeout(timeoutId));\n  return (0, import_turbo_stream2.encode)(data2, {\n    signal: controller.signal,\n    plugins: [\n      (value) => {\n        if (value instanceof Error) {\n          let { name, message, stack } = serverMode === \"production\" /* Production */ ? sanitizeError(value, serverMode) : value;\n          return [\"SanitizedError\", name, message, stack];\n        }\n        if (value instanceof ErrorResponseImpl) {\n          let { data: data3, status, statusText } = value;\n          return [\"ErrorResponse\", data3, status, statusText];\n        }\n        if (value && typeof value === \"object\" && SingleFetchRedirectSymbol in value) {\n          return [\"SingleFetchRedirect\", value[SingleFetchRedirectSymbol]];\n        }\n      }\n    ],\n    postPlugins: [\n      (value) => {\n        if (!value) return;\n        if (typeof value !== \"object\") return;\n        return [\n          \"SingleFetchClassInstance\",\n          Object.fromEntries(Object.entries(value))\n        ];\n      },\n      () => [\"SingleFetchFallback\"]\n    ]\n  });\n}\n\n// lib/server-runtime/server.ts\nfunction derive(build, mode) {\n  let routes = createRoutes(build.routes);\n  let dataRoutes = createStaticHandlerDataRoutes(build.routes, build.future);\n  let serverMode = isServerMode(mode) ? mode : \"production\" /* Production */;\n  let staticHandler = createStaticHandler(dataRoutes, {\n    basename: build.basename\n  });\n  let errorHandler = build.entry.module.handleError || ((error, { request }) => {\n    if (serverMode !== \"test\" /* Test */ && !request.signal.aborted) {\n      console.error(\n        // @ts-expect-error This is \"private\" from users but intended for internal use\n        isRouteErrorResponse(error) && error.error ? error.error : error\n      );\n    }\n  });\n  return {\n    routes,\n    dataRoutes,\n    serverMode,\n    staticHandler,\n    errorHandler\n  };\n}\nvar createRequestHandler = (build, mode) => {\n  let _build;\n  let routes;\n  let serverMode;\n  let staticHandler;\n  let errorHandler;\n  return async function requestHandler(request, loadContext = {}) {\n    _build = typeof build === \"function\" ? await build() : build;\n    if (typeof build === \"function\") {\n      let derived = derive(_build, mode);\n      routes = derived.routes;\n      serverMode = derived.serverMode;\n      staticHandler = derived.staticHandler;\n      errorHandler = derived.errorHandler;\n    } else if (!routes || !serverMode || !staticHandler || !errorHandler) {\n      let derived = derive(_build, mode);\n      routes = derived.routes;\n      serverMode = derived.serverMode;\n      staticHandler = derived.staticHandler;\n      errorHandler = derived.errorHandler;\n    }\n    let url = new URL(request.url);\n    let params = {};\n    let handleError = (error) => {\n      if (mode === \"development\" /* Development */) {\n        getDevServerHooks()?.processRequestError?.(error);\n      }\n      errorHandler(error, {\n        context: loadContext,\n        params,\n        request\n      });\n    };\n    let manifestUrl = `${_build.basename ?? \"/\"}/__manifest`.replace(\n      /\\/+/g,\n      \"/\"\n    );\n    if (url.pathname === manifestUrl) {\n      try {\n        let res = await handleManifestRequest(_build, routes, url);\n        return res;\n      } catch (e) {\n        handleError(e);\n        return new Response(\"Unknown Server Error\", { status: 500 });\n      }\n    }\n    let matches = matchServerRoutes(routes, url.pathname, _build.basename);\n    if (matches && matches.length > 0) {\n      Object.assign(params, matches[0].params);\n    }\n    let response;\n    if (url.pathname.endsWith(\".data\")) {\n      let handlerUrl = new URL(request.url);\n      handlerUrl.pathname = handlerUrl.pathname.replace(/\\.data$/, \"\").replace(/^\\/_root$/, \"/\");\n      let singleFetchMatches = matchServerRoutes(\n        routes,\n        handlerUrl.pathname,\n        _build.basename\n      );\n      response = await handleSingleFetchRequest(\n        serverMode,\n        _build,\n        staticHandler,\n        request,\n        handlerUrl,\n        loadContext,\n        handleError\n      );\n      if (_build.entry.module.handleDataRequest) {\n        response = await _build.entry.module.handleDataRequest(response, {\n          context: loadContext,\n          params: singleFetchMatches ? singleFetchMatches[0].params : {},\n          request\n        });\n        if (isRedirectResponse(response)) {\n          let result = getSingleFetchRedirect(\n            response.status,\n            response.headers,\n            _build.basename\n          );\n          if (request.method === \"GET\") {\n            result = {\n              [SingleFetchRedirectSymbol]: result\n            };\n          }\n          let headers = new Headers(response.headers);\n          headers.set(\"Content-Type\", \"text/x-script\");\n          return new Response(\n            encodeViaTurboStream(\n              result,\n              request.signal,\n              _build.entry.module.streamTimeout,\n              serverMode\n            ),\n            {\n              status: SINGLE_FETCH_REDIRECT_STATUS,\n              headers\n            }\n          );\n        }\n      }\n    } else if (matches && matches[matches.length - 1].route.module.default == null && matches[matches.length - 1].route.module.ErrorBoundary == null) {\n      response = await handleResourceRequest(\n        serverMode,\n        staticHandler,\n        matches.slice(-1)[0].route.id,\n        request,\n        loadContext,\n        handleError\n      );\n    } else {\n      let criticalCss = mode === \"development\" /* Development */ ? await getDevServerHooks()?.getCriticalCss?.(_build, url.pathname) : void 0;\n      response = await handleDocumentRequest(\n        serverMode,\n        _build,\n        staticHandler,\n        request,\n        loadContext,\n        handleError,\n        criticalCss\n      );\n    }\n    if (request.method === \"HEAD\") {\n      return new Response(null, {\n        headers: response.headers,\n        status: response.status,\n        statusText: response.statusText\n      });\n    }\n    return response;\n  };\n};\nasync function handleManifestRequest(build, routes, url) {\n  let patches = {};\n  if (url.searchParams.has(\"p\")) {\n    for (let path of url.searchParams.getAll(\"p\")) {\n      let matches = matchServerRoutes(routes, path, build.basename);\n      if (matches) {\n        for (let match of matches) {\n          let routeId = match.route.id;\n          let route = build.assets.routes[routeId];\n          if (route) {\n            patches[routeId] = route;\n          }\n        }\n      }\n    }\n    return Response.json(patches, {\n      headers: {\n        \"Cache-Control\": \"public, max-age=31536000, immutable\"\n      }\n    });\n  }\n  return new Response(\"Invalid Request\", { status: 400 });\n}\nasync function handleSingleFetchRequest(serverMode, build, staticHandler, request, handlerUrl, loadContext, handleError) {\n  let { result, headers, status } = request.method !== \"GET\" ? await singleFetchAction(\n    build,\n    serverMode,\n    staticHandler,\n    request,\n    handlerUrl,\n    loadContext,\n    handleError\n  ) : await singleFetchLoaders(\n    build,\n    serverMode,\n    staticHandler,\n    request,\n    handlerUrl,\n    loadContext,\n    handleError\n  );\n  let resultHeaders = new Headers(headers);\n  resultHeaders.set(\"X-Remix-Response\", \"yes\");\n  if (status === 304) {\n    return new Response(null, { status: 304, headers: resultHeaders });\n  }\n  resultHeaders.set(\"Content-Type\", \"text/x-script\");\n  return new Response(\n    encodeViaTurboStream(\n      result,\n      request.signal,\n      build.entry.module.streamTimeout,\n      serverMode\n    ),\n    {\n      status: status || 200,\n      headers: resultHeaders\n    }\n  );\n}\nasync function handleDocumentRequest(serverMode, build, staticHandler, request, loadContext, handleError, criticalCss) {\n  let context;\n  try {\n    context = await staticHandler.query(request, {\n      requestContext: loadContext\n    });\n  } catch (error) {\n    handleError(error);\n    return new Response(null, { status: 500 });\n  }\n  if (isResponse(context)) {\n    return context;\n  }\n  let headers = getDocumentHeaders(build, context);\n  if (context.statusCode === 304) {\n    return new Response(null, { status: 304, headers });\n  }\n  if (context.errors) {\n    Object.values(context.errors).forEach((err) => {\n      if (!isRouteErrorResponse(err) || err.error) {\n        handleError(err);\n      }\n    });\n    context.errors = sanitizeErrors(context.errors, serverMode);\n  }\n  let state = {\n    loaderData: context.loaderData,\n    actionData: context.actionData,\n    errors: serializeErrors2(context.errors, serverMode)\n  };\n  let entryContext = {\n    manifest: build.assets,\n    routeModules: createEntryRouteModules(build.routes),\n    staticHandlerContext: context,\n    criticalCss,\n    serverHandoffString: createServerHandoffString({\n      basename: build.basename,\n      criticalCss,\n      future: build.future,\n      isSpaMode: build.isSpaMode\n    }),\n    serverHandoffStream: encodeViaTurboStream(\n      state,\n      request.signal,\n      build.entry.module.streamTimeout,\n      serverMode\n    ),\n    renderMeta: {},\n    future: build.future,\n    isSpaMode: build.isSpaMode,\n    serializeError: (err) => serializeError(err, serverMode)\n  };\n  let handleDocumentRequestFunction = build.entry.module.default;\n  try {\n    return await handleDocumentRequestFunction(\n      request,\n      context.statusCode,\n      headers,\n      entryContext,\n      loadContext\n    );\n  } catch (error) {\n    handleError(error);\n    let errorForSecondRender = error;\n    if (isResponse(error)) {\n      try {\n        let data2 = await unwrapResponse(error);\n        errorForSecondRender = new ErrorResponseImpl(\n          error.status,\n          error.statusText,\n          data2\n        );\n      } catch (e) {\n      }\n    }\n    context = getStaticContextFromError(\n      staticHandler.dataRoutes,\n      context,\n      errorForSecondRender\n    );\n    if (context.errors) {\n      context.errors = sanitizeErrors(context.errors, serverMode);\n    }\n    let state2 = {\n      loaderData: context.loaderData,\n      actionData: context.actionData,\n      errors: serializeErrors2(context.errors, serverMode)\n    };\n    entryContext = {\n      ...entryContext,\n      staticHandlerContext: context,\n      serverHandoffString: createServerHandoffString({\n        basename: build.basename,\n        future: build.future,\n        isSpaMode: build.isSpaMode\n      }),\n      serverHandoffStream: encodeViaTurboStream(\n        state2,\n        request.signal,\n        build.entry.module.streamTimeout,\n        serverMode\n      ),\n      renderMeta: {}\n    };\n    try {\n      return await handleDocumentRequestFunction(\n        request,\n        context.statusCode,\n        headers,\n        entryContext,\n        loadContext\n      );\n    } catch (error2) {\n      handleError(error2);\n      return returnLastResortErrorResponse(error2, serverMode);\n    }\n  }\n}\nasync function handleResourceRequest(serverMode, staticHandler, routeId, request, loadContext, handleError) {\n  try {\n    let response = await staticHandler.queryRoute(request, {\n      routeId,\n      requestContext: loadContext\n    });\n    invariant3(\n      isResponse(response),\n      \"Expected a Response to be returned from resource route handler\"\n    );\n    return response;\n  } catch (error) {\n    if (isResponse(error)) {\n      error.headers.set(\"X-Remix-Catch\", \"yes\");\n      return error;\n    }\n    if (isRouteErrorResponse(error)) {\n      if (error) {\n        handleError(error);\n      }\n      return errorResponseToJson(error, serverMode);\n    }\n    handleError(error);\n    return returnLastResortErrorResponse(error, serverMode);\n  }\n}\nfunction errorResponseToJson(errorResponse, serverMode) {\n  return Response.json(\n    serializeError(\n      // @ts-expect-error This is \"private\" from users but intended for internal use\n      errorResponse.error || new Error(\"Unexpected Server Error\"),\n      serverMode\n    ),\n    {\n      status: errorResponse.status,\n      statusText: errorResponse.statusText,\n      headers: {\n        \"X-Remix-Error\": \"yes\"\n      }\n    }\n  );\n}\nfunction returnLastResortErrorResponse(error, serverMode) {\n  let message = \"Unexpected Server Error\";\n  if (serverMode !== \"production\" /* Production */) {\n    message += `\n\n${String(error)}`;\n  }\n  return new Response(message, {\n    status: 500,\n    headers: {\n      \"Content-Type\": \"text/plain\"\n    }\n  });\n}\nfunction unwrapResponse(response) {\n  let contentType = response.headers.get(\"Content-Type\");\n  return contentType && /\\bapplication\\/json\\b/.test(contentType) ? response.body == null ? null : response.json() : response.text();\n}\n\n// lib/server-runtime/sessions.ts\nfunction flash(name) {\n  return `__flash_${name}__`;\n}\nvar createSession = (initialData = {}, id = \"\") => {\n  let map = new Map(Object.entries(initialData));\n  return {\n    get id() {\n      return id;\n    },\n    get data() {\n      return Object.fromEntries(map);\n    },\n    has(name) {\n      return map.has(name) || map.has(flash(name));\n    },\n    get(name) {\n      if (map.has(name)) return map.get(name);\n      let flashName = flash(name);\n      if (map.has(flashName)) {\n        let value = map.get(flashName);\n        map.delete(flashName);\n        return value;\n      }\n      return void 0;\n    },\n    set(name, value) {\n      map.set(name, value);\n    },\n    flash(name, value) {\n      map.set(flash(name), value);\n    },\n    unset(name) {\n      map.delete(name);\n    }\n  };\n};\nvar isSession = (object) => {\n  return object != null && typeof object.id === \"string\" && typeof object.data !== \"undefined\" && typeof object.has === \"function\" && typeof object.get === \"function\" && typeof object.set === \"function\" && typeof object.flash === \"function\" && typeof object.unset === \"function\";\n};\nfunction createSessionStorage({\n  cookie: cookieArg,\n  createData,\n  readData,\n  updateData,\n  deleteData\n}) {\n  let cookie = isCookie(cookieArg) ? cookieArg : createCookie(cookieArg?.name || \"__session\", cookieArg);\n  warnOnceAboutSigningSessionCookie(cookie);\n  return {\n    async getSession(cookieHeader, options) {\n      let id = cookieHeader && await cookie.parse(cookieHeader, options);\n      let data2 = id && await readData(id);\n      return createSession(data2 || {}, id || \"\");\n    },\n    async commitSession(session, options) {\n      let { id, data: data2 } = session;\n      let expires = options?.maxAge != null ? new Date(Date.now() + options.maxAge * 1e3) : options?.expires != null ? options.expires : cookie.expires;\n      if (id) {\n        await updateData(id, data2, expires);\n      } else {\n        id = await createData(data2, expires);\n      }\n      return cookie.serialize(id, options);\n    },\n    async destroySession(session, options) {\n      await deleteData(session.id);\n      return cookie.serialize(\"\", {\n        ...options,\n        maxAge: void 0,\n        expires: /* @__PURE__ */ new Date(0)\n      });\n    }\n  };\n}\nfunction warnOnceAboutSigningSessionCookie(cookie) {\n  warnOnce(\n    cookie.isSigned,\n    `The \"${cookie.name}\" cookie is not signed, but session cookies should be signed to prevent tampering on the client before they are sent back to the server. See https://remix.run/utils/cookies#signing-cookies for more information.`\n  );\n}\n\n// lib/server-runtime/sessions/cookieStorage.ts\nfunction createCookieSessionStorage({ cookie: cookieArg } = {}) {\n  let cookie = isCookie(cookieArg) ? cookieArg : createCookie(cookieArg?.name || \"__session\", cookieArg);\n  warnOnceAboutSigningSessionCookie(cookie);\n  return {\n    async getSession(cookieHeader, options) {\n      return createSession(\n        cookieHeader && await cookie.parse(cookieHeader, options) || {}\n      );\n    },\n    async commitSession(session, options) {\n      let serializedCookie = await cookie.serialize(session.data, options);\n      if (serializedCookie.length > 4096) {\n        throw new Error(\n          \"Cookie length will exceed browser maximum. Length: \" + serializedCookie.length\n        );\n      }\n      return serializedCookie;\n    },\n    async destroySession(_session, options) {\n      return cookie.serialize(\"\", {\n        ...options,\n        maxAge: void 0,\n        expires: /* @__PURE__ */ new Date(0)\n      });\n    }\n  };\n}\n\n// lib/server-runtime/sessions/memoryStorage.ts\nfunction createMemorySessionStorage({ cookie } = {}) {\n  let map = /* @__PURE__ */ new Map();\n  return createSessionStorage({\n    cookie,\n    async createData(data2, expires) {\n      let id = Math.random().toString(36).substring(2, 10);\n      map.set(id, { data: data2, expires });\n      return id;\n    },\n    async readData(id) {\n      if (map.has(id)) {\n        let { data: data2, expires } = map.get(id);\n        if (!expires || expires > /* @__PURE__ */ new Date()) {\n          return data2;\n        }\n        if (expires) map.delete(id);\n      }\n      return null;\n    },\n    async updateData(id, data2, expires) {\n      map.set(id, { data: data2, expires });\n    },\n    async deleteData(id) {\n      map.delete(id);\n    }\n  });\n}\n\n// lib/dom/ssr/errors.ts\nfunction deserializeErrors2(errors) {\n  if (!errors) return null;\n  let entries = Object.entries(errors);\n  let serialized = {};\n  for (let [key, val] of entries) {\n    if (val && val.__type === \"RouteErrorResponse\") {\n      serialized[key] = new ErrorResponseImpl(\n        val.status,\n        val.statusText,\n        val.data,\n        val.internal === true\n      );\n    } else if (val && val.__type === \"Error\") {\n      if (val.__subType) {\n        let ErrorConstructor = window[val.__subType];\n        if (typeof ErrorConstructor === \"function\") {\n          try {\n            let error = new ErrorConstructor(val.message);\n            error.stack = val.stack;\n            serialized[key] = error;\n          } catch (e) {\n          }\n        }\n      }\n      if (serialized[key] == null) {\n        let error = new Error(val.message);\n        error.stack = val.stack;\n        serialized[key] = error;\n      }\n    } else {\n      serialized[key] = val;\n    }\n  }\n  return serialized;\n}\n// Annotate the CommonJS export names for ESM import in node:\n0 && (0);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmVhY3Qtcm91dGVyL2Rpc3QvZGV2ZWxvcG1lbnQvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsa0NBQWtDO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsNEZBQTRGO0FBQ3pIO0FBQ0E7QUFDQTtBQUNBLG1HQUFtRztBQUNuRztBQUNBO0FBQ0E7QUFDQTtBQUNBLHlFQUF5RSw4QkFBOEI7QUFDdkc7QUFDQTtBQUNBLG9EQUFvRCxrQkFBa0IsYUFBYTs7QUFFbkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSixXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxlQUFlO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckIsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsVUFBVSxpQkFBaUI7QUFDM0I7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlFQUF5RTtBQUN6RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLHdDQUF3QztBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLFVBQVU7QUFDdEM7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCxZQUFZLElBQUk7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSwwQkFBMEI7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsa0JBQWtCLG1DQUFtQztBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxnQ0FBZ0M7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxVQUFVLHFCQUFxQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1IsOERBQThELFdBQVc7QUFDekU7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLGdCQUFnQjtBQUN4RCxZQUFZO0FBQ1o7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSxJQUFJO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLHNDQUFzQztBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsNERBQTREO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtEO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0Esd0JBQXdCLGtDQUFrQztBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsWUFBWSxFQUFFLGVBQWU7QUFDcEQsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUcsSUFBSTtBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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Q0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkRBQTZELDRDQUE0QztBQUN6RztBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRSxJQUFJO0FBQ04sUUFBUSxTQUFTO0FBQ2pCLFFBQVEsNENBQTRDO0FBQ3BEO0FBQ0E7QUFDQSxRQUFRLFdBQVc7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSw4R0FBOEcsTUFBTTtBQUNwSDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFFBQVEsVUFBVTtBQUNs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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQXFEO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwyQkFBMkIsbUJBQU8sQ0FBQyw0RUFBYzs7QUFFakQ7QUFDQSwrQkFBK0IsbUJBQU8sQ0FBQyxtRkFBbUI7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsdURBQXVEO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsVUFBVSxLQUFLO0FBQ2Y7QUFDQSx3Q0FBd0MsR0FBRztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRSxJQUFJO0FBQ04sa0JBQWtCLGtCQUFrQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLHFDQUFxQztBQUNwRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLGlCQUFpQjtBQUMzQyxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QixNQUFNO0FBQ04sNEJBQTRCLDRDQUE0QztBQUN4RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLGdCQUFnQixPQUFPO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksS0FBSztBQUNqQjtBQUNBLHdCQUF3QjtBQUN4QixRQUFRO0FBQ1Isd0JBQXdCO0FBQ3hCO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLGdCQUFnQixRQUFRLFNBQVM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLHVCQUF1QjtBQUN2QztBQUNBO0FBQ0E7QUFDQSxnQkFBZ0Isa0NBQWtDO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILGtFQUFrRSxTQUFTO0FBQzNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0VBQWdFO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EseUJBQXlCLHVCQUF1QjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLHNEQUFzRCxhQUFhO0FBQ25FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdFQUF3RTtBQUN4RTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsMkNBQTJDLGFBQWE7QUFDeEQ7QUFDQTtBQUNBLFFBQVEsMEJBQTBCO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLHFDQUFxQztBQUNyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLElBQUk7QUFDSjtBQUNBLGdDQUFnQyxhQUFhO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxzQkFBc0I7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsRUFBRSxjQUFjO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxvQkFBb0IsS0FBSztBQUN6QjtBQUNBLHFDQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQztBQUN0QyxLQUFLO0FBQ0w7QUFDQSxZQUFZLGtCQUFrQjtBQUM5QjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFlBQVk7QUFDeEI7QUFDQTs7QUFFQTtBQUNBLHNDQUFzQyxvQkFBb0IsSUFBSTtBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0Esc0NBQXNDLFNBQVMsSUFBSTtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHNCQUFzQjtBQUMxQztBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsY0FBYyx1QkFBdUI7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0Esb0JBQW9CLHNCQUFzQjtBQUMxQyxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSxDQWdITCIsInNvdXJjZXMiOlsiL1VzZXJzL211bXVtdS9zcmMvcmFpbHMvYXBpLWFwcC9mcm9udGVuZC9ub2RlX21vZHVsZXMvcmVhY3Qtcm91dGVyL2Rpc3QvZGV2ZWxvcG1lbnQvaW5kZXguanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiByZWFjdC1yb3V0ZXIgdjcuMS4wXG4gKlxuICogQ29weXJpZ2h0IChjKSBSZW1peCBTb2Z0d2FyZSBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFLm1kIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICogQGxpY2Vuc2UgTUlUXG4gKi9cblwidXNlIHN0cmljdFwiO1xudmFyIF9fY3JlYXRlID0gT2JqZWN0LmNyZWF0ZTtcbnZhciBfX2RlZlByb3AgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG52YXIgX19nZXRPd25Qcm9wRGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7XG52YXIgX19nZXRPd25Qcm9wTmFtZXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcztcbnZhciBfX2dldFByb3RvT2YgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Y7XG52YXIgX19oYXNPd25Qcm9wID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbnZhciBfX2V4cG9ydCA9ICh0YXJnZXQsIGFsbCkgPT4ge1xuICBmb3IgKHZhciBuYW1lIGluIGFsbClcbiAgICBfX2RlZlByb3AodGFyZ2V0LCBuYW1lLCB7IGdldDogYWxsW25hbWVdLCBlbnVtZXJhYmxlOiB0cnVlIH0pO1xufTtcbnZhciBfX2NvcHlQcm9wcyA9ICh0bywgZnJvbSwgZXhjZXB0LCBkZXNjKSA9PiB7XG4gIGlmIChmcm9tICYmIHR5cGVvZiBmcm9tID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBmcm9tID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICBmb3IgKGxldCBrZXkgb2YgX19nZXRPd25Qcm9wTmFtZXMoZnJvbSkpXG4gICAgICBpZiAoIV9faGFzT3duUHJvcC5jYWxsKHRvLCBrZXkpICYmIGtleSAhPT0gZXhjZXB0KVxuICAgICAgICBfX2RlZlByb3AodG8sIGtleSwgeyBnZXQ6ICgpID0+IGZyb21ba2V5XSwgZW51bWVyYWJsZTogIShkZXNjID0gX19nZXRPd25Qcm9wRGVzYyhmcm9tLCBrZXkpKSB8fCBkZXNjLmVudW1lcmFibGUgfSk7XG4gIH1cbiAgcmV0dXJuIHRvO1xufTtcbnZhciBfX3RvRVNNID0gKG1vZCwgaXNOb2RlTW9kZSwgdGFyZ2V0KSA9PiAodGFyZ2V0ID0gbW9kICE9IG51bGwgPyBfX2NyZWF0ZShfX2dldFByb3RvT2YobW9kKSkgOiB7fSwgX19jb3B5UHJvcHMoXG4gIC8vIElmIHRoZSBpbXBvcnRlciBpcyBpbiBub2RlIGNvbXBhdGliaWxpdHkgbW9kZSBvciB0aGlzIGlzIG5vdCBhbiBFU01cbiAgLy8gZmlsZSB0aGF0IGhhcyBiZWVuIGNvbnZlcnRlZCB0byBhIENvbW1vbkpTIGZpbGUgdXNpbmcgYSBCYWJlbC1cbiAgLy8gY29tcGF0aWJsZSB0cmFuc2Zvcm0gKGkuZS4gXCJfX2VzTW9kdWxlXCIgaGFzIG5vdCBiZWVuIHNldCksIHRoZW4gc2V0XG4gIC8vIFwiZGVmYXVsdFwiIHRvIHRoZSBDb21tb25KUyBcIm1vZHVsZS5leHBvcnRzXCIgZm9yIG5vZGUgY29tcGF0aWJpbGl0eS5cbiAgaXNOb2RlTW9kZSB8fCAhbW9kIHx8ICFtb2QuX19lc01vZHVsZSA/IF9fZGVmUHJvcCh0YXJnZXQsIFwiZGVmYXVsdFwiLCB7IHZhbHVlOiBtb2QsIGVudW1lcmFibGU6IHRydWUgfSkgOiB0YXJnZXQsXG4gIG1vZFxuKSk7XG52YXIgX190b0NvbW1vbkpTID0gKG1vZCkgPT4gX19jb3B5UHJvcHMoX19kZWZQcm9wKHt9LCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KSwgbW9kKTtcblxuLy8gaW5kZXgudHNcbnZhciByZWFjdF9yb3V0ZXJfZXhwb3J0cyA9IHt9O1xuX19leHBvcnQocmVhY3Rfcm91dGVyX2V4cG9ydHMsIHtcbiAgQXdhaXQ6ICgpID0+IEF3YWl0LFxuICBCcm93c2VyUm91dGVyOiAoKSA9PiBCcm93c2VyUm91dGVyLFxuICBGb3JtOiAoKSA9PiBGb3JtLFxuICBIYXNoUm91dGVyOiAoKSA9PiBIYXNoUm91dGVyLFxuICBJRExFX0JMT0NLRVI6ICgpID0+IElETEVfQkxPQ0tFUixcbiAgSURMRV9GRVRDSEVSOiAoKSA9PiBJRExFX0ZFVENIRVIsXG4gIElETEVfTkFWSUdBVElPTjogKCkgPT4gSURMRV9OQVZJR0FUSU9OLFxuICBMaW5rOiAoKSA9PiBMaW5rLFxuICBMaW5rczogKCkgPT4gTGlua3MsXG4gIE1lbW9yeVJvdXRlcjogKCkgPT4gTWVtb3J5Um91dGVyLFxuICBNZXRhOiAoKSA9PiBNZXRhLFxuICBOYXZMaW5rOiAoKSA9PiBOYXZMaW5rLFxuICBOYXZpZ2F0ZTogKCkgPT4gTmF2aWdhdGUsXG4gIE5hdmlnYXRpb25UeXBlOiAoKSA9PiBBY3Rpb24sXG4gIE91dGxldDogKCkgPT4gT3V0bGV0LFxuICBQcmVmZXRjaFBhZ2VMaW5rczogKCkgPT4gUHJlZmV0Y2hQYWdlTGlua3MsXG4gIFJvdXRlOiAoKSA9PiBSb3V0ZSxcbiAgUm91dGVyOiAoKSA9PiBSb3V0ZXIsXG4gIFJvdXRlclByb3ZpZGVyOiAoKSA9PiBSb3V0ZXJQcm92aWRlcixcbiAgUm91dGVzOiAoKSA9PiBSb3V0ZXMsXG4gIFNjcmlwdHM6ICgpID0+IFNjcmlwdHMsXG4gIFNjcm9sbFJlc3RvcmF0aW9uOiAoKSA9PiBTY3JvbGxSZXN0b3JhdGlvbixcbiAgU2VydmVyUm91dGVyOiAoKSA9PiBTZXJ2ZXJSb3V0ZXIsXG4gIFN0YXRpY1JvdXRlcjogKCkgPT4gU3RhdGljUm91dGVyLFxuICBTdGF0aWNSb3V0ZXJQcm92aWRlcjogKCkgPT4gU3RhdGljUm91dGVyUHJvdmlkZXIsXG4gIFVOU0FGRV9EYXRhUm91dGVyQ29udGV4dDogKCkgPT4gRGF0YVJvdXRlckNvbnRleHQsXG4gIFVOU0FGRV9EYXRhUm91dGVyU3RhdGVDb250ZXh0OiAoKSA9PiBEYXRhUm91dGVyU3RhdGVDb250ZXh0LFxuICBVTlNBRkVfRXJyb3JSZXNwb25zZUltcGw6ICgpID0+IEVycm9yUmVzcG9uc2VJbXBsLFxuICBVTlNBRkVfRmV0Y2hlcnNDb250ZXh0OiAoKSA9PiBGZXRjaGVyc0NvbnRleHQsXG4gIFVOU0FGRV9GcmFtZXdvcmtDb250ZXh0OiAoKSA9PiBGcmFtZXdvcmtDb250ZXh0LFxuICBVTlNBRkVfTG9jYXRpb25Db250ZXh0OiAoKSA9PiBMb2NhdGlvbkNvbnRleHQsXG4gIFVOU0FGRV9OYXZpZ2F0aW9uQ29udGV4dDogKCkgPT4gTmF2aWdhdGlvbkNvbnRleHQsXG4gIFVOU0FGRV9SZW1peEVycm9yQm91bmRhcnk6ICgpID0+IFJlbWl4RXJyb3JCb3VuZGFyeSxcbiAgVU5TQUZFX1JvdXRlQ29udGV4dDogKCkgPT4gUm91dGVDb250ZXh0LFxuICBVTlNBRkVfU2VydmVyTW9kZTogKCkgPT4gU2VydmVyTW9kZSxcbiAgVU5TQUZFX1NpbmdsZUZldGNoUmVkaXJlY3RTeW1ib2w6ICgpID0+IFNpbmdsZUZldGNoUmVkaXJlY3RTeW1ib2wsXG4gIFVOU0FGRV9WaWV3VHJhbnNpdGlvbkNvbnRleHQ6ICgpID0+IFZpZXdUcmFuc2l0aW9uQ29udGV4dCxcbiAgVU5TQUZFX2NyZWF0ZUJyb3dzZXJIaXN0b3J5OiAoKSA9PiBjcmVhdGVCcm93c2VySGlzdG9yeSxcbiAgVU5TQUZFX2NyZWF0ZUNsaWVudFJvdXRlczogKCkgPT4gY3JlYXRlQ2xpZW50Um91dGVzLFxuICBVTlNBRkVfY3JlYXRlQ2xpZW50Um91dGVzV2l0aEhNUlJldmFsaWRhdGlvbk9wdE91dDogKCkgPT4gY3JlYXRlQ2xpZW50Um91dGVzV2l0aEhNUlJldmFsaWRhdGlvbk9wdE91dCxcbiAgVU5TQUZFX2NyZWF0ZVJvdXRlcjogKCkgPT4gY3JlYXRlUm91dGVyLFxuICBVTlNBRkVfZGVjb2RlVmlhVHVyYm9TdHJlYW06ICgpID0+IGRlY29kZVZpYVR1cmJvU3RyZWFtLFxuICBVTlNBRkVfZGVzZXJpYWxpemVFcnJvcnM6ICgpID0+IGRlc2VyaWFsaXplRXJyb3JzMixcbiAgVU5TQUZFX2dldFBhdGNoUm91dGVzT25OYXZpZ2F0aW9uRnVuY3Rpb246ICgpID0+IGdldFBhdGNoUm91dGVzT25OYXZpZ2F0aW9uRnVuY3Rpb24sXG4gIFVOU0FGRV9nZXRTaW5nbGVGZXRjaERhdGFTdHJhdGVneTogKCkgPT4gZ2V0U2luZ2xlRmV0Y2hEYXRhU3RyYXRlZ3ksXG4gIFVOU0FGRV9pbnZhcmlhbnQ6ICgpID0+IGludmFyaWFudCxcbiAgVU5TQUZFX21hcFJvdXRlUHJvcGVydGllczogKCkgPT4gbWFwUm91dGVQcm9wZXJ0aWVzLFxuICBVTlNBRkVfc2hvdWxkSHlkcmF0ZVJvdXRlTG9hZGVyOiAoKSA9PiBzaG91bGRIeWRyYXRlUm91dGVMb2FkZXIsXG4gIFVOU0FGRV91c2VGb2dPRldhckRpc2NvdmVyeTogKCkgPT4gdXNlRm9nT0ZXYXJEaXNjb3ZlcnksXG4gIFVOU0FGRV91c2VTY3JvbGxSZXN0b3JhdGlvbjogKCkgPT4gdXNlU2Nyb2xsUmVzdG9yYXRpb24sXG4gIGNyZWF0ZUJyb3dzZXJSb3V0ZXI6ICgpID0+IGNyZWF0ZUJyb3dzZXJSb3V0ZXIsXG4gIGNyZWF0ZUNvb2tpZTogKCkgPT4gY3JlYXRlQ29va2llLFxuICBjcmVhdGVDb29raWVTZXNzaW9uU3RvcmFnZTogKCkgPT4gY3JlYXRlQ29va2llU2Vzc2lvblN0b3JhZ2UsXG4gIGNyZWF0ZUhhc2hSb3V0ZXI6ICgpID0+IGNyZWF0ZUhhc2hSb3V0ZXIsXG4gIGNyZWF0ZU1lbW9yeVJvdXRlcjogKCkgPT4gY3JlYXRlTWVtb3J5Um91dGVyLFxuICBjcmVhdGVNZW1vcnlTZXNzaW9uU3RvcmFnZTogKCkgPT4gY3JlYXRlTWVtb3J5U2Vzc2lvblN0b3JhZ2UsXG4gIGNyZWF0ZVBhdGg6ICgpID0+IGNyZWF0ZVBhdGgsXG4gIGNyZWF0ZVJlcXVlc3RIYW5kbGVyOiAoKSA9PiBjcmVhdGVSZXF1ZXN0SGFuZGxlcixcbiAgY3JlYXRlUm91dGVzRnJvbUNoaWxkcmVuOiAoKSA9PiBjcmVhdGVSb3V0ZXNGcm9tQ2hpbGRyZW4sXG4gIGNyZWF0ZVJvdXRlc0Zyb21FbGVtZW50czogKCkgPT4gY3JlYXRlUm91dGVzRnJvbUVsZW1lbnRzLFxuICBjcmVhdGVSb3V0ZXNTdHViOiAoKSA9PiBjcmVhdGVSb3V0ZXNTdHViLFxuICBjcmVhdGVTZWFyY2hQYXJhbXM6ICgpID0+IGNyZWF0ZVNlYXJjaFBhcmFtcyxcbiAgY3JlYXRlU2Vzc2lvbjogKCkgPT4gY3JlYXRlU2Vzc2lvbixcbiAgY3JlYXRlU2Vzc2lvblN0b3JhZ2U6ICgpID0+IGNyZWF0ZVNlc3Npb25TdG9yYWdlLFxuICBjcmVhdGVTdGF0aWNIYW5kbGVyOiAoKSA9PiBjcmVhdGVTdGF0aWNIYW5kbGVyMixcbiAgY3JlYXRlU3RhdGljUm91dGVyOiAoKSA9PiBjcmVhdGVTdGF0aWNSb3V0ZXIsXG4gIGRhdGE6ICgpID0+IGRhdGEsXG4gIGdlbmVyYXRlUGF0aDogKCkgPT4gZ2VuZXJhdGVQYXRoLFxuICBpc0Nvb2tpZTogKCkgPT4gaXNDb29raWUsXG4gIGlzUm91dGVFcnJvclJlc3BvbnNlOiAoKSA9PiBpc1JvdXRlRXJyb3JSZXNwb25zZSxcbiAgaXNTZXNzaW9uOiAoKSA9PiBpc1Nlc3Npb24sXG4gIG1hdGNoUGF0aDogKCkgPT4gbWF0Y2hQYXRoLFxuICBtYXRjaFJvdXRlczogKCkgPT4gbWF0Y2hSb3V0ZXMsXG4gIHBhcnNlUGF0aDogKCkgPT4gcGFyc2VQYXRoLFxuICByZWRpcmVjdDogKCkgPT4gcmVkaXJlY3QsXG4gIHJlZGlyZWN0RG9jdW1lbnQ6ICgpID0+IHJlZGlyZWN0RG9jdW1lbnQsXG4gIHJlbmRlck1hdGNoZXM6ICgpID0+IHJlbmRlck1hdGNoZXMsXG4gIHJlcGxhY2U6ICgpID0+IHJlcGxhY2UsXG4gIHJlc29sdmVQYXRoOiAoKSA9PiByZXNvbHZlUGF0aCxcbiAgdW5zdGFibGVfSGlzdG9yeVJvdXRlcjogKCkgPT4gSGlzdG9yeVJvdXRlcixcbiAgdW5zdGFibGVfc2V0RGV2U2VydmVySG9va3M6ICgpID0+IHNldERldlNlcnZlckhvb2tzLFxuICB1bnN0YWJsZV91c2VQcm9tcHQ6ICgpID0+IHVzZVByb21wdCxcbiAgdXNlQWN0aW9uRGF0YTogKCkgPT4gdXNlQWN0aW9uRGF0YSxcbiAgdXNlQXN5bmNFcnJvcjogKCkgPT4gdXNlQXN5bmNFcnJvcixcbiAgdXNlQXN5bmNWYWx1ZTogKCkgPT4gdXNlQXN5bmNWYWx1ZSxcbiAgdXNlQmVmb3JlVW5sb2FkOiAoKSA9PiB1c2VCZWZvcmVVbmxvYWQsXG4gIHVzZUJsb2NrZXI6ICgpID0+IHVzZUJsb2NrZXIsXG4gIHVzZUZldGNoZXI6ICgpID0+IHVzZUZldGNoZXIsXG4gIHVzZUZldGNoZXJzOiAoKSA9PiB1c2VGZXRjaGVycyxcbiAgdXNlRm9ybUFjdGlvbjogKCkgPT4gdXNlRm9ybUFjdGlvbixcbiAgdXNlSHJlZjogKCkgPT4gdXNlSHJlZixcbiAgdXNlSW5Sb3V0ZXJDb250ZXh0OiAoKSA9PiB1c2VJblJvdXRlckNvbnRleHQsXG4gIHVzZUxpbmtDbGlja0hhbmRsZXI6ICgpID0+IHVzZUxpbmtDbGlja0hhbmRsZXIsXG4gIHVzZUxvYWRlckRhdGE6ICgpID0+IHVzZUxvYWRlckRhdGEsXG4gIHVzZUxvY2F0aW9uOiAoKSA9PiB1c2VMb2NhdGlvbixcbiAgdXNlTWF0Y2g6ICgpID0+IHVzZU1hdGNoLFxuICB1c2VNYXRjaGVzOiAoKSA9PiB1c2VNYXRjaGVzLFxuICB1c2VOYXZpZ2F0ZTogKCkgPT4gdXNlTmF2aWdhdGUsXG4gIHVzZU5hdmlnYXRpb246ICgpID0+IHVzZU5hdmlnYXRpb24sXG4gIHVzZU5hdmlnYXRpb25UeXBlOiAoKSA9PiB1c2VOYXZpZ2F0aW9uVHlwZSxcbiAgdXNlT3V0bGV0OiAoKSA9PiB1c2VPdXRsZXQsXG4gIHVzZU91dGxldENvbnRleHQ6ICgpID0+IHVzZU91dGxldENvbnRleHQsXG4gIHVzZVBhcmFtczogKCkgPT4gdXNlUGFyYW1zLFxuICB1c2VSZXNvbHZlZFBhdGg6ICgpID0+IHVzZVJlc29sdmVkUGF0aCxcbiAgdXNlUmV2YWxpZGF0b3I6ICgpID0+IHVzZVJldmFsaWRhdG9yLFxuICB1c2VSb3V0ZUVycm9yOiAoKSA9PiB1c2VSb3V0ZUVycm9yLFxuICB1c2VSb3V0ZUxvYWRlckRhdGE6ICgpID0+IHVzZVJvdXRlTG9hZGVyRGF0YSxcbiAgdXNlUm91dGVzOiAoKSA9PiB1c2VSb3V0ZXMsXG4gIHVzZVNlYXJjaFBhcmFtczogKCkgPT4gdXNlU2VhcmNoUGFyYW1zLFxuICB1c2VTdWJtaXQ6ICgpID0+IHVzZVN1Ym1pdCxcbiAgdXNlVmlld1RyYW5zaXRpb25TdGF0ZTogKCkgPT4gdXNlVmlld1RyYW5zaXRpb25TdGF0ZVxufSk7XG5tb2R1bGUuZXhwb3J0cyA9IF9fdG9Db21tb25KUyhyZWFjdF9yb3V0ZXJfZXhwb3J0cyk7XG5cbi8vIGxpYi9yb3V0ZXIvaGlzdG9yeS50c1xudmFyIEFjdGlvbiA9IC8qIEBfX1BVUkVfXyAqLyAoKEFjdGlvbjIpID0+IHtcbiAgQWN0aW9uMltcIlBvcFwiXSA9IFwiUE9QXCI7XG4gIEFjdGlvbjJbXCJQdXNoXCJdID0gXCJQVVNIXCI7XG4gIEFjdGlvbjJbXCJSZXBsYWNlXCJdID0gXCJSRVBMQUNFXCI7XG4gIHJldHVybiBBY3Rpb24yO1xufSkoQWN0aW9uIHx8IHt9KTtcbnZhciBQb3BTdGF0ZUV2ZW50VHlwZSA9IFwicG9wc3RhdGVcIjtcbmZ1bmN0aW9uIGNyZWF0ZU1lbW9yeUhpc3Rvcnkob3B0aW9ucyA9IHt9KSB7XG4gIGxldCB7IGluaXRpYWxFbnRyaWVzID0gW1wiL1wiXSwgaW5pdGlhbEluZGV4LCB2NUNvbXBhdCA9IGZhbHNlIH0gPSBvcHRpb25zO1xuICBsZXQgZW50cmllcztcbiAgZW50cmllcyA9IGluaXRpYWxFbnRyaWVzLm1hcChcbiAgICAoZW50cnksIGluZGV4MikgPT4gY3JlYXRlTWVtb3J5TG9jYXRpb24oXG4gICAgICBlbnRyeSxcbiAgICAgIHR5cGVvZiBlbnRyeSA9PT0gXCJzdHJpbmdcIiA/IG51bGwgOiBlbnRyeS5zdGF0ZSxcbiAgICAgIGluZGV4MiA9PT0gMCA/IFwiZGVmYXVsdFwiIDogdm9pZCAwXG4gICAgKVxuICApO1xuICBsZXQgaW5kZXggPSBjbGFtcEluZGV4KFxuICAgIGluaXRpYWxJbmRleCA9PSBudWxsID8gZW50cmllcy5sZW5ndGggLSAxIDogaW5pdGlhbEluZGV4XG4gICk7XG4gIGxldCBhY3Rpb24gPSBcIlBPUFwiIC8qIFBvcCAqLztcbiAgbGV0IGxpc3RlbmVyID0gbnVsbDtcbiAgZnVuY3Rpb24gY2xhbXBJbmRleChuKSB7XG4gICAgcmV0dXJuIE1hdGgubWluKE1hdGgubWF4KG4sIDApLCBlbnRyaWVzLmxlbmd0aCAtIDEpO1xuICB9XG4gIGZ1bmN0aW9uIGdldEN1cnJlbnRMb2NhdGlvbigpIHtcbiAgICByZXR1cm4gZW50cmllc1tpbmRleF07XG4gIH1cbiAgZnVuY3Rpb24gY3JlYXRlTWVtb3J5TG9jYXRpb24odG8sIHN0YXRlID0gbnVsbCwga2V5KSB7XG4gICAgbGV0IGxvY2F0aW9uID0gY3JlYXRlTG9jYXRpb24oXG4gICAgICBlbnRyaWVzID8gZ2V0Q3VycmVudExvY2F0aW9uKCkucGF0aG5hbWUgOiBcIi9cIixcbiAgICAgIHRvLFxuICAgICAgc3RhdGUsXG4gICAgICBrZXlcbiAgICApO1xuICAgIHdhcm5pbmcoXG4gICAgICBsb2NhdGlvbi5wYXRobmFtZS5jaGFyQXQoMCkgPT09IFwiL1wiLFxuICAgICAgYHJlbGF0aXZlIHBhdGhuYW1lcyBhcmUgbm90IHN1cHBvcnRlZCBpbiBtZW1vcnkgaGlzdG9yeTogJHtKU09OLnN0cmluZ2lmeShcbiAgICAgICAgdG9cbiAgICAgICl9YFxuICAgICk7XG4gICAgcmV0dXJuIGxvY2F0aW9uO1xuICB9XG4gIGZ1bmN0aW9uIGNyZWF0ZUhyZWYyKHRvKSB7XG4gICAgcmV0dXJuIHR5cGVvZiB0byA9PT0gXCJzdHJpbmdcIiA/IHRvIDogY3JlYXRlUGF0aCh0byk7XG4gIH1cbiAgbGV0IGhpc3RvcnkgPSB7XG4gICAgZ2V0IGluZGV4KCkge1xuICAgICAgcmV0dXJuIGluZGV4O1xuICAgIH0sXG4gICAgZ2V0IGFjdGlvbigpIHtcbiAgICAgIHJldHVybiBhY3Rpb247XG4gICAgfSxcbiAgICBnZXQgbG9jYXRpb24oKSB7XG4gICAgICByZXR1cm4gZ2V0Q3VycmVudExvY2F0aW9uKCk7XG4gICAgfSxcbiAgICBjcmVhdGVIcmVmOiBjcmVhdGVIcmVmMixcbiAgICBjcmVhdGVVUkwodG8pIHtcbiAgICAgIHJldHVybiBuZXcgVVJMKGNyZWF0ZUhyZWYyKHRvKSwgXCJodHRwOi8vbG9jYWxob3N0XCIpO1xuICAgIH0sXG4gICAgZW5jb2RlTG9jYXRpb24odG8pIHtcbiAgICAgIGxldCBwYXRoID0gdHlwZW9mIHRvID09PSBcInN0cmluZ1wiID8gcGFyc2VQYXRoKHRvKSA6IHRvO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcGF0aG5hbWU6IHBhdGgucGF0aG5hbWUgfHwgXCJcIixcbiAgICAgICAgc2VhcmNoOiBwYXRoLnNlYXJjaCB8fCBcIlwiLFxuICAgICAgICBoYXNoOiBwYXRoLmhhc2ggfHwgXCJcIlxuICAgICAgfTtcbiAgICB9LFxuICAgIHB1c2godG8sIHN0YXRlKSB7XG4gICAgICBhY3Rpb24gPSBcIlBVU0hcIiAvKiBQdXNoICovO1xuICAgICAgbGV0IG5leHRMb2NhdGlvbiA9IGNyZWF0ZU1lbW9yeUxvY2F0aW9uKHRvLCBzdGF0ZSk7XG4gICAgICBpbmRleCArPSAxO1xuICAgICAgZW50cmllcy5zcGxpY2UoaW5kZXgsIGVudHJpZXMubGVuZ3RoLCBuZXh0TG9jYXRpb24pO1xuICAgICAgaWYgKHY1Q29tcGF0ICYmIGxpc3RlbmVyKSB7XG4gICAgICAgIGxpc3RlbmVyKHsgYWN0aW9uLCBsb2NhdGlvbjogbmV4dExvY2F0aW9uLCBkZWx0YTogMSB9KTtcbiAgICAgIH1cbiAgICB9LFxuICAgIHJlcGxhY2UodG8sIHN0YXRlKSB7XG4gICAgICBhY3Rpb24gPSBcIlJFUExBQ0VcIiAvKiBSZXBsYWNlICovO1xuICAgICAgbGV0IG5leHRMb2NhdGlvbiA9IGNyZWF0ZU1lbW9yeUxvY2F0aW9uKHRvLCBzdGF0ZSk7XG4gICAgICBlbnRyaWVzW2luZGV4XSA9IG5leHRMb2NhdGlvbjtcbiAgICAgIGlmICh2NUNvbXBhdCAmJiBsaXN0ZW5lcikge1xuICAgICAgICBsaXN0ZW5lcih7IGFjdGlvbiwgbG9jYXRpb246IG5leHRMb2NhdGlvbiwgZGVsdGE6IDAgfSk7XG4gICAgICB9XG4gICAgfSxcbiAgICBnbyhkZWx0YSkge1xuICAgICAgYWN0aW9uID0gXCJQT1BcIiAvKiBQb3AgKi87XG4gICAgICBsZXQgbmV4dEluZGV4ID0gY2xhbXBJbmRleChpbmRleCArIGRlbHRhKTtcbiAgICAgIGxldCBuZXh0TG9jYXRpb24gPSBlbnRyaWVzW25leHRJbmRleF07XG4gICAgICBpbmRleCA9IG5leHRJbmRleDtcbiAgICAgIGlmIChsaXN0ZW5lcikge1xuICAgICAgICBsaXN0ZW5lcih7IGFjdGlvbiwgbG9jYXRpb246IG5leHRMb2NhdGlvbiwgZGVsdGEgfSk7XG4gICAgICB9XG4gICAgfSxcbiAgICBsaXN0ZW4oZm4pIHtcbiAgICAgIGxpc3RlbmVyID0gZm47XG4gICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICBsaXN0ZW5lciA9IG51bGw7XG4gICAgICB9O1xuICAgIH1cbiAgfTtcbiAgcmV0dXJuIGhpc3Rvcnk7XG59XG5mdW5jdGlvbiBjcmVhdGVCcm93c2VySGlzdG9yeShvcHRpb25zID0ge30pIHtcbiAgZnVuY3Rpb24gY3JlYXRlQnJvd3NlckxvY2F0aW9uKHdpbmRvdzIsIGdsb2JhbEhpc3RvcnkpIHtcbiAgICBsZXQgeyBwYXRobmFtZSwgc2VhcmNoLCBoYXNoIH0gPSB3aW5kb3cyLmxvY2F0aW9uO1xuICAgIHJldHVybiBjcmVhdGVMb2NhdGlvbihcbiAgICAgIFwiXCIsXG4gICAgICB7IHBhdGhuYW1lLCBzZWFyY2gsIGhhc2ggfSxcbiAgICAgIC8vIHN0YXRlIGRlZmF1bHRzIHRvIGBudWxsYCBiZWNhdXNlIGB3aW5kb3cuaGlzdG9yeS5zdGF0ZWAgZG9lc1xuICAgICAgZ2xvYmFsSGlzdG9yeS5zdGF0ZSAmJiBnbG9iYWxIaXN0b3J5LnN0YXRlLnVzciB8fCBudWxsLFxuICAgICAgZ2xvYmFsSGlzdG9yeS5zdGF0ZSAmJiBnbG9iYWxIaXN0b3J5LnN0YXRlLmtleSB8fCBcImRlZmF1bHRcIlxuICAgICk7XG4gIH1cbiAgZnVuY3Rpb24gY3JlYXRlQnJvd3NlckhyZWYod2luZG93MiwgdG8pIHtcbiAgICByZXR1cm4gdHlwZW9mIHRvID09PSBcInN0cmluZ1wiID8gdG8gOiBjcmVhdGVQYXRoKHRvKTtcbiAgfVxuICByZXR1cm4gZ2V0VXJsQmFzZWRIaXN0b3J5KFxuICAgIGNyZWF0ZUJyb3dzZXJMb2NhdGlvbixcbiAgICBjcmVhdGVCcm93c2VySHJlZixcbiAgICBudWxsLFxuICAgIG9wdGlvbnNcbiAgKTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUhhc2hIaXN0b3J5KG9wdGlvbnMgPSB7fSkge1xuICBmdW5jdGlvbiBjcmVhdGVIYXNoTG9jYXRpb24od2luZG93MiwgZ2xvYmFsSGlzdG9yeSkge1xuICAgIGxldCB7XG4gICAgICBwYXRobmFtZSA9IFwiL1wiLFxuICAgICAgc2VhcmNoID0gXCJcIixcbiAgICAgIGhhc2ggPSBcIlwiXG4gICAgfSA9IHBhcnNlUGF0aCh3aW5kb3cyLmxvY2F0aW9uLmhhc2guc3Vic3RyaW5nKDEpKTtcbiAgICBpZiAoIXBhdGhuYW1lLnN0YXJ0c1dpdGgoXCIvXCIpICYmICFwYXRobmFtZS5zdGFydHNXaXRoKFwiLlwiKSkge1xuICAgICAgcGF0aG5hbWUgPSBcIi9cIiArIHBhdGhuYW1lO1xuICAgIH1cbiAgICByZXR1cm4gY3JlYXRlTG9jYXRpb24oXG4gICAgICBcIlwiLFxuICAgICAgeyBwYXRobmFtZSwgc2VhcmNoLCBoYXNoIH0sXG4gICAgICAvLyBzdGF0ZSBkZWZhdWx0cyB0byBgbnVsbGAgYmVjYXVzZSBgd2luZG93Lmhpc3Rvcnkuc3RhdGVgIGRvZXNcbiAgICAgIGdsb2JhbEhpc3Rvcnkuc3RhdGUgJiYgZ2xvYmFsSGlzdG9yeS5zdGF0ZS51c3IgfHwgbnVsbCxcbiAgICAgIGdsb2JhbEhpc3Rvcnkuc3RhdGUgJiYgZ2xvYmFsSGlzdG9yeS5zdGF0ZS5rZXkgfHwgXCJkZWZhdWx0XCJcbiAgICApO1xuICB9XG4gIGZ1bmN0aW9uIGNyZWF0ZUhhc2hIcmVmKHdpbmRvdzIsIHRvKSB7XG4gICAgbGV0IGJhc2UgPSB3aW5kb3cyLmRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoXCJiYXNlXCIpO1xuICAgIGxldCBocmVmID0gXCJcIjtcbiAgICBpZiAoYmFzZSAmJiBiYXNlLmdldEF0dHJpYnV0ZShcImhyZWZcIikpIHtcbiAgICAgIGxldCB1cmwgPSB3aW5kb3cyLmxvY2F0aW9uLmhyZWY7XG4gICAgICBsZXQgaGFzaEluZGV4ID0gdXJsLmluZGV4T2YoXCIjXCIpO1xuICAgICAgaHJlZiA9IGhhc2hJbmRleCA9PT0gLTEgPyB1cmwgOiB1cmwuc2xpY2UoMCwgaGFzaEluZGV4KTtcbiAgICB9XG4gICAgcmV0dXJuIGhyZWYgKyBcIiNcIiArICh0eXBlb2YgdG8gPT09IFwic3RyaW5nXCIgPyB0byA6IGNyZWF0ZVBhdGgodG8pKTtcbiAgfVxuICBmdW5jdGlvbiB2YWxpZGF0ZUhhc2hMb2NhdGlvbihsb2NhdGlvbiwgdG8pIHtcbiAgICB3YXJuaW5nKFxuICAgICAgbG9jYXRpb24ucGF0aG5hbWUuY2hhckF0KDApID09PSBcIi9cIixcbiAgICAgIGByZWxhdGl2ZSBwYXRobmFtZXMgYXJlIG5vdCBzdXBwb3J0ZWQgaW4gaGFzaCBoaXN0b3J5LnB1c2goJHtKU09OLnN0cmluZ2lmeShcbiAgICAgICAgdG9cbiAgICAgICl9KWBcbiAgICApO1xuICB9XG4gIHJldHVybiBnZXRVcmxCYXNlZEhpc3RvcnkoXG4gICAgY3JlYXRlSGFzaExvY2F0aW9uLFxuICAgIGNyZWF0ZUhhc2hIcmVmLFxuICAgIHZhbGlkYXRlSGFzaExvY2F0aW9uLFxuICAgIG9wdGlvbnNcbiAgKTtcbn1cbmZ1bmN0aW9uIGludmFyaWFudCh2YWx1ZSwgbWVzc2FnZSkge1xuICBpZiAodmFsdWUgPT09IGZhbHNlIHx8IHZhbHVlID09PSBudWxsIHx8IHR5cGVvZiB2YWx1ZSA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgIHRocm93IG5ldyBFcnJvcihtZXNzYWdlKTtcbiAgfVxufVxuZnVuY3Rpb24gd2FybmluZyhjb25kLCBtZXNzYWdlKSB7XG4gIGlmICghY29uZCkge1xuICAgIGlmICh0eXBlb2YgY29uc29sZSAhPT0gXCJ1bmRlZmluZWRcIikgY29uc29sZS53YXJuKG1lc3NhZ2UpO1xuICAgIHRyeSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gY3JlYXRlS2V5KCkge1xuICByZXR1cm4gTWF0aC5yYW5kb20oKS50b1N0cmluZygzNikuc3Vic3RyaW5nKDIsIDEwKTtcbn1cbmZ1bmN0aW9uIGdldEhpc3RvcnlTdGF0ZShsb2NhdGlvbiwgaW5kZXgpIHtcbiAgcmV0dXJuIHtcbiAgICB1c3I6IGxvY2F0aW9uLnN0YXRlLFxuICAgIGtleTogbG9jYXRpb24ua2V5LFxuICAgIGlkeDogaW5kZXhcbiAgfTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUxvY2F0aW9uKGN1cnJlbnQsIHRvLCBzdGF0ZSA9IG51bGwsIGtleSkge1xuICBsZXQgbG9jYXRpb24gPSB7XG4gICAgcGF0aG5hbWU6IHR5cGVvZiBjdXJyZW50ID09PSBcInN0cmluZ1wiID8gY3VycmVudCA6IGN1cnJlbnQucGF0aG5hbWUsXG4gICAgc2VhcmNoOiBcIlwiLFxuICAgIGhhc2g6IFwiXCIsXG4gICAgLi4udHlwZW9mIHRvID09PSBcInN0cmluZ1wiID8gcGFyc2VQYXRoKHRvKSA6IHRvLFxuICAgIHN0YXRlLFxuICAgIC8vIFRPRE86IFRoaXMgY291bGQgYmUgY2xlYW5lZCB1cC4gIHB1c2gvcmVwbGFjZSBzaG91bGQgcHJvYmFibHkganVzdCB0YWtlXG4gICAgLy8gZnVsbCBMb2NhdGlvbnMgbm93IGFuZCBhdm9pZCB0aGUgbmVlZCB0byBydW4gdGhyb3VnaCB0aGlzIGZsb3cgYXQgYWxsXG4gICAgLy8gQnV0IHRoYXQncyBhIHByZXR0eSBiaWcgcmVmYWN0b3IgdG8gdGhlIGN1cnJlbnQgdGVzdCBzdWl0ZSBzbyBnb2luZyB0b1xuICAgIC8vIGtlZXAgYXMgaXMgZm9yIHRoZSB0aW1lIGJlaW5nIGFuZCBqdXN0IGxldCBhbnkgaW5jb21pbmcga2V5cyB0YWtlIHByZWNlZGVuY2VcbiAgICBrZXk6IHRvICYmIHRvLmtleSB8fCBrZXkgfHwgY3JlYXRlS2V5KClcbiAgfTtcbiAgcmV0dXJuIGxvY2F0aW9uO1xufVxuZnVuY3Rpb24gY3JlYXRlUGF0aCh7XG4gIHBhdGhuYW1lID0gXCIvXCIsXG4gIHNlYXJjaCA9IFwiXCIsXG4gIGhhc2ggPSBcIlwiXG59KSB7XG4gIGlmIChzZWFyY2ggJiYgc2VhcmNoICE9PSBcIj9cIilcbiAgICBwYXRobmFtZSArPSBzZWFyY2guY2hhckF0KDApID09PSBcIj9cIiA/IHNlYXJjaCA6IFwiP1wiICsgc2VhcmNoO1xuICBpZiAoaGFzaCAmJiBoYXNoICE9PSBcIiNcIilcbiAgICBwYXRobmFtZSArPSBoYXNoLmNoYXJBdCgwKSA9PT0gXCIjXCIgPyBoYXNoIDogXCIjXCIgKyBoYXNoO1xuICByZXR1cm4gcGF0aG5hbWU7XG59XG5mdW5jdGlvbiBwYXJzZVBhdGgocGF0aCkge1xuICBsZXQgcGFyc2VkUGF0aCA9IHt9O1xuICBpZiAocGF0aCkge1xuICAgIGxldCBoYXNoSW5kZXggPSBwYXRoLmluZGV4T2YoXCIjXCIpO1xuICAgIGlmIChoYXNoSW5kZXggPj0gMCkge1xuICAgICAgcGFyc2VkUGF0aC5oYXNoID0gcGF0aC5zdWJzdHJpbmcoaGFzaEluZGV4KTtcbiAgICAgIHBhdGggPSBwYXRoLnN1YnN0cmluZygwLCBoYXNoSW5kZXgpO1xuICAgIH1cbiAgICBsZXQgc2VhcmNoSW5kZXggPSBwYXRoLmluZGV4T2YoXCI/XCIpO1xuICAgIGlmIChzZWFyY2hJbmRleCA+PSAwKSB7XG4gICAgICBwYXJzZWRQYXRoLnNlYXJjaCA9IHBhdGguc3Vic3RyaW5nKHNlYXJjaEluZGV4KTtcbiAgICAgIHBhdGggPSBwYXRoLnN1YnN0cmluZygwLCBzZWFyY2hJbmRleCk7XG4gICAgfVxuICAgIGlmIChwYXRoKSB7XG4gICAgICBwYXJzZWRQYXRoLnBhdGhuYW1lID0gcGF0aDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHBhcnNlZFBhdGg7XG59XG5mdW5jdGlvbiBnZXRVcmxCYXNlZEhpc3RvcnkoZ2V0TG9jYXRpb24sIGNyZWF0ZUhyZWYyLCB2YWxpZGF0ZUxvY2F0aW9uLCBvcHRpb25zID0ge30pIHtcbiAgbGV0IHsgd2luZG93OiB3aW5kb3cyID0gZG9jdW1lbnQuZGVmYXVsdFZpZXcsIHY1Q29tcGF0ID0gZmFsc2UgfSA9IG9wdGlvbnM7XG4gIGxldCBnbG9iYWxIaXN0b3J5ID0gd2luZG93Mi5oaXN0b3J5O1xuICBsZXQgYWN0aW9uID0gXCJQT1BcIiAvKiBQb3AgKi87XG4gIGxldCBsaXN0ZW5lciA9IG51bGw7XG4gIGxldCBpbmRleCA9IGdldEluZGV4KCk7XG4gIGlmIChpbmRleCA9PSBudWxsKSB7XG4gICAgaW5kZXggPSAwO1xuICAgIGdsb2JhbEhpc3RvcnkucmVwbGFjZVN0YXRlKHsgLi4uZ2xvYmFsSGlzdG9yeS5zdGF0ZSwgaWR4OiBpbmRleCB9LCBcIlwiKTtcbiAgfVxuICBmdW5jdGlvbiBnZXRJbmRleCgpIHtcbiAgICBsZXQgc3RhdGUgPSBnbG9iYWxIaXN0b3J5LnN0YXRlIHx8IHsgaWR4OiBudWxsIH07XG4gICAgcmV0dXJuIHN0YXRlLmlkeDtcbiAgfVxuICBmdW5jdGlvbiBoYW5kbGVQb3AoKSB7XG4gICAgYWN0aW9uID0gXCJQT1BcIiAvKiBQb3AgKi87XG4gICAgbGV0IG5leHRJbmRleCA9IGdldEluZGV4KCk7XG4gICAgbGV0IGRlbHRhID0gbmV4dEluZGV4ID09IG51bGwgPyBudWxsIDogbmV4dEluZGV4IC0gaW5kZXg7XG4gICAgaW5kZXggPSBuZXh0SW5kZXg7XG4gICAgaWYgKGxpc3RlbmVyKSB7XG4gICAgICBsaXN0ZW5lcih7IGFjdGlvbiwgbG9jYXRpb246IGhpc3RvcnkubG9jYXRpb24sIGRlbHRhIH0pO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBwdXNoKHRvLCBzdGF0ZSkge1xuICAgIGFjdGlvbiA9IFwiUFVTSFwiIC8qIFB1c2ggKi87XG4gICAgbGV0IGxvY2F0aW9uID0gY3JlYXRlTG9jYXRpb24oaGlzdG9yeS5sb2NhdGlvbiwgdG8sIHN0YXRlKTtcbiAgICBpZiAodmFsaWRhdGVMb2NhdGlvbikgdmFsaWRhdGVMb2NhdGlvbihsb2NhdGlvbiwgdG8pO1xuICAgIGluZGV4ID0gZ2V0SW5kZXgoKSArIDE7XG4gICAgbGV0IGhpc3RvcnlTdGF0ZSA9IGdldEhpc3RvcnlTdGF0ZShsb2NhdGlvbiwgaW5kZXgpO1xuICAgIGxldCB1cmwgPSBoaXN0b3J5LmNyZWF0ZUhyZWYobG9jYXRpb24pO1xuICAgIHRyeSB7XG4gICAgICBnbG9iYWxIaXN0b3J5LnB1c2hTdGF0ZShoaXN0b3J5U3RhdGUsIFwiXCIsIHVybCk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIERPTUV4Y2VwdGlvbiAmJiBlcnJvci5uYW1lID09PSBcIkRhdGFDbG9uZUVycm9yXCIpIHtcbiAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICB9XG4gICAgICB3aW5kb3cyLmxvY2F0aW9uLmFzc2lnbih1cmwpO1xuICAgIH1cbiAgICBpZiAodjVDb21wYXQgJiYgbGlzdGVuZXIpIHtcbiAgICAgIGxpc3RlbmVyKHsgYWN0aW9uLCBsb2NhdGlvbjogaGlzdG9yeS5sb2NhdGlvbiwgZGVsdGE6IDEgfSk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIHJlcGxhY2UyKHRvLCBzdGF0ZSkge1xuICAgIGFjdGlvbiA9IFwiUkVQTEFDRVwiIC8qIFJlcGxhY2UgKi87XG4gICAgbGV0IGxvY2F0aW9uID0gY3JlYXRlTG9jYXRpb24oaGlzdG9yeS5sb2NhdGlvbiwgdG8sIHN0YXRlKTtcbiAgICBpZiAodmFsaWRhdGVMb2NhdGlvbikgdmFsaWRhdGVMb2NhdGlvbihsb2NhdGlvbiwgdG8pO1xuICAgIGluZGV4ID0gZ2V0SW5kZXgoKTtcbiAgICBsZXQgaGlzdG9yeVN0YXRlID0gZ2V0SGlzdG9yeVN0YXRlKGxvY2F0aW9uLCBpbmRleCk7XG4gICAgbGV0IHVybCA9IGhpc3RvcnkuY3JlYXRlSHJlZihsb2NhdGlvbik7XG4gICAgZ2xvYmFsSGlzdG9yeS5yZXBsYWNlU3RhdGUoaGlzdG9yeVN0YXRlLCBcIlwiLCB1cmwpO1xuICAgIGlmICh2NUNvbXBhdCAmJiBsaXN0ZW5lcikge1xuICAgICAgbGlzdGVuZXIoeyBhY3Rpb24sIGxvY2F0aW9uOiBoaXN0b3J5LmxvY2F0aW9uLCBkZWx0YTogMCB9KTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gY3JlYXRlVVJMKHRvKSB7XG4gICAgbGV0IGJhc2UgPSB3aW5kb3cyLmxvY2F0aW9uLm9yaWdpbiAhPT0gXCJudWxsXCIgPyB3aW5kb3cyLmxvY2F0aW9uLm9yaWdpbiA6IHdpbmRvdzIubG9jYXRpb24uaHJlZjtcbiAgICBsZXQgaHJlZiA9IHR5cGVvZiB0byA9PT0gXCJzdHJpbmdcIiA/IHRvIDogY3JlYXRlUGF0aCh0byk7XG4gICAgaHJlZiA9IGhyZWYucmVwbGFjZSgvICQvLCBcIiUyMFwiKTtcbiAgICBpbnZhcmlhbnQoXG4gICAgICBiYXNlLFxuICAgICAgYE5vIHdpbmRvdy5sb2NhdGlvbi4ob3JpZ2lufGhyZWYpIGF2YWlsYWJsZSB0byBjcmVhdGUgVVJMIGZvciBocmVmOiAke2hyZWZ9YFxuICAgICk7XG4gICAgcmV0dXJuIG5ldyBVUkwoaHJlZiwgYmFzZSk7XG4gIH1cbiAgbGV0IGhpc3RvcnkgPSB7XG4gICAgZ2V0IGFjdGlvbigpIHtcbiAgICAgIHJldHVybiBhY3Rpb247XG4gICAgfSxcbiAgICBnZXQgbG9jYXRpb24oKSB7XG4gICAgICByZXR1cm4gZ2V0TG9jYXRpb24od2luZG93MiwgZ2xvYmFsSGlzdG9yeSk7XG4gICAgfSxcbiAgICBsaXN0ZW4oZm4pIHtcbiAgICAgIGlmIChsaXN0ZW5lcikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJBIGhpc3Rvcnkgb25seSBhY2NlcHRzIG9uZSBhY3RpdmUgbGlzdGVuZXJcIik7XG4gICAgICB9XG4gICAgICB3aW5kb3cyLmFkZEV2ZW50TGlzdGVuZXIoUG9wU3RhdGVFdmVudFR5cGUsIGhhbmRsZVBvcCk7XG4gICAgICBsaXN0ZW5lciA9IGZuO1xuICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgd2luZG93Mi5yZW1vdmVFdmVudExpc3RlbmVyKFBvcFN0YXRlRXZlbnRUeXBlLCBoYW5kbGVQb3ApO1xuICAgICAgICBsaXN0ZW5lciA9IG51bGw7XG4gICAgICB9O1xuICAgIH0sXG4gICAgY3JlYXRlSHJlZih0bykge1xuICAgICAgcmV0dXJuIGNyZWF0ZUhyZWYyKHdpbmRvdzIsIHRvKTtcbiAgICB9LFxuICAgIGNyZWF0ZVVSTCxcbiAgICBlbmNvZGVMb2NhdGlvbih0bykge1xuICAgICAgbGV0IHVybCA9IGNyZWF0ZVVSTCh0byk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBwYXRobmFtZTogdXJsLnBhdGhuYW1lLFxuICAgICAgICBzZWFyY2g6IHVybC5zZWFyY2gsXG4gICAgICAgIGhhc2g6IHVybC5oYXNoXG4gICAgICB9O1xuICAgIH0sXG4gICAgcHVzaCxcbiAgICByZXBsYWNlOiByZXBsYWNlMixcbiAgICBnbyhuKSB7XG4gICAgICByZXR1cm4gZ2xvYmFsSGlzdG9yeS5nbyhuKTtcbiAgICB9XG4gIH07XG4gIHJldHVybiBoaXN0b3J5O1xufVxuXG4vLyBsaWIvcm91dGVyL3V0aWxzLnRzXG52YXIgaW1tdXRhYmxlUm91dGVLZXlzID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoW1xuICBcImxhenlcIixcbiAgXCJjYXNlU2Vuc2l0aXZlXCIsXG4gIFwicGF0aFwiLFxuICBcImlkXCIsXG4gIFwiaW5kZXhcIixcbiAgXCJjaGlsZHJlblwiXG5dKTtcbmZ1bmN0aW9uIGlzSW5kZXhSb3V0ZShyb3V0ZSkge1xuICByZXR1cm4gcm91dGUuaW5kZXggPT09IHRydWU7XG59XG5mdW5jdGlvbiBjb252ZXJ0Um91dGVzVG9EYXRhUm91dGVzKHJvdXRlcywgbWFwUm91dGVQcm9wZXJ0aWVzMiwgcGFyZW50UGF0aCA9IFtdLCBtYW5pZmVzdCA9IHt9KSB7XG4gIHJldHVybiByb3V0ZXMubWFwKChyb3V0ZSwgaW5kZXgpID0+IHtcbiAgICBsZXQgdHJlZVBhdGggPSBbLi4ucGFyZW50UGF0aCwgU3RyaW5nKGluZGV4KV07XG4gICAgbGV0IGlkID0gdHlwZW9mIHJvdXRlLmlkID09PSBcInN0cmluZ1wiID8gcm91dGUuaWQgOiB0cmVlUGF0aC5qb2luKFwiLVwiKTtcbiAgICBpbnZhcmlhbnQoXG4gICAgICByb3V0ZS5pbmRleCAhPT0gdHJ1ZSB8fCAhcm91dGUuY2hpbGRyZW4sXG4gICAgICBgQ2Fubm90IHNwZWNpZnkgY2hpbGRyZW4gb24gYW4gaW5kZXggcm91dGVgXG4gICAgKTtcbiAgICBpbnZhcmlhbnQoXG4gICAgICAhbWFuaWZlc3RbaWRdLFxuICAgICAgYEZvdW5kIGEgcm91dGUgaWQgY29sbGlzaW9uIG9uIGlkIFwiJHtpZH1cIi4gIFJvdXRlIGlkJ3MgbXVzdCBiZSBnbG9iYWxseSB1bmlxdWUgd2l0aGluIERhdGEgUm91dGVyIHVzYWdlc2BcbiAgICApO1xuICAgIGlmIChpc0luZGV4Um91dGUocm91dGUpKSB7XG4gICAgICBsZXQgaW5kZXhSb3V0ZSA9IHtcbiAgICAgICAgLi4ucm91dGUsXG4gICAgICAgIC4uLm1hcFJvdXRlUHJvcGVydGllczIocm91dGUpLFxuICAgICAgICBpZFxuICAgICAgfTtcbiAgICAgIG1hbmlmZXN0W2lkXSA9IGluZGV4Um91dGU7XG4gICAgICByZXR1cm4gaW5kZXhSb3V0ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgbGV0IHBhdGhPckxheW91dFJvdXRlID0ge1xuICAgICAgICAuLi5yb3V0ZSxcbiAgICAgICAgLi4ubWFwUm91dGVQcm9wZXJ0aWVzMihyb3V0ZSksXG4gICAgICAgIGlkLFxuICAgICAgICBjaGlsZHJlbjogdm9pZCAwXG4gICAgICB9O1xuICAgICAgbWFuaWZlc3RbaWRdID0gcGF0aE9yTGF5b3V0Um91dGU7XG4gICAgICBpZiAocm91dGUuY2hpbGRyZW4pIHtcbiAgICAgICAgcGF0aE9yTGF5b3V0Um91dGUuY2hpbGRyZW4gPSBjb252ZXJ0Um91dGVzVG9EYXRhUm91dGVzKFxuICAgICAgICAgIHJvdXRlLmNoaWxkcmVuLFxuICAgICAgICAgIG1hcFJvdXRlUHJvcGVydGllczIsXG4gICAgICAgICAgdHJlZVBhdGgsXG4gICAgICAgICAgbWFuaWZlc3RcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBwYXRoT3JMYXlvdXRSb3V0ZTtcbiAgICB9XG4gIH0pO1xufVxuZnVuY3Rpb24gbWF0Y2hSb3V0ZXMocm91dGVzLCBsb2NhdGlvbkFyZywgYmFzZW5hbWUgPSBcIi9cIikge1xuICByZXR1cm4gbWF0Y2hSb3V0ZXNJbXBsKHJvdXRlcywgbG9jYXRpb25BcmcsIGJhc2VuYW1lLCBmYWxzZSk7XG59XG5mdW5jdGlvbiBtYXRjaFJvdXRlc0ltcGwocm91dGVzLCBsb2NhdGlvbkFyZywgYmFzZW5hbWUsIGFsbG93UGFydGlhbCkge1xuICBsZXQgbG9jYXRpb24gPSB0eXBlb2YgbG9jYXRpb25BcmcgPT09IFwic3RyaW5nXCIgPyBwYXJzZVBhdGgobG9jYXRpb25BcmcpIDogbG9jYXRpb25Bcmc7XG4gIGxldCBwYXRobmFtZSA9IHN0cmlwQmFzZW5hbWUobG9jYXRpb24ucGF0aG5hbWUgfHwgXCIvXCIsIGJhc2VuYW1lKTtcbiAgaWYgKHBhdGhuYW1lID09IG51bGwpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBsZXQgYnJhbmNoZXMgPSBmbGF0dGVuUm91dGVzKHJvdXRlcyk7XG4gIHJhbmtSb3V0ZUJyYW5jaGVzKGJyYW5jaGVzKTtcbiAgbGV0IG1hdGNoZXMgPSBudWxsO1xuICBmb3IgKGxldCBpID0gMDsgbWF0Y2hlcyA9PSBudWxsICYmIGkgPCBicmFuY2hlcy5sZW5ndGg7ICsraSkge1xuICAgIGxldCBkZWNvZGVkID0gZGVjb2RlUGF0aChwYXRobmFtZSk7XG4gICAgbWF0Y2hlcyA9IG1hdGNoUm91dGVCcmFuY2goXG4gICAgICBicmFuY2hlc1tpXSxcbiAgICAgIGRlY29kZWQsXG4gICAgICBhbGxvd1BhcnRpYWxcbiAgICApO1xuICB9XG4gIHJldHVybiBtYXRjaGVzO1xufVxuZnVuY3Rpb24gY29udmVydFJvdXRlTWF0Y2hUb1VpTWF0Y2gobWF0Y2gsIGxvYWRlckRhdGEpIHtcbiAgbGV0IHsgcm91dGUsIHBhdGhuYW1lLCBwYXJhbXMgfSA9IG1hdGNoO1xuICByZXR1cm4ge1xuICAgIGlkOiByb3V0ZS5pZCxcbiAgICBwYXRobmFtZSxcbiAgICBwYXJhbXMsXG4gICAgZGF0YTogbG9hZGVyRGF0YVtyb3V0ZS5pZF0sXG4gICAgaGFuZGxlOiByb3V0ZS5oYW5kbGVcbiAgfTtcbn1cbmZ1bmN0aW9uIGZsYXR0ZW5Sb3V0ZXMocm91dGVzLCBicmFuY2hlcyA9IFtdLCBwYXJlbnRzTWV0YSA9IFtdLCBwYXJlbnRQYXRoID0gXCJcIikge1xuICBsZXQgZmxhdHRlblJvdXRlID0gKHJvdXRlLCBpbmRleCwgcmVsYXRpdmVQYXRoKSA9PiB7XG4gICAgbGV0IG1ldGEgPSB7XG4gICAgICByZWxhdGl2ZVBhdGg6IHJlbGF0aXZlUGF0aCA9PT0gdm9pZCAwID8gcm91dGUucGF0aCB8fCBcIlwiIDogcmVsYXRpdmVQYXRoLFxuICAgICAgY2FzZVNlbnNpdGl2ZTogcm91dGUuY2FzZVNlbnNpdGl2ZSA9PT0gdHJ1ZSxcbiAgICAgIGNoaWxkcmVuSW5kZXg6IGluZGV4LFxuICAgICAgcm91dGVcbiAgICB9O1xuICAgIGlmIChtZXRhLnJlbGF0aXZlUGF0aC5zdGFydHNXaXRoKFwiL1wiKSkge1xuICAgICAgaW52YXJpYW50KFxuICAgICAgICBtZXRhLnJlbGF0aXZlUGF0aC5zdGFydHNXaXRoKHBhcmVudFBhdGgpLFxuICAgICAgICBgQWJzb2x1dGUgcm91dGUgcGF0aCBcIiR7bWV0YS5yZWxhdGl2ZVBhdGh9XCIgbmVzdGVkIHVuZGVyIHBhdGggXCIke3BhcmVudFBhdGh9XCIgaXMgbm90IHZhbGlkLiBBbiBhYnNvbHV0ZSBjaGlsZCByb3V0ZSBwYXRoIG11c3Qgc3RhcnQgd2l0aCB0aGUgY29tYmluZWQgcGF0aCBvZiBhbGwgaXRzIHBhcmVudCByb3V0ZXMuYFxuICAgICAgKTtcbiAgICAgIG1ldGEucmVsYXRpdmVQYXRoID0gbWV0YS5yZWxhdGl2ZVBhdGguc2xpY2UocGFyZW50UGF0aC5sZW5ndGgpO1xuICAgIH1cbiAgICBsZXQgcGF0aCA9IGpvaW5QYXRocyhbcGFyZW50UGF0aCwgbWV0YS5yZWxhdGl2ZVBhdGhdKTtcbiAgICBsZXQgcm91dGVzTWV0YSA9IHBhcmVudHNNZXRhLmNvbmNhdChtZXRhKTtcbiAgICBpZiAocm91dGUuY2hpbGRyZW4gJiYgcm91dGUuY2hpbGRyZW4ubGVuZ3RoID4gMCkge1xuICAgICAgaW52YXJpYW50KFxuICAgICAgICAvLyBPdXIgdHlwZXMga25vdyBiZXR0ZXIsIGJ1dCBydW50aW1lIEpTIG1heSBub3QhXG4gICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgcm91dGUuaW5kZXggIT09IHRydWUsXG4gICAgICAgIGBJbmRleCByb3V0ZXMgbXVzdCBub3QgaGF2ZSBjaGlsZCByb3V0ZXMuIFBsZWFzZSByZW1vdmUgYWxsIGNoaWxkIHJvdXRlcyBmcm9tIHJvdXRlIHBhdGggXCIke3BhdGh9XCIuYFxuICAgICAgKTtcbiAgICAgIGZsYXR0ZW5Sb3V0ZXMocm91dGUuY2hpbGRyZW4sIGJyYW5jaGVzLCByb3V0ZXNNZXRhLCBwYXRoKTtcbiAgICB9XG4gICAgaWYgKHJvdXRlLnBhdGggPT0gbnVsbCAmJiAhcm91dGUuaW5kZXgpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgYnJhbmNoZXMucHVzaCh7XG4gICAgICBwYXRoLFxuICAgICAgc2NvcmU6IGNvbXB1dGVTY29yZShwYXRoLCByb3V0ZS5pbmRleCksXG4gICAgICByb3V0ZXNNZXRhXG4gICAgfSk7XG4gIH07XG4gIHJvdXRlcy5mb3JFYWNoKChyb3V0ZSwgaW5kZXgpID0+IHtcbiAgICBpZiAocm91dGUucGF0aCA9PT0gXCJcIiB8fCAhcm91dGUucGF0aD8uaW5jbHVkZXMoXCI/XCIpKSB7XG4gICAgICBmbGF0dGVuUm91dGUocm91dGUsIGluZGV4KTtcbiAgICB9IGVsc2Uge1xuICAgICAgZm9yIChsZXQgZXhwbG9kZWQgb2YgZXhwbG9kZU9wdGlvbmFsU2VnbWVudHMocm91dGUucGF0aCkpIHtcbiAgICAgICAgZmxhdHRlblJvdXRlKHJvdXRlLCBpbmRleCwgZXhwbG9kZWQpO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG4gIHJldHVybiBicmFuY2hlcztcbn1cbmZ1bmN0aW9uIGV4cGxvZGVPcHRpb25hbFNlZ21lbnRzKHBhdGgpIHtcbiAgbGV0IHNlZ21lbnRzID0gcGF0aC5zcGxpdChcIi9cIik7XG4gIGlmIChzZWdtZW50cy5sZW5ndGggPT09IDApIHJldHVybiBbXTtcbiAgbGV0IFtmaXJzdCwgLi4ucmVzdF0gPSBzZWdtZW50cztcbiAgbGV0IGlzT3B0aW9uYWwgPSBmaXJzdC5lbmRzV2l0aChcIj9cIik7XG4gIGxldCByZXF1aXJlZCA9IGZpcnN0LnJlcGxhY2UoL1xcPyQvLCBcIlwiKTtcbiAgaWYgKHJlc3QubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIGlzT3B0aW9uYWwgPyBbcmVxdWlyZWQsIFwiXCJdIDogW3JlcXVpcmVkXTtcbiAgfVxuICBsZXQgcmVzdEV4cGxvZGVkID0gZXhwbG9kZU9wdGlvbmFsU2VnbWVudHMocmVzdC5qb2luKFwiL1wiKSk7XG4gIGxldCByZXN1bHQgPSBbXTtcbiAgcmVzdWx0LnB1c2goXG4gICAgLi4ucmVzdEV4cGxvZGVkLm1hcChcbiAgICAgIChzdWJwYXRoKSA9PiBzdWJwYXRoID09PSBcIlwiID8gcmVxdWlyZWQgOiBbcmVxdWlyZWQsIHN1YnBhdGhdLmpvaW4oXCIvXCIpXG4gICAgKVxuICApO1xuICBpZiAoaXNPcHRpb25hbCkge1xuICAgIHJlc3VsdC5wdXNoKC4uLnJlc3RFeHBsb2RlZCk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdC5tYXAoXG4gICAgKGV4cGxvZGVkKSA9PiBwYXRoLnN0YXJ0c1dpdGgoXCIvXCIpICYmIGV4cGxvZGVkID09PSBcIlwiID8gXCIvXCIgOiBleHBsb2RlZFxuICApO1xufVxuZnVuY3Rpb24gcmFua1JvdXRlQnJhbmNoZXMoYnJhbmNoZXMpIHtcbiAgYnJhbmNoZXMuc29ydChcbiAgICAoYSwgYikgPT4gYS5zY29yZSAhPT0gYi5zY29yZSA/IGIuc2NvcmUgLSBhLnNjb3JlIDogY29tcGFyZUluZGV4ZXMoXG4gICAgICBhLnJvdXRlc01ldGEubWFwKChtZXRhKSA9PiBtZXRhLmNoaWxkcmVuSW5kZXgpLFxuICAgICAgYi5yb3V0ZXNNZXRhLm1hcCgobWV0YSkgPT4gbWV0YS5jaGlsZHJlbkluZGV4KVxuICAgIClcbiAgKTtcbn1cbnZhciBwYXJhbVJlID0gL146W1xcdy1dKyQvO1xudmFyIGR5bmFtaWNTZWdtZW50VmFsdWUgPSAzO1xudmFyIGluZGV4Um91dGVWYWx1ZSA9IDI7XG52YXIgZW1wdHlTZWdtZW50VmFsdWUgPSAxO1xudmFyIHN0YXRpY1NlZ21lbnRWYWx1ZSA9IDEwO1xudmFyIHNwbGF0UGVuYWx0eSA9IC0yO1xudmFyIGlzU3BsYXQgPSAocykgPT4gcyA9PT0gXCIqXCI7XG5mdW5jdGlvbiBjb21wdXRlU2NvcmUocGF0aCwgaW5kZXgpIHtcbiAgbGV0IHNlZ21lbnRzID0gcGF0aC5zcGxpdChcIi9cIik7XG4gIGxldCBpbml0aWFsU2NvcmUgPSBzZWdtZW50cy5sZW5ndGg7XG4gIGlmIChzZWdtZW50cy5zb21lKGlzU3BsYXQpKSB7XG4gICAgaW5pdGlhbFNjb3JlICs9IHNwbGF0UGVuYWx0eTtcbiAgfVxuICBpZiAoaW5kZXgpIHtcbiAgICBpbml0aWFsU2NvcmUgKz0gaW5kZXhSb3V0ZVZhbHVlO1xuICB9XG4gIHJldHVybiBzZWdtZW50cy5maWx0ZXIoKHMpID0+ICFpc1NwbGF0KHMpKS5yZWR1Y2UoXG4gICAgKHNjb3JlLCBzZWdtZW50KSA9PiBzY29yZSArIChwYXJhbVJlLnRlc3Qoc2VnbWVudCkgPyBkeW5hbWljU2VnbWVudFZhbHVlIDogc2VnbWVudCA9PT0gXCJcIiA/IGVtcHR5U2VnbWVudFZhbHVlIDogc3RhdGljU2VnbWVudFZhbHVlKSxcbiAgICBpbml0aWFsU2NvcmVcbiAgKTtcbn1cbmZ1bmN0aW9uIGNvbXBhcmVJbmRleGVzKGEsIGIpIHtcbiAgbGV0IHNpYmxpbmdzID0gYS5sZW5ndGggPT09IGIubGVuZ3RoICYmIGEuc2xpY2UoMCwgLTEpLmV2ZXJ5KChuLCBpKSA9PiBuID09PSBiW2ldKTtcbiAgcmV0dXJuIHNpYmxpbmdzID8gKFxuICAgIC8vIElmIHR3byByb3V0ZXMgYXJlIHNpYmxpbmdzLCB3ZSBzaG91bGQgdHJ5IHRvIG1hdGNoIHRoZSBlYXJsaWVyIHNpYmxpbmdcbiAgICAvLyBmaXJzdC4gVGhpcyBhbGxvd3MgcGVvcGxlIHRvIGhhdmUgZmluZS1ncmFpbmVkIGNvbnRyb2wgb3ZlciB0aGUgbWF0Y2hpbmdcbiAgICAvLyBiZWhhdmlvciBieSBzaW1wbHkgcHV0dGluZyByb3V0ZXMgd2l0aCBpZGVudGljYWwgcGF0aHMgaW4gdGhlIG9yZGVyIHRoZXlcbiAgICAvLyB3YW50IHRoZW0gdHJpZWQuXG4gICAgYVthLmxlbmd0aCAtIDFdIC0gYltiLmxlbmd0aCAtIDFdXG4gICkgOiAoXG4gICAgLy8gT3RoZXJ3aXNlLCBpdCBkb2Vzbid0IHJlYWxseSBtYWtlIHNlbnNlIHRvIHJhbmsgbm9uLXNpYmxpbmdzIGJ5IGluZGV4LFxuICAgIC8vIHNvIHRoZXkgc29ydCBlcXVhbGx5LlxuICAgIDBcbiAgKTtcbn1cbmZ1bmN0aW9uIG1hdGNoUm91dGVCcmFuY2goYnJhbmNoLCBwYXRobmFtZSwgYWxsb3dQYXJ0aWFsID0gZmFsc2UpIHtcbiAgbGV0IHsgcm91dGVzTWV0YSB9ID0gYnJhbmNoO1xuICBsZXQgbWF0Y2hlZFBhcmFtcyA9IHt9O1xuICBsZXQgbWF0Y2hlZFBhdGhuYW1lID0gXCIvXCI7XG4gIGxldCBtYXRjaGVzID0gW107XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgcm91dGVzTWV0YS5sZW5ndGg7ICsraSkge1xuICAgIGxldCBtZXRhID0gcm91dGVzTWV0YVtpXTtcbiAgICBsZXQgZW5kID0gaSA9PT0gcm91dGVzTWV0YS5sZW5ndGggLSAxO1xuICAgIGxldCByZW1haW5pbmdQYXRobmFtZSA9IG1hdGNoZWRQYXRobmFtZSA9PT0gXCIvXCIgPyBwYXRobmFtZSA6IHBhdGhuYW1lLnNsaWNlKG1hdGNoZWRQYXRobmFtZS5sZW5ndGgpIHx8IFwiL1wiO1xuICAgIGxldCBtYXRjaCA9IG1hdGNoUGF0aChcbiAgICAgIHsgcGF0aDogbWV0YS5yZWxhdGl2ZVBhdGgsIGNhc2VTZW5zaXRpdmU6IG1ldGEuY2FzZVNlbnNpdGl2ZSwgZW5kIH0sXG4gICAgICByZW1haW5pbmdQYXRobmFtZVxuICAgICk7XG4gICAgbGV0IHJvdXRlID0gbWV0YS5yb3V0ZTtcbiAgICBpZiAoIW1hdGNoICYmIGVuZCAmJiBhbGxvd1BhcnRpYWwgJiYgIXJvdXRlc01ldGFbcm91dGVzTWV0YS5sZW5ndGggLSAxXS5yb3V0ZS5pbmRleCkge1xuICAgICAgbWF0Y2ggPSBtYXRjaFBhdGgoXG4gICAgICAgIHtcbiAgICAgICAgICBwYXRoOiBtZXRhLnJlbGF0aXZlUGF0aCxcbiAgICAgICAgICBjYXNlU2Vuc2l0aXZlOiBtZXRhLmNhc2VTZW5zaXRpdmUsXG4gICAgICAgICAgZW5kOiBmYWxzZVxuICAgICAgICB9LFxuICAgICAgICByZW1haW5pbmdQYXRobmFtZVxuICAgICAgKTtcbiAgICB9XG4gICAgaWYgKCFtYXRjaCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIE9iamVjdC5hc3NpZ24obWF0Y2hlZFBhcmFtcywgbWF0Y2gucGFyYW1zKTtcbiAgICBtYXRjaGVzLnB1c2goe1xuICAgICAgLy8gVE9ETzogQ2FuIHRoaXMgYXMgYmUgYXZvaWRlZD9cbiAgICAgIHBhcmFtczogbWF0Y2hlZFBhcmFtcyxcbiAgICAgIHBhdGhuYW1lOiBqb2luUGF0aHMoW21hdGNoZWRQYXRobmFtZSwgbWF0Y2gucGF0aG5hbWVdKSxcbiAgICAgIHBhdGhuYW1lQmFzZTogbm9ybWFsaXplUGF0aG5hbWUoXG4gICAgICAgIGpvaW5QYXRocyhbbWF0Y2hlZFBhdGhuYW1lLCBtYXRjaC5wYXRobmFtZUJhc2VdKVxuICAgICAgKSxcbiAgICAgIHJvdXRlXG4gICAgfSk7XG4gICAgaWYgKG1hdGNoLnBhdGhuYW1lQmFzZSAhPT0gXCIvXCIpIHtcbiAgICAgIG1hdGNoZWRQYXRobmFtZSA9IGpvaW5QYXRocyhbbWF0Y2hlZFBhdGhuYW1lLCBtYXRjaC5wYXRobmFtZUJhc2VdKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG1hdGNoZXM7XG59XG5mdW5jdGlvbiBnZW5lcmF0ZVBhdGgob3JpZ2luYWxQYXRoLCBwYXJhbXMgPSB7fSkge1xuICBsZXQgcGF0aCA9IG9yaWdpbmFsUGF0aDtcbiAgaWYgKHBhdGguZW5kc1dpdGgoXCIqXCIpICYmIHBhdGggIT09IFwiKlwiICYmICFwYXRoLmVuZHNXaXRoKFwiLypcIikpIHtcbiAgICB3YXJuaW5nKFxuICAgICAgZmFsc2UsXG4gICAgICBgUm91dGUgcGF0aCBcIiR7cGF0aH1cIiB3aWxsIGJlIHRyZWF0ZWQgYXMgaWYgaXQgd2VyZSBcIiR7cGF0aC5yZXBsYWNlKC9cXCokLywgXCIvKlwiKX1cIiBiZWNhdXNlIHRoZSBcXGAqXFxgIGNoYXJhY3RlciBtdXN0IGFsd2F5cyBmb2xsb3cgYSBcXGAvXFxgIGluIHRoZSBwYXR0ZXJuLiBUbyBnZXQgcmlkIG9mIHRoaXMgd2FybmluZywgcGxlYXNlIGNoYW5nZSB0aGUgcm91dGUgcGF0aCB0byBcIiR7cGF0aC5yZXBsYWNlKC9cXCokLywgXCIvKlwiKX1cIi5gXG4gICAgKTtcbiAgICBwYXRoID0gcGF0aC5yZXBsYWNlKC9cXCokLywgXCIvKlwiKTtcbiAgfVxuICBjb25zdCBwcmVmaXggPSBwYXRoLnN0YXJ0c1dpdGgoXCIvXCIpID8gXCIvXCIgOiBcIlwiO1xuICBjb25zdCBzdHJpbmdpZnkgPSAocCkgPT4gcCA9PSBudWxsID8gXCJcIiA6IHR5cGVvZiBwID09PSBcInN0cmluZ1wiID8gcCA6IFN0cmluZyhwKTtcbiAgY29uc3Qgc2VnbWVudHMgPSBwYXRoLnNwbGl0KC9cXC8rLykubWFwKChzZWdtZW50LCBpbmRleCwgYXJyYXkpID0+IHtcbiAgICBjb25zdCBpc0xhc3RTZWdtZW50ID0gaW5kZXggPT09IGFycmF5Lmxlbmd0aCAtIDE7XG4gICAgaWYgKGlzTGFzdFNlZ21lbnQgJiYgc2VnbWVudCA9PT0gXCIqXCIpIHtcbiAgICAgIGNvbnN0IHN0YXIgPSBcIipcIjtcbiAgICAgIHJldHVybiBzdHJpbmdpZnkocGFyYW1zW3N0YXJdKTtcbiAgICB9XG4gICAgY29uc3Qga2V5TWF0Y2ggPSBzZWdtZW50Lm1hdGNoKC9eOihbXFx3LV0rKShcXD8/KSQvKTtcbiAgICBpZiAoa2V5TWF0Y2gpIHtcbiAgICAgIGNvbnN0IFssIGtleSwgb3B0aW9uYWxdID0ga2V5TWF0Y2g7XG4gICAgICBsZXQgcGFyYW0gPSBwYXJhbXNba2V5XTtcbiAgICAgIGludmFyaWFudChvcHRpb25hbCA9PT0gXCI/XCIgfHwgcGFyYW0gIT0gbnVsbCwgYE1pc3NpbmcgXCI6JHtrZXl9XCIgcGFyYW1gKTtcbiAgICAgIHJldHVybiBzdHJpbmdpZnkocGFyYW0pO1xuICAgIH1cbiAgICByZXR1cm4gc2VnbWVudC5yZXBsYWNlKC9cXD8kL2csIFwiXCIpO1xuICB9KS5maWx0ZXIoKHNlZ21lbnQpID0+ICEhc2VnbWVudCk7XG4gIHJldHVybiBwcmVmaXggKyBzZWdtZW50cy5qb2luKFwiL1wiKTtcbn1cbmZ1bmN0aW9uIG1hdGNoUGF0aChwYXR0ZXJuLCBwYXRobmFtZSkge1xuICBpZiAodHlwZW9mIHBhdHRlcm4gPT09IFwic3RyaW5nXCIpIHtcbiAgICBwYXR0ZXJuID0geyBwYXRoOiBwYXR0ZXJuLCBjYXNlU2Vuc2l0aXZlOiBmYWxzZSwgZW5kOiB0cnVlIH07XG4gIH1cbiAgbGV0IFttYXRjaGVyLCBjb21waWxlZFBhcmFtc10gPSBjb21waWxlUGF0aChcbiAgICBwYXR0ZXJuLnBhdGgsXG4gICAgcGF0dGVybi5jYXNlU2Vuc2l0aXZlLFxuICAgIHBhdHRlcm4uZW5kXG4gICk7XG4gIGxldCBtYXRjaCA9IHBhdGhuYW1lLm1hdGNoKG1hdGNoZXIpO1xuICBpZiAoIW1hdGNoKSByZXR1cm4gbnVsbDtcbiAgbGV0IG1hdGNoZWRQYXRobmFtZSA9IG1hdGNoWzBdO1xuICBsZXQgcGF0aG5hbWVCYXNlID0gbWF0Y2hlZFBhdGhuYW1lLnJlcGxhY2UoLyguKVxcLyskLywgXCIkMVwiKTtcbiAgbGV0IGNhcHR1cmVHcm91cHMgPSBtYXRjaC5zbGljZSgxKTtcbiAgbGV0IHBhcmFtcyA9IGNvbXBpbGVkUGFyYW1zLnJlZHVjZShcbiAgICAobWVtbzIsIHsgcGFyYW1OYW1lLCBpc09wdGlvbmFsIH0sIGluZGV4KSA9PiB7XG4gICAgICBpZiAocGFyYW1OYW1lID09PSBcIipcIikge1xuICAgICAgICBsZXQgc3BsYXRWYWx1ZSA9IGNhcHR1cmVHcm91cHNbaW5kZXhdIHx8IFwiXCI7XG4gICAgICAgIHBhdGhuYW1lQmFzZSA9IG1hdGNoZWRQYXRobmFtZS5zbGljZSgwLCBtYXRjaGVkUGF0aG5hbWUubGVuZ3RoIC0gc3BsYXRWYWx1ZS5sZW5ndGgpLnJlcGxhY2UoLyguKVxcLyskLywgXCIkMVwiKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHZhbHVlID0gY2FwdHVyZUdyb3Vwc1tpbmRleF07XG4gICAgICBpZiAoaXNPcHRpb25hbCAmJiAhdmFsdWUpIHtcbiAgICAgICAgbWVtbzJbcGFyYW1OYW1lXSA9IHZvaWQgMDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG1lbW8yW3BhcmFtTmFtZV0gPSAodmFsdWUgfHwgXCJcIikucmVwbGFjZSgvJTJGL2csIFwiL1wiKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBtZW1vMjtcbiAgICB9LFxuICAgIHt9XG4gICk7XG4gIHJldHVybiB7XG4gICAgcGFyYW1zLFxuICAgIHBhdGhuYW1lOiBtYXRjaGVkUGF0aG5hbWUsXG4gICAgcGF0aG5hbWVCYXNlLFxuICAgIHBhdHRlcm5cbiAgfTtcbn1cbmZ1bmN0aW9uIGNvbXBpbGVQYXRoKHBhdGgsIGNhc2VTZW5zaXRpdmUgPSBmYWxzZSwgZW5kID0gdHJ1ZSkge1xuICB3YXJuaW5nKFxuICAgIHBhdGggPT09IFwiKlwiIHx8ICFwYXRoLmVuZHNXaXRoKFwiKlwiKSB8fCBwYXRoLmVuZHNXaXRoKFwiLypcIiksXG4gICAgYFJvdXRlIHBhdGggXCIke3BhdGh9XCIgd2lsbCBiZSB0cmVhdGVkIGFzIGlmIGl0IHdlcmUgXCIke3BhdGgucmVwbGFjZSgvXFwqJC8sIFwiLypcIil9XCIgYmVjYXVzZSB0aGUgXFxgKlxcYCBjaGFyYWN0ZXIgbXVzdCBhbHdheXMgZm9sbG93IGEgXFxgL1xcYCBpbiB0aGUgcGF0dGVybi4gVG8gZ2V0IHJpZCBvZiB0aGlzIHdhcm5pbmcsIHBsZWFzZSBjaGFuZ2UgdGhlIHJvdXRlIHBhdGggdG8gXCIke3BhdGgucmVwbGFjZSgvXFwqJC8sIFwiLypcIil9XCIuYFxuICApO1xuICBsZXQgcGFyYW1zID0gW107XG4gIGxldCByZWdleHBTb3VyY2UgPSBcIl5cIiArIHBhdGgucmVwbGFjZSgvXFwvKlxcKj8kLywgXCJcIikucmVwbGFjZSgvXlxcLyovLCBcIi9cIikucmVwbGFjZSgvW1xcXFwuKiteJHt9fCgpW1xcXV0vZywgXCJcXFxcJCZcIikucmVwbGFjZShcbiAgICAvXFwvOihbXFx3LV0rKShcXD8pPy9nLFxuICAgIChfLCBwYXJhbU5hbWUsIGlzT3B0aW9uYWwpID0+IHtcbiAgICAgIHBhcmFtcy5wdXNoKHsgcGFyYW1OYW1lLCBpc09wdGlvbmFsOiBpc09wdGlvbmFsICE9IG51bGwgfSk7XG4gICAgICByZXR1cm4gaXNPcHRpb25hbCA/IFwiLz8oW15cXFxcL10rKT9cIiA6IFwiLyhbXlxcXFwvXSspXCI7XG4gICAgfVxuICApO1xuICBpZiAocGF0aC5lbmRzV2l0aChcIipcIikpIHtcbiAgICBwYXJhbXMucHVzaCh7IHBhcmFtTmFtZTogXCIqXCIgfSk7XG4gICAgcmVnZXhwU291cmNlICs9IHBhdGggPT09IFwiKlwiIHx8IHBhdGggPT09IFwiLypcIiA/IFwiKC4qKSRcIiA6IFwiKD86XFxcXC8oLispfFxcXFwvKikkXCI7XG4gIH0gZWxzZSBpZiAoZW5kKSB7XG4gICAgcmVnZXhwU291cmNlICs9IFwiXFxcXC8qJFwiO1xuICB9IGVsc2UgaWYgKHBhdGggIT09IFwiXCIgJiYgcGF0aCAhPT0gXCIvXCIpIHtcbiAgICByZWdleHBTb3VyY2UgKz0gXCIoPzooPz1cXFxcL3wkKSlcIjtcbiAgfSBlbHNlIHtcbiAgfVxuICBsZXQgbWF0Y2hlciA9IG5ldyBSZWdFeHAocmVnZXhwU291cmNlLCBjYXNlU2Vuc2l0aXZlID8gdm9pZCAwIDogXCJpXCIpO1xuICByZXR1cm4gW21hdGNoZXIsIHBhcmFtc107XG59XG5mdW5jdGlvbiBkZWNvZGVQYXRoKHZhbHVlKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIHZhbHVlLnNwbGl0KFwiL1wiKS5tYXAoKHYpID0+IGRlY29kZVVSSUNvbXBvbmVudCh2KS5yZXBsYWNlKC9cXC8vZywgXCIlMkZcIikpLmpvaW4oXCIvXCIpO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIHdhcm5pbmcoXG4gICAgICBmYWxzZSxcbiAgICAgIGBUaGUgVVJMIHBhdGggXCIke3ZhbHVlfVwiIGNvdWxkIG5vdCBiZSBkZWNvZGVkIGJlY2F1c2UgaXQgaXMgaXMgYSBtYWxmb3JtZWQgVVJMIHNlZ21lbnQuIFRoaXMgaXMgcHJvYmFibHkgZHVlIHRvIGEgYmFkIHBlcmNlbnQgZW5jb2RpbmcgKCR7ZXJyb3J9KS5gXG4gICAgKTtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbn1cbmZ1bmN0aW9uIHN0cmlwQmFzZW5hbWUocGF0aG5hbWUsIGJhc2VuYW1lKSB7XG4gIGlmIChiYXNlbmFtZSA9PT0gXCIvXCIpIHJldHVybiBwYXRobmFtZTtcbiAgaWYgKCFwYXRobmFtZS50b0xvd2VyQ2FzZSgpLnN0YXJ0c1dpdGgoYmFzZW5hbWUudG9Mb3dlckNhc2UoKSkpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBsZXQgc3RhcnRJbmRleCA9IGJhc2VuYW1lLmVuZHNXaXRoKFwiL1wiKSA/IGJhc2VuYW1lLmxlbmd0aCAtIDEgOiBiYXNlbmFtZS5sZW5ndGg7XG4gIGxldCBuZXh0Q2hhciA9IHBhdGhuYW1lLmNoYXJBdChzdGFydEluZGV4KTtcbiAgaWYgKG5leHRDaGFyICYmIG5leHRDaGFyICE9PSBcIi9cIikge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHJldHVybiBwYXRobmFtZS5zbGljZShzdGFydEluZGV4KSB8fCBcIi9cIjtcbn1cbmZ1bmN0aW9uIHJlc29sdmVQYXRoKHRvLCBmcm9tUGF0aG5hbWUgPSBcIi9cIikge1xuICBsZXQge1xuICAgIHBhdGhuYW1lOiB0b1BhdGhuYW1lLFxuICAgIHNlYXJjaCA9IFwiXCIsXG4gICAgaGFzaCA9IFwiXCJcbiAgfSA9IHR5cGVvZiB0byA9PT0gXCJzdHJpbmdcIiA/IHBhcnNlUGF0aCh0bykgOiB0bztcbiAgbGV0IHBhdGhuYW1lID0gdG9QYXRobmFtZSA/IHRvUGF0aG5hbWUuc3RhcnRzV2l0aChcIi9cIikgPyB0b1BhdGhuYW1lIDogcmVzb2x2ZVBhdGhuYW1lKHRvUGF0aG5hbWUsIGZyb21QYXRobmFtZSkgOiBmcm9tUGF0aG5hbWU7XG4gIHJldHVybiB7XG4gICAgcGF0aG5hbWUsXG4gICAgc2VhcmNoOiBub3JtYWxpemVTZWFyY2goc2VhcmNoKSxcbiAgICBoYXNoOiBub3JtYWxpemVIYXNoKGhhc2gpXG4gIH07XG59XG5mdW5jdGlvbiByZXNvbHZlUGF0aG5hbWUocmVsYXRpdmVQYXRoLCBmcm9tUGF0aG5hbWUpIHtcbiAgbGV0IHNlZ21lbnRzID0gZnJvbVBhdGhuYW1lLnJlcGxhY2UoL1xcLyskLywgXCJcIikuc3BsaXQoXCIvXCIpO1xuICBsZXQgcmVsYXRpdmVTZWdtZW50cyA9IHJlbGF0aXZlUGF0aC5zcGxpdChcIi9cIik7XG4gIHJlbGF0aXZlU2VnbWVudHMuZm9yRWFjaCgoc2VnbWVudCkgPT4ge1xuICAgIGlmIChzZWdtZW50ID09PSBcIi4uXCIpIHtcbiAgICAgIGlmIChzZWdtZW50cy5sZW5ndGggPiAxKSBzZWdtZW50cy5wb3AoKTtcbiAgICB9IGVsc2UgaWYgKHNlZ21lbnQgIT09IFwiLlwiKSB7XG4gICAgICBzZWdtZW50cy5wdXNoKHNlZ21lbnQpO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiBzZWdtZW50cy5sZW5ndGggPiAxID8gc2VnbWVudHMuam9pbihcIi9cIikgOiBcIi9cIjtcbn1cbmZ1bmN0aW9uIGdldEludmFsaWRQYXRoRXJyb3IoY2hhciwgZmllbGQsIGRlc3QsIHBhdGgpIHtcbiAgcmV0dXJuIGBDYW5ub3QgaW5jbHVkZSBhICcke2NoYXJ9JyBjaGFyYWN0ZXIgaW4gYSBtYW51YWxseSBzcGVjaWZpZWQgXFxgdG8uJHtmaWVsZH1cXGAgZmllbGQgWyR7SlNPTi5zdHJpbmdpZnkoXG4gICAgcGF0aFxuICApfV0uICBQbGVhc2Ugc2VwYXJhdGUgaXQgb3V0IHRvIHRoZSBcXGB0by4ke2Rlc3R9XFxgIGZpZWxkLiBBbHRlcm5hdGl2ZWx5IHlvdSBtYXkgcHJvdmlkZSB0aGUgZnVsbCBwYXRoIGFzIGEgc3RyaW5nIGluIDxMaW5rIHRvPVwiLi4uXCI+IGFuZCB0aGUgcm91dGVyIHdpbGwgcGFyc2UgaXQgZm9yIHlvdS5gO1xufVxuZnVuY3Rpb24gZ2V0UGF0aENvbnRyaWJ1dGluZ01hdGNoZXMobWF0Y2hlcykge1xuICByZXR1cm4gbWF0Y2hlcy5maWx0ZXIoXG4gICAgKG1hdGNoLCBpbmRleCkgPT4gaW5kZXggPT09IDAgfHwgbWF0Y2gucm91dGUucGF0aCAmJiBtYXRjaC5yb3V0ZS5wYXRoLmxlbmd0aCA+IDBcbiAgKTtcbn1cbmZ1bmN0aW9uIGdldFJlc29sdmVUb01hdGNoZXMobWF0Y2hlcykge1xuICBsZXQgcGF0aE1hdGNoZXMgPSBnZXRQYXRoQ29udHJpYnV0aW5nTWF0Y2hlcyhtYXRjaGVzKTtcbiAgcmV0dXJuIHBhdGhNYXRjaGVzLm1hcChcbiAgICAobWF0Y2gsIGlkeCkgPT4gaWR4ID09PSBwYXRoTWF0Y2hlcy5sZW5ndGggLSAxID8gbWF0Y2gucGF0aG5hbWUgOiBtYXRjaC5wYXRobmFtZUJhc2VcbiAgKTtcbn1cbmZ1bmN0aW9uIHJlc29sdmVUbyh0b0FyZywgcm91dGVQYXRobmFtZXMsIGxvY2F0aW9uUGF0aG5hbWUsIGlzUGF0aFJlbGF0aXZlID0gZmFsc2UpIHtcbiAgbGV0IHRvO1xuICBpZiAodHlwZW9mIHRvQXJnID09PSBcInN0cmluZ1wiKSB7XG4gICAgdG8gPSBwYXJzZVBhdGgodG9BcmcpO1xuICB9IGVsc2Uge1xuICAgIHRvID0geyAuLi50b0FyZyB9O1xuICAgIGludmFyaWFudChcbiAgICAgICF0by5wYXRobmFtZSB8fCAhdG8ucGF0aG5hbWUuaW5jbHVkZXMoXCI/XCIpLFxuICAgICAgZ2V0SW52YWxpZFBhdGhFcnJvcihcIj9cIiwgXCJwYXRobmFtZVwiLCBcInNlYXJjaFwiLCB0bylcbiAgICApO1xuICAgIGludmFyaWFudChcbiAgICAgICF0by5wYXRobmFtZSB8fCAhdG8ucGF0aG5hbWUuaW5jbHVkZXMoXCIjXCIpLFxuICAgICAgZ2V0SW52YWxpZFBhdGhFcnJvcihcIiNcIiwgXCJwYXRobmFtZVwiLCBcImhhc2hcIiwgdG8pXG4gICAgKTtcbiAgICBpbnZhcmlhbnQoXG4gICAgICAhdG8uc2VhcmNoIHx8ICF0by5zZWFyY2guaW5jbHVkZXMoXCIjXCIpLFxuICAgICAgZ2V0SW52YWxpZFBhdGhFcnJvcihcIiNcIiwgXCJzZWFyY2hcIiwgXCJoYXNoXCIsIHRvKVxuICAgICk7XG4gIH1cbiAgbGV0IGlzRW1wdHlQYXRoID0gdG9BcmcgPT09IFwiXCIgfHwgdG8ucGF0aG5hbWUgPT09IFwiXCI7XG4gIGxldCB0b1BhdGhuYW1lID0gaXNFbXB0eVBhdGggPyBcIi9cIiA6IHRvLnBhdGhuYW1lO1xuICBsZXQgZnJvbTtcbiAgaWYgKHRvUGF0aG5hbWUgPT0gbnVsbCkge1xuICAgIGZyb20gPSBsb2NhdGlvblBhdGhuYW1lO1xuICB9IGVsc2Uge1xuICAgIGxldCByb3V0ZVBhdGhuYW1lSW5kZXggPSByb3V0ZVBhdGhuYW1lcy5sZW5ndGggLSAxO1xuICAgIGlmICghaXNQYXRoUmVsYXRpdmUgJiYgdG9QYXRobmFtZS5zdGFydHNXaXRoKFwiLi5cIikpIHtcbiAgICAgIGxldCB0b1NlZ21lbnRzID0gdG9QYXRobmFtZS5zcGxpdChcIi9cIik7XG4gICAgICB3aGlsZSAodG9TZWdtZW50c1swXSA9PT0gXCIuLlwiKSB7XG4gICAgICAgIHRvU2VnbWVudHMuc2hpZnQoKTtcbiAgICAgICAgcm91dGVQYXRobmFtZUluZGV4IC09IDE7XG4gICAgICB9XG4gICAgICB0by5wYXRobmFtZSA9IHRvU2VnbWVudHMuam9pbihcIi9cIik7XG4gICAgfVxuICAgIGZyb20gPSByb3V0ZVBhdGhuYW1lSW5kZXggPj0gMCA/IHJvdXRlUGF0aG5hbWVzW3JvdXRlUGF0aG5hbWVJbmRleF0gOiBcIi9cIjtcbiAgfVxuICBsZXQgcGF0aCA9IHJlc29sdmVQYXRoKHRvLCBmcm9tKTtcbiAgbGV0IGhhc0V4cGxpY2l0VHJhaWxpbmdTbGFzaCA9IHRvUGF0aG5hbWUgJiYgdG9QYXRobmFtZSAhPT0gXCIvXCIgJiYgdG9QYXRobmFtZS5lbmRzV2l0aChcIi9cIik7XG4gIGxldCBoYXNDdXJyZW50VHJhaWxpbmdTbGFzaCA9IChpc0VtcHR5UGF0aCB8fCB0b1BhdGhuYW1lID09PSBcIi5cIikgJiYgbG9jYXRpb25QYXRobmFtZS5lbmRzV2l0aChcIi9cIik7XG4gIGlmICghcGF0aC5wYXRobmFtZS5lbmRzV2l0aChcIi9cIikgJiYgKGhhc0V4cGxpY2l0VHJhaWxpbmdTbGFzaCB8fCBoYXNDdXJyZW50VHJhaWxpbmdTbGFzaCkpIHtcbiAgICBwYXRoLnBhdGhuYW1lICs9IFwiL1wiO1xuICB9XG4gIHJldHVybiBwYXRoO1xufVxudmFyIGpvaW5QYXRocyA9IChwYXRocykgPT4gcGF0aHMuam9pbihcIi9cIikucmVwbGFjZSgvXFwvXFwvKy9nLCBcIi9cIik7XG52YXIgbm9ybWFsaXplUGF0aG5hbWUgPSAocGF0aG5hbWUpID0+IHBhdGhuYW1lLnJlcGxhY2UoL1xcLyskLywgXCJcIikucmVwbGFjZSgvXlxcLyovLCBcIi9cIik7XG52YXIgbm9ybWFsaXplU2VhcmNoID0gKHNlYXJjaCkgPT4gIXNlYXJjaCB8fCBzZWFyY2ggPT09IFwiP1wiID8gXCJcIiA6IHNlYXJjaC5zdGFydHNXaXRoKFwiP1wiKSA/IHNlYXJjaCA6IFwiP1wiICsgc2VhcmNoO1xudmFyIG5vcm1hbGl6ZUhhc2ggPSAoaGFzaCkgPT4gIWhhc2ggfHwgaGFzaCA9PT0gXCIjXCIgPyBcIlwiIDogaGFzaC5zdGFydHNXaXRoKFwiI1wiKSA/IGhhc2ggOiBcIiNcIiArIGhhc2g7XG52YXIgRGF0YVdpdGhSZXNwb25zZUluaXQgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKGRhdGEyLCBpbml0KSB7XG4gICAgdGhpcy50eXBlID0gXCJEYXRhV2l0aFJlc3BvbnNlSW5pdFwiO1xuICAgIHRoaXMuZGF0YSA9IGRhdGEyO1xuICAgIHRoaXMuaW5pdCA9IGluaXQgfHwgbnVsbDtcbiAgfVxufTtcbmZ1bmN0aW9uIGRhdGEoZGF0YTIsIGluaXQpIHtcbiAgcmV0dXJuIG5ldyBEYXRhV2l0aFJlc3BvbnNlSW5pdChcbiAgICBkYXRhMixcbiAgICB0eXBlb2YgaW5pdCA9PT0gXCJudW1iZXJcIiA/IHsgc3RhdHVzOiBpbml0IH0gOiBpbml0XG4gICk7XG59XG52YXIgcmVkaXJlY3QgPSAodXJsLCBpbml0ID0gMzAyKSA9PiB7XG4gIGxldCByZXNwb25zZUluaXQgPSBpbml0O1xuICBpZiAodHlwZW9mIHJlc3BvbnNlSW5pdCA9PT0gXCJudW1iZXJcIikge1xuICAgIHJlc3BvbnNlSW5pdCA9IHsgc3RhdHVzOiByZXNwb25zZUluaXQgfTtcbiAgfSBlbHNlIGlmICh0eXBlb2YgcmVzcG9uc2VJbml0LnN0YXR1cyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgIHJlc3BvbnNlSW5pdC5zdGF0dXMgPSAzMDI7XG4gIH1cbiAgbGV0IGhlYWRlcnMgPSBuZXcgSGVhZGVycyhyZXNwb25zZUluaXQuaGVhZGVycyk7XG4gIGhlYWRlcnMuc2V0KFwiTG9jYXRpb25cIiwgdXJsKTtcbiAgcmV0dXJuIG5ldyBSZXNwb25zZShudWxsLCB7XG4gICAgLi4ucmVzcG9uc2VJbml0LFxuICAgIGhlYWRlcnNcbiAgfSk7XG59O1xudmFyIHJlZGlyZWN0RG9jdW1lbnQgPSAodXJsLCBpbml0KSA9PiB7XG4gIGxldCByZXNwb25zZSA9IHJlZGlyZWN0KHVybCwgaW5pdCk7XG4gIHJlc3BvbnNlLmhlYWRlcnMuc2V0KFwiWC1SZW1peC1SZWxvYWQtRG9jdW1lbnRcIiwgXCJ0cnVlXCIpO1xuICByZXR1cm4gcmVzcG9uc2U7XG59O1xudmFyIHJlcGxhY2UgPSAodXJsLCBpbml0KSA9PiB7XG4gIGxldCByZXNwb25zZSA9IHJlZGlyZWN0KHVybCwgaW5pdCk7XG4gIHJlc3BvbnNlLmhlYWRlcnMuc2V0KFwiWC1SZW1peC1SZXBsYWNlXCIsIFwidHJ1ZVwiKTtcbiAgcmV0dXJuIHJlc3BvbnNlO1xufTtcbnZhciBFcnJvclJlc3BvbnNlSW1wbCA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3Ioc3RhdHVzLCBzdGF0dXNUZXh0LCBkYXRhMiwgaW50ZXJuYWwgPSBmYWxzZSkge1xuICAgIHRoaXMuc3RhdHVzID0gc3RhdHVzO1xuICAgIHRoaXMuc3RhdHVzVGV4dCA9IHN0YXR1c1RleHQgfHwgXCJcIjtcbiAgICB0aGlzLmludGVybmFsID0gaW50ZXJuYWw7XG4gICAgaWYgKGRhdGEyIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgIHRoaXMuZGF0YSA9IGRhdGEyLnRvU3RyaW5nKCk7XG4gICAgICB0aGlzLmVycm9yID0gZGF0YTI7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuZGF0YSA9IGRhdGEyO1xuICAgIH1cbiAgfVxufTtcbmZ1bmN0aW9uIGlzUm91dGVFcnJvclJlc3BvbnNlKGVycm9yKSB7XG4gIHJldHVybiBlcnJvciAhPSBudWxsICYmIHR5cGVvZiBlcnJvci5zdGF0dXMgPT09IFwibnVtYmVyXCIgJiYgdHlwZW9mIGVycm9yLnN0YXR1c1RleHQgPT09IFwic3RyaW5nXCIgJiYgdHlwZW9mIGVycm9yLmludGVybmFsID09PSBcImJvb2xlYW5cIiAmJiBcImRhdGFcIiBpbiBlcnJvcjtcbn1cblxuLy8gbGliL3JvdXRlci9yb3V0ZXIudHNcbnZhciB2YWxpZE11dGF0aW9uTWV0aG9kc0FyciA9IFtcbiAgXCJQT1NUXCIsXG4gIFwiUFVUXCIsXG4gIFwiUEFUQ0hcIixcbiAgXCJERUxFVEVcIlxuXTtcbnZhciB2YWxpZE11dGF0aW9uTWV0aG9kcyA9IG5ldyBTZXQoXG4gIHZhbGlkTXV0YXRpb25NZXRob2RzQXJyXG4pO1xudmFyIHZhbGlkUmVxdWVzdE1ldGhvZHNBcnIgPSBbXG4gIFwiR0VUXCIsXG4gIC4uLnZhbGlkTXV0YXRpb25NZXRob2RzQXJyXG5dO1xudmFyIHZhbGlkUmVxdWVzdE1ldGhvZHMgPSBuZXcgU2V0KHZhbGlkUmVxdWVzdE1ldGhvZHNBcnIpO1xudmFyIHJlZGlyZWN0U3RhdHVzQ29kZXMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldChbMzAxLCAzMDIsIDMwMywgMzA3LCAzMDhdKTtcbnZhciByZWRpcmVjdFByZXNlcnZlTWV0aG9kU3RhdHVzQ29kZXMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldChbMzA3LCAzMDhdKTtcbnZhciBJRExFX05BVklHQVRJT04gPSB7XG4gIHN0YXRlOiBcImlkbGVcIixcbiAgbG9jYXRpb246IHZvaWQgMCxcbiAgZm9ybU1ldGhvZDogdm9pZCAwLFxuICBmb3JtQWN0aW9uOiB2b2lkIDAsXG4gIGZvcm1FbmNUeXBlOiB2b2lkIDAsXG4gIGZvcm1EYXRhOiB2b2lkIDAsXG4gIGpzb246IHZvaWQgMCxcbiAgdGV4dDogdm9pZCAwXG59O1xudmFyIElETEVfRkVUQ0hFUiA9IHtcbiAgc3RhdGU6IFwiaWRsZVwiLFxuICBkYXRhOiB2b2lkIDAsXG4gIGZvcm1NZXRob2Q6IHZvaWQgMCxcbiAgZm9ybUFjdGlvbjogdm9pZCAwLFxuICBmb3JtRW5jVHlwZTogdm9pZCAwLFxuICBmb3JtRGF0YTogdm9pZCAwLFxuICBqc29uOiB2b2lkIDAsXG4gIHRleHQ6IHZvaWQgMFxufTtcbnZhciBJRExFX0JMT0NLRVIgPSB7XG4gIHN0YXRlOiBcInVuYmxvY2tlZFwiLFxuICBwcm9jZWVkOiB2b2lkIDAsXG4gIHJlc2V0OiB2b2lkIDAsXG4gIGxvY2F0aW9uOiB2b2lkIDBcbn07XG52YXIgQUJTT0xVVEVfVVJMX1JFR0VYID0gL14oPzpbYS16XVthLXowLTkrLi1dKjp8XFwvXFwvKS9pO1xudmFyIGRlZmF1bHRNYXBSb3V0ZVByb3BlcnRpZXMgPSAocm91dGUpID0+ICh7XG4gIGhhc0Vycm9yQm91bmRhcnk6IEJvb2xlYW4ocm91dGUuaGFzRXJyb3JCb3VuZGFyeSlcbn0pO1xudmFyIFRSQU5TSVRJT05TX1NUT1JBR0VfS0VZID0gXCJyZW1peC1yb3V0ZXItdHJhbnNpdGlvbnNcIjtcbnZhciBSZXNldExvYWRlckRhdGFTeW1ib2wgPSBTeW1ib2woXCJSZXNldExvYWRlckRhdGFcIik7XG5mdW5jdGlvbiBjcmVhdGVSb3V0ZXIoaW5pdCkge1xuICBjb25zdCByb3V0ZXJXaW5kb3cgPSBpbml0LndpbmRvdyA/IGluaXQud2luZG93IDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHZvaWQgMDtcbiAgY29uc3QgaXNCcm93c2VyMiA9IHR5cGVvZiByb3V0ZXJXaW5kb3cgIT09IFwidW5kZWZpbmVkXCIgJiYgdHlwZW9mIHJvdXRlcldpbmRvdy5kb2N1bWVudCAhPT0gXCJ1bmRlZmluZWRcIiAmJiB0eXBlb2Ygcm91dGVyV2luZG93LmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQgIT09IFwidW5kZWZpbmVkXCI7XG4gIGludmFyaWFudChcbiAgICBpbml0LnJvdXRlcy5sZW5ndGggPiAwLFxuICAgIFwiWW91IG11c3QgcHJvdmlkZSBhIG5vbi1lbXB0eSByb3V0ZXMgYXJyYXkgdG8gY3JlYXRlUm91dGVyXCJcbiAgKTtcbiAgbGV0IG1hcFJvdXRlUHJvcGVydGllczIgPSBpbml0Lm1hcFJvdXRlUHJvcGVydGllcyB8fCBkZWZhdWx0TWFwUm91dGVQcm9wZXJ0aWVzO1xuICBsZXQgbWFuaWZlc3QgPSB7fTtcbiAgbGV0IGRhdGFSb3V0ZXMgPSBjb252ZXJ0Um91dGVzVG9EYXRhUm91dGVzKFxuICAgIGluaXQucm91dGVzLFxuICAgIG1hcFJvdXRlUHJvcGVydGllczIsXG4gICAgdm9pZCAwLFxuICAgIG1hbmlmZXN0XG4gICk7XG4gIGxldCBpbkZsaWdodERhdGFSb3V0ZXM7XG4gIGxldCBiYXNlbmFtZSA9IGluaXQuYmFzZW5hbWUgfHwgXCIvXCI7XG4gIGxldCBkYXRhU3RyYXRlZ3lJbXBsID0gaW5pdC5kYXRhU3RyYXRlZ3kgfHwgZGVmYXVsdERhdGFTdHJhdGVneTtcbiAgbGV0IHBhdGNoUm91dGVzT25OYXZpZ2F0aW9uSW1wbCA9IGluaXQucGF0Y2hSb3V0ZXNPbk5hdmlnYXRpb247XG4gIGxldCBmdXR1cmUgPSB7XG4gICAgLi4uaW5pdC5mdXR1cmVcbiAgfTtcbiAgbGV0IHVubGlzdGVuSGlzdG9yeSA9IG51bGw7XG4gIGxldCBzdWJzY3JpYmVycyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gIGxldCBzYXZlZFNjcm9sbFBvc2l0aW9uczIgPSBudWxsO1xuICBsZXQgZ2V0U2Nyb2xsUmVzdG9yYXRpb25LZXkyID0gbnVsbDtcbiAgbGV0IGdldFNjcm9sbFBvc2l0aW9uID0gbnVsbDtcbiAgbGV0IGluaXRpYWxTY3JvbGxSZXN0b3JlZCA9IGluaXQuaHlkcmF0aW9uRGF0YSAhPSBudWxsO1xuICBsZXQgaW5pdGlhbE1hdGNoZXMgPSBtYXRjaFJvdXRlcyhkYXRhUm91dGVzLCBpbml0Lmhpc3RvcnkubG9jYXRpb24sIGJhc2VuYW1lKTtcbiAgbGV0IGluaXRpYWxFcnJvcnMgPSBudWxsO1xuICBpZiAoaW5pdGlhbE1hdGNoZXMgPT0gbnVsbCAmJiAhcGF0Y2hSb3V0ZXNPbk5hdmlnYXRpb25JbXBsKSB7XG4gICAgbGV0IGVycm9yID0gZ2V0SW50ZXJuYWxSb3V0ZXJFcnJvcig0MDQsIHtcbiAgICAgIHBhdGhuYW1lOiBpbml0Lmhpc3RvcnkubG9jYXRpb24ucGF0aG5hbWVcbiAgICB9KTtcbiAgICBsZXQgeyBtYXRjaGVzLCByb3V0ZSB9ID0gZ2V0U2hvcnRDaXJjdWl0TWF0Y2hlcyhkYXRhUm91dGVzKTtcbiAgICBpbml0aWFsTWF0Y2hlcyA9IG1hdGNoZXM7XG4gICAgaW5pdGlhbEVycm9ycyA9IHsgW3JvdXRlLmlkXTogZXJyb3IgfTtcbiAgfVxuICBpZiAoaW5pdGlhbE1hdGNoZXMgJiYgIWluaXQuaHlkcmF0aW9uRGF0YSkge1xuICAgIGxldCBmb2dPZldhciA9IGNoZWNrRm9nT2ZXYXIoXG4gICAgICBpbml0aWFsTWF0Y2hlcyxcbiAgICAgIGRhdGFSb3V0ZXMsXG4gICAgICBpbml0Lmhpc3RvcnkubG9jYXRpb24ucGF0aG5hbWVcbiAgICApO1xuICAgIGlmIChmb2dPZldhci5hY3RpdmUpIHtcbiAgICAgIGluaXRpYWxNYXRjaGVzID0gbnVsbDtcbiAgICB9XG4gIH1cbiAgbGV0IGluaXRpYWxpemVkO1xuICBpZiAoIWluaXRpYWxNYXRjaGVzKSB7XG4gICAgaW5pdGlhbGl6ZWQgPSBmYWxzZTtcbiAgICBpbml0aWFsTWF0Y2hlcyA9IFtdO1xuICAgIGxldCBmb2dPZldhciA9IGNoZWNrRm9nT2ZXYXIoXG4gICAgICBudWxsLFxuICAgICAgZGF0YVJvdXRlcyxcbiAgICAgIGluaXQuaGlzdG9yeS5sb2NhdGlvbi5wYXRobmFtZVxuICAgICk7XG4gICAgaWYgKGZvZ09mV2FyLmFjdGl2ZSAmJiBmb2dPZldhci5tYXRjaGVzKSB7XG4gICAgICBpbml0aWFsTWF0Y2hlcyA9IGZvZ09mV2FyLm1hdGNoZXM7XG4gICAgfVxuICB9IGVsc2UgaWYgKGluaXRpYWxNYXRjaGVzLnNvbWUoKG0pID0+IG0ucm91dGUubGF6eSkpIHtcbiAgICBpbml0aWFsaXplZCA9IGZhbHNlO1xuICB9IGVsc2UgaWYgKCFpbml0aWFsTWF0Y2hlcy5zb21lKChtKSA9PiBtLnJvdXRlLmxvYWRlcikpIHtcbiAgICBpbml0aWFsaXplZCA9IHRydWU7XG4gIH0gZWxzZSB7XG4gICAgbGV0IGxvYWRlckRhdGEgPSBpbml0Lmh5ZHJhdGlvbkRhdGEgPyBpbml0Lmh5ZHJhdGlvbkRhdGEubG9hZGVyRGF0YSA6IG51bGw7XG4gICAgbGV0IGVycm9ycyA9IGluaXQuaHlkcmF0aW9uRGF0YSA/IGluaXQuaHlkcmF0aW9uRGF0YS5lcnJvcnMgOiBudWxsO1xuICAgIGlmIChlcnJvcnMpIHtcbiAgICAgIGxldCBpZHggPSBpbml0aWFsTWF0Y2hlcy5maW5kSW5kZXgoXG4gICAgICAgIChtKSA9PiBlcnJvcnNbbS5yb3V0ZS5pZF0gIT09IHZvaWQgMFxuICAgICAgKTtcbiAgICAgIGluaXRpYWxpemVkID0gaW5pdGlhbE1hdGNoZXMuc2xpY2UoMCwgaWR4ICsgMSkuZXZlcnkoKG0pID0+ICFzaG91bGRMb2FkUm91dGVPbkh5ZHJhdGlvbihtLnJvdXRlLCBsb2FkZXJEYXRhLCBlcnJvcnMpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaW5pdGlhbGl6ZWQgPSBpbml0aWFsTWF0Y2hlcy5ldmVyeShcbiAgICAgICAgKG0pID0+ICFzaG91bGRMb2FkUm91dGVPbkh5ZHJhdGlvbihtLnJvdXRlLCBsb2FkZXJEYXRhLCBlcnJvcnMpXG4gICAgICApO1xuICAgIH1cbiAgfVxuICBsZXQgcm91dGVyO1xuICBsZXQgc3RhdGUgPSB7XG4gICAgaGlzdG9yeUFjdGlvbjogaW5pdC5oaXN0b3J5LmFjdGlvbixcbiAgICBsb2NhdGlvbjogaW5pdC5oaXN0b3J5LmxvY2F0aW9uLFxuICAgIG1hdGNoZXM6IGluaXRpYWxNYXRjaGVzLFxuICAgIGluaXRpYWxpemVkLFxuICAgIG5hdmlnYXRpb246IElETEVfTkFWSUdBVElPTixcbiAgICAvLyBEb24ndCByZXN0b3JlIG9uIGluaXRpYWwgdXBkYXRlU3RhdGUoKSBpZiB3ZSB3ZXJlIFNTUidkXG4gICAgcmVzdG9yZVNjcm9sbFBvc2l0aW9uOiBpbml0Lmh5ZHJhdGlvbkRhdGEgIT0gbnVsbCA/IGZhbHNlIDogbnVsbCxcbiAgICBwcmV2ZW50U2Nyb2xsUmVzZXQ6IGZhbHNlLFxuICAgIHJldmFsaWRhdGlvbjogXCJpZGxlXCIsXG4gICAgbG9hZGVyRGF0YTogaW5pdC5oeWRyYXRpb25EYXRhICYmIGluaXQuaHlkcmF0aW9uRGF0YS5sb2FkZXJEYXRhIHx8IHt9LFxuICAgIGFjdGlvbkRhdGE6IGluaXQuaHlkcmF0aW9uRGF0YSAmJiBpbml0Lmh5ZHJhdGlvbkRhdGEuYWN0aW9uRGF0YSB8fCBudWxsLFxuICAgIGVycm9yczogaW5pdC5oeWRyYXRpb25EYXRhICYmIGluaXQuaHlkcmF0aW9uRGF0YS5lcnJvcnMgfHwgaW5pdGlhbEVycm9ycyxcbiAgICBmZXRjaGVyczogLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKSxcbiAgICBibG9ja2VyczogLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKVxuICB9O1xuICBsZXQgcGVuZGluZ0FjdGlvbiA9IFwiUE9QXCIgLyogUG9wICovO1xuICBsZXQgcGVuZGluZ1ByZXZlbnRTY3JvbGxSZXNldCA9IGZhbHNlO1xuICBsZXQgcGVuZGluZ05hdmlnYXRpb25Db250cm9sbGVyO1xuICBsZXQgcGVuZGluZ1ZpZXdUcmFuc2l0aW9uRW5hYmxlZCA9IGZhbHNlO1xuICBsZXQgYXBwbGllZFZpZXdUcmFuc2l0aW9ucyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gIGxldCByZW1vdmVQYWdlSGlkZUV2ZW50TGlzdGVuZXIgPSBudWxsO1xuICBsZXQgaXNVbmludGVycnVwdGVkUmV2YWxpZGF0aW9uID0gZmFsc2U7XG4gIGxldCBpc1JldmFsaWRhdGlvblJlcXVpcmVkID0gZmFsc2U7XG4gIGxldCBjYW5jZWxsZWRGZXRjaGVyTG9hZHMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICBsZXQgZmV0Y2hDb250cm9sbGVycyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gIGxldCBpbmNyZW1lbnRpbmdMb2FkSWQgPSAwO1xuICBsZXQgcGVuZGluZ05hdmlnYXRpb25Mb2FkSWQgPSAtMTtcbiAgbGV0IGZldGNoUmVsb2FkSWRzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgbGV0IGZldGNoUmVkaXJlY3RJZHMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICBsZXQgZmV0Y2hMb2FkTWF0Y2hlcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gIGxldCBhY3RpdmVGZXRjaGVycyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gIGxldCBmZXRjaGVyc1F1ZXVlZEZvckRlbGV0aW9uID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgbGV0IGJsb2NrZXJGdW5jdGlvbnMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICBsZXQgdW5ibG9ja0Jsb2NrZXJIaXN0b3J5VXBkYXRlID0gdm9pZCAwO1xuICBsZXQgcGVuZGluZ1JldmFsaWRhdGlvbkRmZCA9IG51bGw7XG4gIGZ1bmN0aW9uIGluaXRpYWxpemUoKSB7XG4gICAgdW5saXN0ZW5IaXN0b3J5ID0gaW5pdC5oaXN0b3J5Lmxpc3RlbihcbiAgICAgICh7IGFjdGlvbjogaGlzdG9yeUFjdGlvbiwgbG9jYXRpb24sIGRlbHRhIH0pID0+IHtcbiAgICAgICAgaWYgKHVuYmxvY2tCbG9ja2VySGlzdG9yeVVwZGF0ZSkge1xuICAgICAgICAgIHVuYmxvY2tCbG9ja2VySGlzdG9yeVVwZGF0ZSgpO1xuICAgICAgICAgIHVuYmxvY2tCbG9ja2VySGlzdG9yeVVwZGF0ZSA9IHZvaWQgMDtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgd2FybmluZyhcbiAgICAgICAgICBibG9ja2VyRnVuY3Rpb25zLnNpemUgPT09IDAgfHwgZGVsdGEgIT0gbnVsbCxcbiAgICAgICAgICBcIllvdSBhcmUgdHJ5aW5nIHRvIHVzZSBhIGJsb2NrZXIgb24gYSBQT1AgbmF2aWdhdGlvbiB0byBhIGxvY2F0aW9uIHRoYXQgd2FzIG5vdCBjcmVhdGVkIGJ5IEByZW1peC1ydW4vcm91dGVyLiBUaGlzIHdpbGwgZmFpbCBzaWxlbnRseSBpbiBwcm9kdWN0aW9uLiBUaGlzIGNhbiBoYXBwZW4gaWYgeW91IGFyZSBuYXZpZ2F0aW5nIG91dHNpZGUgdGhlIHJvdXRlciB2aWEgYHdpbmRvdy5oaXN0b3J5LnB1c2hTdGF0ZWAvYHdpbmRvdy5sb2NhdGlvbi5oYXNoYCBpbnN0ZWFkIG9mIHVzaW5nIHJvdXRlciBuYXZpZ2F0aW9uIEFQSXMuICBUaGlzIGNhbiBhbHNvIGhhcHBlbiBpZiB5b3UgYXJlIHVzaW5nIGNyZWF0ZUhhc2hSb3V0ZXIgYW5kIHRoZSB1c2VyIG1hbnVhbGx5IGNoYW5nZXMgdGhlIFVSTC5cIlxuICAgICAgICApO1xuICAgICAgICBsZXQgYmxvY2tlcktleSA9IHNob3VsZEJsb2NrTmF2aWdhdGlvbih7XG4gICAgICAgICAgY3VycmVudExvY2F0aW9uOiBzdGF0ZS5sb2NhdGlvbixcbiAgICAgICAgICBuZXh0TG9jYXRpb246IGxvY2F0aW9uLFxuICAgICAgICAgIGhpc3RvcnlBY3Rpb25cbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChibG9ja2VyS2V5ICYmIGRlbHRhICE9IG51bGwpIHtcbiAgICAgICAgICBsZXQgbmV4dEhpc3RvcnlVcGRhdGVQcm9taXNlID0gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICAgICAgICAgIHVuYmxvY2tCbG9ja2VySGlzdG9yeVVwZGF0ZSA9IHJlc29sdmU7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgaW5pdC5oaXN0b3J5LmdvKGRlbHRhICogLTEpO1xuICAgICAgICAgIHVwZGF0ZUJsb2NrZXIoYmxvY2tlcktleSwge1xuICAgICAgICAgICAgc3RhdGU6IFwiYmxvY2tlZFwiLFxuICAgICAgICAgICAgbG9jYXRpb24sXG4gICAgICAgICAgICBwcm9jZWVkKCkge1xuICAgICAgICAgICAgICB1cGRhdGVCbG9ja2VyKGJsb2NrZXJLZXksIHtcbiAgICAgICAgICAgICAgICBzdGF0ZTogXCJwcm9jZWVkaW5nXCIsXG4gICAgICAgICAgICAgICAgcHJvY2VlZDogdm9pZCAwLFxuICAgICAgICAgICAgICAgIHJlc2V0OiB2b2lkIDAsXG4gICAgICAgICAgICAgICAgbG9jYXRpb25cbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIG5leHRIaXN0b3J5VXBkYXRlUHJvbWlzZS50aGVuKCgpID0+IGluaXQuaGlzdG9yeS5nbyhkZWx0YSkpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHJlc2V0KCkge1xuICAgICAgICAgICAgICBsZXQgYmxvY2tlcnMgPSBuZXcgTWFwKHN0YXRlLmJsb2NrZXJzKTtcbiAgICAgICAgICAgICAgYmxvY2tlcnMuc2V0KGJsb2NrZXJLZXksIElETEVfQkxPQ0tFUik7XG4gICAgICAgICAgICAgIHVwZGF0ZVN0YXRlKHsgYmxvY2tlcnMgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdGFydE5hdmlnYXRpb24oaGlzdG9yeUFjdGlvbiwgbG9jYXRpb24pO1xuICAgICAgfVxuICAgICk7XG4gICAgaWYgKGlzQnJvd3NlcjIpIHtcbiAgICAgIHJlc3RvcmVBcHBsaWVkVHJhbnNpdGlvbnMocm91dGVyV2luZG93LCBhcHBsaWVkVmlld1RyYW5zaXRpb25zKTtcbiAgICAgIGxldCBfc2F2ZUFwcGxpZWRUcmFuc2l0aW9ucyA9ICgpID0+IHBlcnNpc3RBcHBsaWVkVHJhbnNpdGlvbnMocm91dGVyV2luZG93LCBhcHBsaWVkVmlld1RyYW5zaXRpb25zKTtcbiAgICAgIHJvdXRlcldpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwicGFnZWhpZGVcIiwgX3NhdmVBcHBsaWVkVHJhbnNpdGlvbnMpO1xuICAgICAgcmVtb3ZlUGFnZUhpZGVFdmVudExpc3RlbmVyID0gKCkgPT4gcm91dGVyV2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJwYWdlaGlkZVwiLCBfc2F2ZUFwcGxpZWRUcmFuc2l0aW9ucyk7XG4gICAgfVxuICAgIGlmICghc3RhdGUuaW5pdGlhbGl6ZWQpIHtcbiAgICAgIHN0YXJ0TmF2aWdhdGlvbihcIlBPUFwiIC8qIFBvcCAqLywgc3RhdGUubG9jYXRpb24sIHtcbiAgICAgICAgaW5pdGlhbEh5ZHJhdGlvbjogdHJ1ZVxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiByb3V0ZXI7XG4gIH1cbiAgZnVuY3Rpb24gZGlzcG9zZSgpIHtcbiAgICBpZiAodW5saXN0ZW5IaXN0b3J5KSB7XG4gICAgICB1bmxpc3Rlbkhpc3RvcnkoKTtcbiAgICB9XG4gICAgaWYgKHJlbW92ZVBhZ2VIaWRlRXZlbnRMaXN0ZW5lcikge1xuICAgICAgcmVtb3ZlUGFnZUhpZGVFdmVudExpc3RlbmVyKCk7XG4gICAgfVxuICAgIHN1YnNjcmliZXJzLmNsZWFyKCk7XG4gICAgcGVuZGluZ05hdmlnYXRpb25Db250cm9sbGVyICYmIHBlbmRpbmdOYXZpZ2F0aW9uQ29udHJvbGxlci5hYm9ydCgpO1xuICAgIHN0YXRlLmZldGNoZXJzLmZvckVhY2goKF8sIGtleSkgPT4gZGVsZXRlRmV0Y2hlcihrZXkpKTtcbiAgICBzdGF0ZS5ibG9ja2Vycy5mb3JFYWNoKChfLCBrZXkpID0+IGRlbGV0ZUJsb2NrZXIoa2V5KSk7XG4gIH1cbiAgZnVuY3Rpb24gc3Vic2NyaWJlKGZuKSB7XG4gICAgc3Vic2NyaWJlcnMuYWRkKGZuKTtcbiAgICByZXR1cm4gKCkgPT4gc3Vic2NyaWJlcnMuZGVsZXRlKGZuKTtcbiAgfVxuICBmdW5jdGlvbiB1cGRhdGVTdGF0ZShuZXdTdGF0ZSwgb3B0cyA9IHt9KSB7XG4gICAgc3RhdGUgPSB7XG4gICAgICAuLi5zdGF0ZSxcbiAgICAgIC4uLm5ld1N0YXRlXG4gICAgfTtcbiAgICBsZXQgdW5tb3VudGVkRmV0Y2hlcnMgPSBbXTtcbiAgICBsZXQgbW91bnRlZEZldGNoZXJzID0gW107XG4gICAgc3RhdGUuZmV0Y2hlcnMuZm9yRWFjaCgoZmV0Y2hlciwga2V5KSA9PiB7XG4gICAgICBpZiAoZmV0Y2hlci5zdGF0ZSA9PT0gXCJpZGxlXCIpIHtcbiAgICAgICAgaWYgKGZldGNoZXJzUXVldWVkRm9yRGVsZXRpb24uaGFzKGtleSkpIHtcbiAgICAgICAgICB1bm1vdW50ZWRGZXRjaGVycy5wdXNoKGtleSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbW91bnRlZEZldGNoZXJzLnB1c2goa2V5KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICAgIFsuLi5zdWJzY3JpYmVyc10uZm9yRWFjaChcbiAgICAgIChzdWJzY3JpYmVyKSA9PiBzdWJzY3JpYmVyKHN0YXRlLCB7XG4gICAgICAgIGRlbGV0ZWRGZXRjaGVyczogdW5tb3VudGVkRmV0Y2hlcnMsXG4gICAgICAgIHZpZXdUcmFuc2l0aW9uT3B0czogb3B0cy52aWV3VHJhbnNpdGlvbk9wdHMsXG4gICAgICAgIGZsdXNoU3luYzogb3B0cy5mbHVzaFN5bmMgPT09IHRydWVcbiAgICAgIH0pXG4gICAgKTtcbiAgICB1bm1vdW50ZWRGZXRjaGVycy5mb3JFYWNoKChrZXkpID0+IGRlbGV0ZUZldGNoZXIoa2V5KSk7XG4gICAgbW91bnRlZEZldGNoZXJzLmZvckVhY2goKGtleSkgPT4gc3RhdGUuZmV0Y2hlcnMuZGVsZXRlKGtleSkpO1xuICB9XG4gIGZ1bmN0aW9uIGNvbXBsZXRlTmF2aWdhdGlvbihsb2NhdGlvbiwgbmV3U3RhdGUsIHsgZmx1c2hTeW5jIH0gPSB7fSkge1xuICAgIGxldCBpc0FjdGlvblJlbG9hZCA9IHN0YXRlLmFjdGlvbkRhdGEgIT0gbnVsbCAmJiBzdGF0ZS5uYXZpZ2F0aW9uLmZvcm1NZXRob2QgIT0gbnVsbCAmJiBpc011dGF0aW9uTWV0aG9kKHN0YXRlLm5hdmlnYXRpb24uZm9ybU1ldGhvZCkgJiYgc3RhdGUubmF2aWdhdGlvbi5zdGF0ZSA9PT0gXCJsb2FkaW5nXCIgJiYgbG9jYXRpb24uc3RhdGU/Ll9pc1JlZGlyZWN0ICE9PSB0cnVlO1xuICAgIGxldCBhY3Rpb25EYXRhO1xuICAgIGlmIChuZXdTdGF0ZS5hY3Rpb25EYXRhKSB7XG4gICAgICBpZiAoT2JqZWN0LmtleXMobmV3U3RhdGUuYWN0aW9uRGF0YSkubGVuZ3RoID4gMCkge1xuICAgICAgICBhY3Rpb25EYXRhID0gbmV3U3RhdGUuYWN0aW9uRGF0YTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGFjdGlvbkRhdGEgPSBudWxsO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoaXNBY3Rpb25SZWxvYWQpIHtcbiAgICAgIGFjdGlvbkRhdGEgPSBzdGF0ZS5hY3Rpb25EYXRhO1xuICAgIH0gZWxzZSB7XG4gICAgICBhY3Rpb25EYXRhID0gbnVsbDtcbiAgICB9XG4gICAgbGV0IGxvYWRlckRhdGEgPSBuZXdTdGF0ZS5sb2FkZXJEYXRhID8gbWVyZ2VMb2FkZXJEYXRhKFxuICAgICAgc3RhdGUubG9hZGVyRGF0YSxcbiAgICAgIG5ld1N0YXRlLmxvYWRlckRhdGEsXG4gICAgICBuZXdTdGF0ZS5tYXRjaGVzIHx8IFtdLFxuICAgICAgbmV3U3RhdGUuZXJyb3JzXG4gICAgKSA6IHN0YXRlLmxvYWRlckRhdGE7XG4gICAgbGV0IGJsb2NrZXJzID0gc3RhdGUuYmxvY2tlcnM7XG4gICAgaWYgKGJsb2NrZXJzLnNpemUgPiAwKSB7XG4gICAgICBibG9ja2VycyA9IG5ldyBNYXAoYmxvY2tlcnMpO1xuICAgICAgYmxvY2tlcnMuZm9yRWFjaCgoXywgaykgPT4gYmxvY2tlcnMuc2V0KGssIElETEVfQkxPQ0tFUikpO1xuICAgIH1cbiAgICBsZXQgcHJldmVudFNjcm9sbFJlc2V0ID0gcGVuZGluZ1ByZXZlbnRTY3JvbGxSZXNldCA9PT0gdHJ1ZSB8fCBzdGF0ZS5uYXZpZ2F0aW9uLmZvcm1NZXRob2QgIT0gbnVsbCAmJiBpc011dGF0aW9uTWV0aG9kKHN0YXRlLm5hdmlnYXRpb24uZm9ybU1ldGhvZCkgJiYgbG9jYXRpb24uc3RhdGU/Ll9pc1JlZGlyZWN0ICE9PSB0cnVlO1xuICAgIGlmIChpbkZsaWdodERhdGFSb3V0ZXMpIHtcbiAgICAgIGRhdGFSb3V0ZXMgPSBpbkZsaWdodERhdGFSb3V0ZXM7XG4gICAgICBpbkZsaWdodERhdGFSb3V0ZXMgPSB2b2lkIDA7XG4gICAgfVxuICAgIGlmIChpc1VuaW50ZXJydXB0ZWRSZXZhbGlkYXRpb24pIHtcbiAgICB9IGVsc2UgaWYgKHBlbmRpbmdBY3Rpb24gPT09IFwiUE9QXCIgLyogUG9wICovKSB7XG4gICAgfSBlbHNlIGlmIChwZW5kaW5nQWN0aW9uID09PSBcIlBVU0hcIiAvKiBQdXNoICovKSB7XG4gICAgICBpbml0Lmhpc3RvcnkucHVzaChsb2NhdGlvbiwgbG9jYXRpb24uc3RhdGUpO1xuICAgIH0gZWxzZSBpZiAocGVuZGluZ0FjdGlvbiA9PT0gXCJSRVBMQUNFXCIgLyogUmVwbGFjZSAqLykge1xuICAgICAgaW5pdC5oaXN0b3J5LnJlcGxhY2UobG9jYXRpb24sIGxvY2F0aW9uLnN0YXRlKTtcbiAgICB9XG4gICAgbGV0IHZpZXdUcmFuc2l0aW9uT3B0cztcbiAgICBpZiAocGVuZGluZ0FjdGlvbiA9PT0gXCJQT1BcIiAvKiBQb3AgKi8pIHtcbiAgICAgIGxldCBwcmlvclBhdGhzID0gYXBwbGllZFZpZXdUcmFuc2l0aW9ucy5nZXQoc3RhdGUubG9jYXRpb24ucGF0aG5hbWUpO1xuICAgICAgaWYgKHByaW9yUGF0aHMgJiYgcHJpb3JQYXRocy5oYXMobG9jYXRpb24ucGF0aG5hbWUpKSB7XG4gICAgICAgIHZpZXdUcmFuc2l0aW9uT3B0cyA9IHtcbiAgICAgICAgICBjdXJyZW50TG9jYXRpb246IHN0YXRlLmxvY2F0aW9uLFxuICAgICAgICAgIG5leHRMb2NhdGlvbjogbG9jYXRpb25cbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSBpZiAoYXBwbGllZFZpZXdUcmFuc2l0aW9ucy5oYXMobG9jYXRpb24ucGF0aG5hbWUpKSB7XG4gICAgICAgIHZpZXdUcmFuc2l0aW9uT3B0cyA9IHtcbiAgICAgICAgICBjdXJyZW50TG9jYXRpb246IGxvY2F0aW9uLFxuICAgICAgICAgIG5leHRMb2NhdGlvbjogc3RhdGUubG9jYXRpb25cbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHBlbmRpbmdWaWV3VHJhbnNpdGlvbkVuYWJsZWQpIHtcbiAgICAgIGxldCB0b1BhdGhzID0gYXBwbGllZFZpZXdUcmFuc2l0aW9ucy5nZXQoc3RhdGUubG9jYXRpb24ucGF0aG5hbWUpO1xuICAgICAgaWYgKHRvUGF0aHMpIHtcbiAgICAgICAgdG9QYXRocy5hZGQobG9jYXRpb24ucGF0aG5hbWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdG9QYXRocyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KFtsb2NhdGlvbi5wYXRobmFtZV0pO1xuICAgICAgICBhcHBsaWVkVmlld1RyYW5zaXRpb25zLnNldChzdGF0ZS5sb2NhdGlvbi5wYXRobmFtZSwgdG9QYXRocyk7XG4gICAgICB9XG4gICAgICB2aWV3VHJhbnNpdGlvbk9wdHMgPSB7XG4gICAgICAgIGN1cnJlbnRMb2NhdGlvbjogc3RhdGUubG9jYXRpb24sXG4gICAgICAgIG5leHRMb2NhdGlvbjogbG9jYXRpb25cbiAgICAgIH07XG4gICAgfVxuICAgIHVwZGF0ZVN0YXRlKFxuICAgICAge1xuICAgICAgICAuLi5uZXdTdGF0ZSxcbiAgICAgICAgLy8gbWF0Y2hlcywgZXJyb3JzLCBmZXRjaGVycyBnbyB0aHJvdWdoIGFzLWlzXG4gICAgICAgIGFjdGlvbkRhdGEsXG4gICAgICAgIGxvYWRlckRhdGEsXG4gICAgICAgIGhpc3RvcnlBY3Rpb246IHBlbmRpbmdBY3Rpb24sXG4gICAgICAgIGxvY2F0aW9uLFxuICAgICAgICBpbml0aWFsaXplZDogdHJ1ZSxcbiAgICAgICAgbmF2aWdhdGlvbjogSURMRV9OQVZJR0FUSU9OLFxuICAgICAgICByZXZhbGlkYXRpb246IFwiaWRsZVwiLFxuICAgICAgICByZXN0b3JlU2Nyb2xsUG9zaXRpb246IGdldFNhdmVkU2Nyb2xsUG9zaXRpb24oXG4gICAgICAgICAgbG9jYXRpb24sXG4gICAgICAgICAgbmV3U3RhdGUubWF0Y2hlcyB8fCBzdGF0ZS5tYXRjaGVzXG4gICAgICAgICksXG4gICAgICAgIHByZXZlbnRTY3JvbGxSZXNldCxcbiAgICAgICAgYmxvY2tlcnNcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIHZpZXdUcmFuc2l0aW9uT3B0cyxcbiAgICAgICAgZmx1c2hTeW5jOiBmbHVzaFN5bmMgPT09IHRydWVcbiAgICAgIH1cbiAgICApO1xuICAgIHBlbmRpbmdBY3Rpb24gPSBcIlBPUFwiIC8qIFBvcCAqLztcbiAgICBwZW5kaW5nUHJldmVudFNjcm9sbFJlc2V0ID0gZmFsc2U7XG4gICAgcGVuZGluZ1ZpZXdUcmFuc2l0aW9uRW5hYmxlZCA9IGZhbHNlO1xuICAgIGlzVW5pbnRlcnJ1cHRlZFJldmFsaWRhdGlvbiA9IGZhbHNlO1xuICAgIGlzUmV2YWxpZGF0aW9uUmVxdWlyZWQgPSBmYWxzZTtcbiAgICBwZW5kaW5nUmV2YWxpZGF0aW9uRGZkPy5yZXNvbHZlKCk7XG4gICAgcGVuZGluZ1JldmFsaWRhdGlvbkRmZCA9IG51bGw7XG4gIH1cbiAgYXN5bmMgZnVuY3Rpb24gbmF2aWdhdGUodG8sIG9wdHMpIHtcbiAgICBpZiAodHlwZW9mIHRvID09PSBcIm51bWJlclwiKSB7XG4gICAgICBpbml0Lmhpc3RvcnkuZ28odG8pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBsZXQgbm9ybWFsaXplZFBhdGggPSBub3JtYWxpemVUbyhcbiAgICAgIHN0YXRlLmxvY2F0aW9uLFxuICAgICAgc3RhdGUubWF0Y2hlcyxcbiAgICAgIGJhc2VuYW1lLFxuICAgICAgdG8sXG4gICAgICBvcHRzPy5mcm9tUm91dGVJZCxcbiAgICAgIG9wdHM/LnJlbGF0aXZlXG4gICAgKTtcbiAgICBsZXQgeyBwYXRoLCBzdWJtaXNzaW9uLCBlcnJvciB9ID0gbm9ybWFsaXplTmF2aWdhdGVPcHRpb25zKFxuICAgICAgZmFsc2UsXG4gICAgICBub3JtYWxpemVkUGF0aCxcbiAgICAgIG9wdHNcbiAgICApO1xuICAgIGxldCBjdXJyZW50TG9jYXRpb24gPSBzdGF0ZS5sb2NhdGlvbjtcbiAgICBsZXQgbmV4dExvY2F0aW9uID0gY3JlYXRlTG9jYXRpb24oc3RhdGUubG9jYXRpb24sIHBhdGgsIG9wdHMgJiYgb3B0cy5zdGF0ZSk7XG4gICAgbmV4dExvY2F0aW9uID0ge1xuICAgICAgLi4ubmV4dExvY2F0aW9uLFxuICAgICAgLi4uaW5pdC5oaXN0b3J5LmVuY29kZUxvY2F0aW9uKG5leHRMb2NhdGlvbilcbiAgICB9O1xuICAgIGxldCB1c2VyUmVwbGFjZSA9IG9wdHMgJiYgb3B0cy5yZXBsYWNlICE9IG51bGwgPyBvcHRzLnJlcGxhY2UgOiB2b2lkIDA7XG4gICAgbGV0IGhpc3RvcnlBY3Rpb24gPSBcIlBVU0hcIiAvKiBQdXNoICovO1xuICAgIGlmICh1c2VyUmVwbGFjZSA9PT0gdHJ1ZSkge1xuICAgICAgaGlzdG9yeUFjdGlvbiA9IFwiUkVQTEFDRVwiIC8qIFJlcGxhY2UgKi87XG4gICAgfSBlbHNlIGlmICh1c2VyUmVwbGFjZSA9PT0gZmFsc2UpIHtcbiAgICB9IGVsc2UgaWYgKHN1Ym1pc3Npb24gIT0gbnVsbCAmJiBpc011dGF0aW9uTWV0aG9kKHN1Ym1pc3Npb24uZm9ybU1ldGhvZCkgJiYgc3VibWlzc2lvbi5mb3JtQWN0aW9uID09PSBzdGF0ZS5sb2NhdGlvbi5wYXRobmFtZSArIHN0YXRlLmxvY2F0aW9uLnNlYXJjaCkge1xuICAgICAgaGlzdG9yeUFjdGlvbiA9IFwiUkVQTEFDRVwiIC8qIFJlcGxhY2UgKi87XG4gICAgfVxuICAgIGxldCBwcmV2ZW50U2Nyb2xsUmVzZXQgPSBvcHRzICYmIFwicHJldmVudFNjcm9sbFJlc2V0XCIgaW4gb3B0cyA/IG9wdHMucHJldmVudFNjcm9sbFJlc2V0ID09PSB0cnVlIDogdm9pZCAwO1xuICAgIGxldCBmbHVzaFN5bmMgPSAob3B0cyAmJiBvcHRzLmZsdXNoU3luYykgPT09IHRydWU7XG4gICAgbGV0IGJsb2NrZXJLZXkgPSBzaG91bGRCbG9ja05hdmlnYXRpb24oe1xuICAgICAgY3VycmVudExvY2F0aW9uLFxuICAgICAgbmV4dExvY2F0aW9uLFxuICAgICAgaGlzdG9yeUFjdGlvblxuICAgIH0pO1xuICAgIGlmIChibG9ja2VyS2V5KSB7XG4gICAgICB1cGRhdGVCbG9ja2VyKGJsb2NrZXJLZXksIHtcbiAgICAgICAgc3RhdGU6IFwiYmxvY2tlZFwiLFxuICAgICAgICBsb2NhdGlvbjogbmV4dExvY2F0aW9uLFxuICAgICAgICBwcm9jZWVkKCkge1xuICAgICAgICAgIHVwZGF0ZUJsb2NrZXIoYmxvY2tlcktleSwge1xuICAgICAgICAgICAgc3RhdGU6IFwicHJvY2VlZGluZ1wiLFxuICAgICAgICAgICAgcHJvY2VlZDogdm9pZCAwLFxuICAgICAgICAgICAgcmVzZXQ6IHZvaWQgMCxcbiAgICAgICAgICAgIGxvY2F0aW9uOiBuZXh0TG9jYXRpb25cbiAgICAgICAgICB9KTtcbiAgICAgICAgICBuYXZpZ2F0ZSh0bywgb3B0cyk7XG4gICAgICAgIH0sXG4gICAgICAgIHJlc2V0KCkge1xuICAgICAgICAgIGxldCBibG9ja2VycyA9IG5ldyBNYXAoc3RhdGUuYmxvY2tlcnMpO1xuICAgICAgICAgIGJsb2NrZXJzLnNldChibG9ja2VyS2V5LCBJRExFX0JMT0NLRVIpO1xuICAgICAgICAgIHVwZGF0ZVN0YXRlKHsgYmxvY2tlcnMgfSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBhd2FpdCBzdGFydE5hdmlnYXRpb24oaGlzdG9yeUFjdGlvbiwgbmV4dExvY2F0aW9uLCB7XG4gICAgICBzdWJtaXNzaW9uLFxuICAgICAgLy8gU2VuZCB0aHJvdWdoIHRoZSBmb3JtRGF0YSBzZXJpYWxpemF0aW9uIGVycm9yIGlmIHdlIGhhdmUgb25lIHNvIHdlIGNhblxuICAgICAgLy8gcmVuZGVyIGF0IHRoZSByaWdodCBlcnJvciBib3VuZGFyeSBhZnRlciB3ZSBtYXRjaCByb3V0ZXNcbiAgICAgIHBlbmRpbmdFcnJvcjogZXJyb3IsXG4gICAgICBwcmV2ZW50U2Nyb2xsUmVzZXQsXG4gICAgICByZXBsYWNlOiBvcHRzICYmIG9wdHMucmVwbGFjZSxcbiAgICAgIGVuYWJsZVZpZXdUcmFuc2l0aW9uOiBvcHRzICYmIG9wdHMudmlld1RyYW5zaXRpb24sXG4gICAgICBmbHVzaFN5bmNcbiAgICB9KTtcbiAgfVxuICBmdW5jdGlvbiByZXZhbGlkYXRlKCkge1xuICAgIGlmICghcGVuZGluZ1JldmFsaWRhdGlvbkRmZCkge1xuICAgICAgcGVuZGluZ1JldmFsaWRhdGlvbkRmZCA9IGNyZWF0ZURlZmVycmVkKCk7XG4gICAgfVxuICAgIGludGVycnVwdEFjdGl2ZUxvYWRzKCk7XG4gICAgdXBkYXRlU3RhdGUoeyByZXZhbGlkYXRpb246IFwibG9hZGluZ1wiIH0pO1xuICAgIGxldCBwcm9taXNlID0gcGVuZGluZ1JldmFsaWRhdGlvbkRmZC5wcm9taXNlO1xuICAgIGlmIChzdGF0ZS5uYXZpZ2F0aW9uLnN0YXRlID09PSBcInN1Ym1pdHRpbmdcIikge1xuICAgICAgcmV0dXJuIHByb21pc2U7XG4gICAgfVxuICAgIGlmIChzdGF0ZS5uYXZpZ2F0aW9uLnN0YXRlID09PSBcImlkbGVcIikge1xuICAgICAgc3RhcnROYXZpZ2F0aW9uKHN0YXRlLmhpc3RvcnlBY3Rpb24sIHN0YXRlLmxvY2F0aW9uLCB7XG4gICAgICAgIHN0YXJ0VW5pbnRlcnJ1cHRlZFJldmFsaWRhdGlvbjogdHJ1ZVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gcHJvbWlzZTtcbiAgICB9XG4gICAgc3RhcnROYXZpZ2F0aW9uKFxuICAgICAgcGVuZGluZ0FjdGlvbiB8fCBzdGF0ZS5oaXN0b3J5QWN0aW9uLFxuICAgICAgc3RhdGUubmF2aWdhdGlvbi5sb2NhdGlvbixcbiAgICAgIHtcbiAgICAgICAgb3ZlcnJpZGVOYXZpZ2F0aW9uOiBzdGF0ZS5uYXZpZ2F0aW9uLFxuICAgICAgICAvLyBQcm94eSB0aHJvdWdoIGFueSByZW5kaW5nIHZpZXcgdHJhbnNpdGlvblxuICAgICAgICBlbmFibGVWaWV3VHJhbnNpdGlvbjogcGVuZGluZ1ZpZXdUcmFuc2l0aW9uRW5hYmxlZCA9PT0gdHJ1ZVxuICAgICAgfVxuICAgICk7XG4gICAgcmV0dXJuIHByb21pc2U7XG4gIH1cbiAgYXN5bmMgZnVuY3Rpb24gc3RhcnROYXZpZ2F0aW9uKGhpc3RvcnlBY3Rpb24sIGxvY2F0aW9uLCBvcHRzKSB7XG4gICAgcGVuZGluZ05hdmlnYXRpb25Db250cm9sbGVyICYmIHBlbmRpbmdOYXZpZ2F0aW9uQ29udHJvbGxlci5hYm9ydCgpO1xuICAgIHBlbmRpbmdOYXZpZ2F0aW9uQ29udHJvbGxlciA9IG51bGw7XG4gICAgcGVuZGluZ0FjdGlvbiA9IGhpc3RvcnlBY3Rpb247XG4gICAgaXNVbmludGVycnVwdGVkUmV2YWxpZGF0aW9uID0gKG9wdHMgJiYgb3B0cy5zdGFydFVuaW50ZXJydXB0ZWRSZXZhbGlkYXRpb24pID09PSB0cnVlO1xuICAgIHNhdmVTY3JvbGxQb3NpdGlvbihzdGF0ZS5sb2NhdGlvbiwgc3RhdGUubWF0Y2hlcyk7XG4gICAgcGVuZGluZ1ByZXZlbnRTY3JvbGxSZXNldCA9IChvcHRzICYmIG9wdHMucHJldmVudFNjcm9sbFJlc2V0KSA9PT0gdHJ1ZTtcbiAgICBwZW5kaW5nVmlld1RyYW5zaXRpb25FbmFibGVkID0gKG9wdHMgJiYgb3B0cy5lbmFibGVWaWV3VHJhbnNpdGlvbikgPT09IHRydWU7XG4gICAgbGV0IHJvdXRlc1RvVXNlID0gaW5GbGlnaHREYXRhUm91dGVzIHx8IGRhdGFSb3V0ZXM7XG4gICAgbGV0IGxvYWRpbmdOYXZpZ2F0aW9uID0gb3B0cyAmJiBvcHRzLm92ZXJyaWRlTmF2aWdhdGlvbjtcbiAgICBsZXQgbWF0Y2hlcyA9IG1hdGNoUm91dGVzKHJvdXRlc1RvVXNlLCBsb2NhdGlvbiwgYmFzZW5hbWUpO1xuICAgIGxldCBmbHVzaFN5bmMgPSAob3B0cyAmJiBvcHRzLmZsdXNoU3luYykgPT09IHRydWU7XG4gICAgbGV0IGZvZ09mV2FyID0gY2hlY2tGb2dPZldhcihtYXRjaGVzLCByb3V0ZXNUb1VzZSwgbG9jYXRpb24ucGF0aG5hbWUpO1xuICAgIGlmIChmb2dPZldhci5hY3RpdmUgJiYgZm9nT2ZXYXIubWF0Y2hlcykge1xuICAgICAgbWF0Y2hlcyA9IGZvZ09mV2FyLm1hdGNoZXM7XG4gICAgfVxuICAgIGlmICghbWF0Y2hlcykge1xuICAgICAgbGV0IHsgZXJyb3IsIG5vdEZvdW5kTWF0Y2hlcywgcm91dGUgfSA9IGhhbmRsZU5hdmlnYXRpb25hbDQwNChcbiAgICAgICAgbG9jYXRpb24ucGF0aG5hbWVcbiAgICAgICk7XG4gICAgICBjb21wbGV0ZU5hdmlnYXRpb24oXG4gICAgICAgIGxvY2F0aW9uLFxuICAgICAgICB7XG4gICAgICAgICAgbWF0Y2hlczogbm90Rm91bmRNYXRjaGVzLFxuICAgICAgICAgIGxvYWRlckRhdGE6IHt9LFxuICAgICAgICAgIGVycm9yczoge1xuICAgICAgICAgICAgW3JvdXRlLmlkXTogZXJyb3JcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHsgZmx1c2hTeW5jIH1cbiAgICAgICk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChzdGF0ZS5pbml0aWFsaXplZCAmJiAhaXNSZXZhbGlkYXRpb25SZXF1aXJlZCAmJiBpc0hhc2hDaGFuZ2VPbmx5KHN0YXRlLmxvY2F0aW9uLCBsb2NhdGlvbikgJiYgIShvcHRzICYmIG9wdHMuc3VibWlzc2lvbiAmJiBpc011dGF0aW9uTWV0aG9kKG9wdHMuc3VibWlzc2lvbi5mb3JtTWV0aG9kKSkpIHtcbiAgICAgIGNvbXBsZXRlTmF2aWdhdGlvbihsb2NhdGlvbiwgeyBtYXRjaGVzIH0sIHsgZmx1c2hTeW5jIH0pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBwZW5kaW5nTmF2aWdhdGlvbkNvbnRyb2xsZXIgPSBuZXcgQWJvcnRDb250cm9sbGVyKCk7XG4gICAgbGV0IHJlcXVlc3QgPSBjcmVhdGVDbGllbnRTaWRlUmVxdWVzdChcbiAgICAgIGluaXQuaGlzdG9yeSxcbiAgICAgIGxvY2F0aW9uLFxuICAgICAgcGVuZGluZ05hdmlnYXRpb25Db250cm9sbGVyLnNpZ25hbCxcbiAgICAgIG9wdHMgJiYgb3B0cy5zdWJtaXNzaW9uXG4gICAgKTtcbiAgICBsZXQgcGVuZGluZ0FjdGlvblJlc3VsdDtcbiAgICBpZiAob3B0cyAmJiBvcHRzLnBlbmRpbmdFcnJvcikge1xuICAgICAgcGVuZGluZ0FjdGlvblJlc3VsdCA9IFtcbiAgICAgICAgZmluZE5lYXJlc3RCb3VuZGFyeShtYXRjaGVzKS5yb3V0ZS5pZCxcbiAgICAgICAgeyB0eXBlOiBcImVycm9yXCIgLyogZXJyb3IgKi8sIGVycm9yOiBvcHRzLnBlbmRpbmdFcnJvciB9XG4gICAgICBdO1xuICAgIH0gZWxzZSBpZiAob3B0cyAmJiBvcHRzLnN1Ym1pc3Npb24gJiYgaXNNdXRhdGlvbk1ldGhvZChvcHRzLnN1Ym1pc3Npb24uZm9ybU1ldGhvZCkpIHtcbiAgICAgIGxldCBhY3Rpb25SZXN1bHQgPSBhd2FpdCBoYW5kbGVBY3Rpb24oXG4gICAgICAgIHJlcXVlc3QsXG4gICAgICAgIGxvY2F0aW9uLFxuICAgICAgICBvcHRzLnN1Ym1pc3Npb24sXG4gICAgICAgIG1hdGNoZXMsXG4gICAgICAgIGZvZ09mV2FyLmFjdGl2ZSxcbiAgICAgICAgeyByZXBsYWNlOiBvcHRzLnJlcGxhY2UsIGZsdXNoU3luYyB9XG4gICAgICApO1xuICAgICAgaWYgKGFjdGlvblJlc3VsdC5zaG9ydENpcmN1aXRlZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoYWN0aW9uUmVzdWx0LnBlbmRpbmdBY3Rpb25SZXN1bHQpIHtcbiAgICAgICAgbGV0IFtyb3V0ZUlkLCByZXN1bHRdID0gYWN0aW9uUmVzdWx0LnBlbmRpbmdBY3Rpb25SZXN1bHQ7XG4gICAgICAgIGlmIChpc0Vycm9yUmVzdWx0KHJlc3VsdCkgJiYgaXNSb3V0ZUVycm9yUmVzcG9uc2UocmVzdWx0LmVycm9yKSAmJiByZXN1bHQuZXJyb3Iuc3RhdHVzID09PSA0MDQpIHtcbiAgICAgICAgICBwZW5kaW5nTmF2aWdhdGlvbkNvbnRyb2xsZXIgPSBudWxsO1xuICAgICAgICAgIGNvbXBsZXRlTmF2aWdhdGlvbihsb2NhdGlvbiwge1xuICAgICAgICAgICAgbWF0Y2hlczogYWN0aW9uUmVzdWx0Lm1hdGNoZXMsXG4gICAgICAgICAgICBsb2FkZXJEYXRhOiB7fSxcbiAgICAgICAgICAgIGVycm9yczoge1xuICAgICAgICAgICAgICBbcm91dGVJZF06IHJlc3VsdC5lcnJvclxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgbWF0Y2hlcyA9IGFjdGlvblJlc3VsdC5tYXRjaGVzIHx8IG1hdGNoZXM7XG4gICAgICBwZW5kaW5nQWN0aW9uUmVzdWx0ID0gYWN0aW9uUmVzdWx0LnBlbmRpbmdBY3Rpb25SZXN1bHQ7XG4gICAgICBsb2FkaW5nTmF2aWdhdGlvbiA9IGdldExvYWRpbmdOYXZpZ2F0aW9uKGxvY2F0aW9uLCBvcHRzLnN1Ym1pc3Npb24pO1xuICAgICAgZmx1c2hTeW5jID0gZmFsc2U7XG4gICAgICBmb2dPZldhci5hY3RpdmUgPSBmYWxzZTtcbiAgICAgIHJlcXVlc3QgPSBjcmVhdGVDbGllbnRTaWRlUmVxdWVzdChcbiAgICAgICAgaW5pdC5oaXN0b3J5LFxuICAgICAgICByZXF1ZXN0LnVybCxcbiAgICAgICAgcmVxdWVzdC5zaWduYWxcbiAgICAgICk7XG4gICAgfVxuICAgIGxldCB7XG4gICAgICBzaG9ydENpcmN1aXRlZCxcbiAgICAgIG1hdGNoZXM6IHVwZGF0ZWRNYXRjaGVzLFxuICAgICAgbG9hZGVyRGF0YSxcbiAgICAgIGVycm9yc1xuICAgIH0gPSBhd2FpdCBoYW5kbGVMb2FkZXJzKFxuICAgICAgcmVxdWVzdCxcbiAgICAgIGxvY2F0aW9uLFxuICAgICAgbWF0Y2hlcyxcbiAgICAgIGZvZ09mV2FyLmFjdGl2ZSxcbiAgICAgIGxvYWRpbmdOYXZpZ2F0aW9uLFxuICAgICAgb3B0cyAmJiBvcHRzLnN1Ym1pc3Npb24sXG4gICAgICBvcHRzICYmIG9wdHMuZmV0Y2hlclN1Ym1pc3Npb24sXG4gICAgICBvcHRzICYmIG9wdHMucmVwbGFjZSxcbiAgICAgIG9wdHMgJiYgb3B0cy5pbml0aWFsSHlkcmF0aW9uID09PSB0cnVlLFxuICAgICAgZmx1c2hTeW5jLFxuICAgICAgcGVuZGluZ0FjdGlvblJlc3VsdFxuICAgICk7XG4gICAgaWYgKHNob3J0Q2lyY3VpdGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHBlbmRpbmdOYXZpZ2F0aW9uQ29udHJvbGxlciA9IG51bGw7XG4gICAgY29tcGxldGVOYXZpZ2F0aW9uKGxvY2F0aW9uLCB7XG4gICAgICBtYXRjaGVzOiB1cGRhdGVkTWF0Y2hlcyB8fCBtYXRjaGVzLFxuICAgICAgLi4uZ2V0QWN0aW9uRGF0YUZvckNvbW1pdChwZW5kaW5nQWN0aW9uUmVzdWx0KSxcbiAgICAgIGxvYWRlckRhdGEsXG4gICAgICBlcnJvcnNcbiAgICB9KTtcbiAgfVxuICBhc3luYyBmdW5jdGlvbiBoYW5kbGVBY3Rpb24ocmVxdWVzdCwgbG9jYXRpb24sIHN1Ym1pc3Npb24sIG1hdGNoZXMsIGlzRm9nT2ZXYXIsIG9wdHMgPSB7fSkge1xuICAgIGludGVycnVwdEFjdGl2ZUxvYWRzKCk7XG4gICAgbGV0IG5hdmlnYXRpb24gPSBnZXRTdWJtaXR0aW5nTmF2aWdhdGlvbihsb2NhdGlvbiwgc3VibWlzc2lvbik7XG4gICAgdXBkYXRlU3RhdGUoeyBuYXZpZ2F0aW9uIH0sIHsgZmx1c2hTeW5jOiBvcHRzLmZsdXNoU3luYyA9PT0gdHJ1ZSB9KTtcbiAgICBpZiAoaXNGb2dPZldhcikge1xuICAgICAgbGV0IGRpc2NvdmVyUmVzdWx0ID0gYXdhaXQgZGlzY292ZXJSb3V0ZXMoXG4gICAgICAgIG1hdGNoZXMsXG4gICAgICAgIGxvY2F0aW9uLnBhdGhuYW1lLFxuICAgICAgICByZXF1ZXN0LnNpZ25hbFxuICAgICAgKTtcbiAgICAgIGlmIChkaXNjb3ZlclJlc3VsdC50eXBlID09PSBcImFib3J0ZWRcIikge1xuICAgICAgICByZXR1cm4geyBzaG9ydENpcmN1aXRlZDogdHJ1ZSB9O1xuICAgICAgfSBlbHNlIGlmIChkaXNjb3ZlclJlc3VsdC50eXBlID09PSBcImVycm9yXCIpIHtcbiAgICAgICAgbGV0IGJvdW5kYXJ5SWQgPSBmaW5kTmVhcmVzdEJvdW5kYXJ5KGRpc2NvdmVyUmVzdWx0LnBhcnRpYWxNYXRjaGVzKS5yb3V0ZS5pZDtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBtYXRjaGVzOiBkaXNjb3ZlclJlc3VsdC5wYXJ0aWFsTWF0Y2hlcyxcbiAgICAgICAgICBwZW5kaW5nQWN0aW9uUmVzdWx0OiBbXG4gICAgICAgICAgICBib3VuZGFyeUlkLFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICB0eXBlOiBcImVycm9yXCIgLyogZXJyb3IgKi8sXG4gICAgICAgICAgICAgIGVycm9yOiBkaXNjb3ZlclJlc3VsdC5lcnJvclxuICAgICAgICAgICAgfVxuICAgICAgICAgIF1cbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSBpZiAoIWRpc2NvdmVyUmVzdWx0Lm1hdGNoZXMpIHtcbiAgICAgICAgbGV0IHsgbm90Rm91bmRNYXRjaGVzLCBlcnJvciwgcm91dGUgfSA9IGhhbmRsZU5hdmlnYXRpb25hbDQwNChcbiAgICAgICAgICBsb2NhdGlvbi5wYXRobmFtZVxuICAgICAgICApO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIG1hdGNoZXM6IG5vdEZvdW5kTWF0Y2hlcyxcbiAgICAgICAgICBwZW5kaW5nQWN0aW9uUmVzdWx0OiBbXG4gICAgICAgICAgICByb3V0ZS5pZCxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgdHlwZTogXCJlcnJvclwiIC8qIGVycm9yICovLFxuICAgICAgICAgICAgICBlcnJvclxuICAgICAgICAgICAgfVxuICAgICAgICAgIF1cbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG1hdGNoZXMgPSBkaXNjb3ZlclJlc3VsdC5tYXRjaGVzO1xuICAgICAgfVxuICAgIH1cbiAgICBsZXQgcmVzdWx0O1xuICAgIGxldCBhY3Rpb25NYXRjaCA9IGdldFRhcmdldE1hdGNoKG1hdGNoZXMsIGxvY2F0aW9uKTtcbiAgICBpZiAoIWFjdGlvbk1hdGNoLnJvdXRlLmFjdGlvbiAmJiAhYWN0aW9uTWF0Y2gucm91dGUubGF6eSkge1xuICAgICAgcmVzdWx0ID0ge1xuICAgICAgICB0eXBlOiBcImVycm9yXCIgLyogZXJyb3IgKi8sXG4gICAgICAgIGVycm9yOiBnZXRJbnRlcm5hbFJvdXRlckVycm9yKDQwNSwge1xuICAgICAgICAgIG1ldGhvZDogcmVxdWVzdC5tZXRob2QsXG4gICAgICAgICAgcGF0aG5hbWU6IGxvY2F0aW9uLnBhdGhuYW1lLFxuICAgICAgICAgIHJvdXRlSWQ6IGFjdGlvbk1hdGNoLnJvdXRlLmlkXG4gICAgICAgIH0pXG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICBsZXQgcmVzdWx0cyA9IGF3YWl0IGNhbGxEYXRhU3RyYXRlZ3koXG4gICAgICAgIFwiYWN0aW9uXCIsXG4gICAgICAgIHN0YXRlLFxuICAgICAgICByZXF1ZXN0LFxuICAgICAgICBbYWN0aW9uTWF0Y2hdLFxuICAgICAgICBtYXRjaGVzLFxuICAgICAgICBudWxsXG4gICAgICApO1xuICAgICAgcmVzdWx0ID0gcmVzdWx0c1thY3Rpb25NYXRjaC5yb3V0ZS5pZF07XG4gICAgICBpZiAocmVxdWVzdC5zaWduYWwuYWJvcnRlZCkge1xuICAgICAgICByZXR1cm4geyBzaG9ydENpcmN1aXRlZDogdHJ1ZSB9O1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoaXNSZWRpcmVjdFJlc3VsdChyZXN1bHQpKSB7XG4gICAgICBsZXQgcmVwbGFjZTI7XG4gICAgICBpZiAob3B0cyAmJiBvcHRzLnJlcGxhY2UgIT0gbnVsbCkge1xuICAgICAgICByZXBsYWNlMiA9IG9wdHMucmVwbGFjZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxldCBsb2NhdGlvbjIgPSBub3JtYWxpemVSZWRpcmVjdExvY2F0aW9uKFxuICAgICAgICAgIHJlc3VsdC5yZXNwb25zZS5oZWFkZXJzLmdldChcIkxvY2F0aW9uXCIpLFxuICAgICAgICAgIG5ldyBVUkwocmVxdWVzdC51cmwpLFxuICAgICAgICAgIGJhc2VuYW1lXG4gICAgICAgICk7XG4gICAgICAgIHJlcGxhY2UyID0gbG9jYXRpb24yID09PSBzdGF0ZS5sb2NhdGlvbi5wYXRobmFtZSArIHN0YXRlLmxvY2F0aW9uLnNlYXJjaDtcbiAgICAgIH1cbiAgICAgIGF3YWl0IHN0YXJ0UmVkaXJlY3ROYXZpZ2F0aW9uKHJlcXVlc3QsIHJlc3VsdCwgdHJ1ZSwge1xuICAgICAgICBzdWJtaXNzaW9uLFxuICAgICAgICByZXBsYWNlOiByZXBsYWNlMlxuICAgICAgfSk7XG4gICAgICByZXR1cm4geyBzaG9ydENpcmN1aXRlZDogdHJ1ZSB9O1xuICAgIH1cbiAgICBpZiAoaXNFcnJvclJlc3VsdChyZXN1bHQpKSB7XG4gICAgICBsZXQgYm91bmRhcnlNYXRjaCA9IGZpbmROZWFyZXN0Qm91bmRhcnkobWF0Y2hlcywgYWN0aW9uTWF0Y2gucm91dGUuaWQpO1xuICAgICAgaWYgKChvcHRzICYmIG9wdHMucmVwbGFjZSkgIT09IHRydWUpIHtcbiAgICAgICAgcGVuZGluZ0FjdGlvbiA9IFwiUFVTSFwiIC8qIFB1c2ggKi87XG4gICAgICB9XG4gICAgICByZXR1cm4ge1xuICAgICAgICBtYXRjaGVzLFxuICAgICAgICBwZW5kaW5nQWN0aW9uUmVzdWx0OiBbYm91bmRhcnlNYXRjaC5yb3V0ZS5pZCwgcmVzdWx0XVxuICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIG1hdGNoZXMsXG4gICAgICBwZW5kaW5nQWN0aW9uUmVzdWx0OiBbYWN0aW9uTWF0Y2gucm91dGUuaWQsIHJlc3VsdF1cbiAgICB9O1xuICB9XG4gIGFzeW5jIGZ1bmN0aW9uIGhhbmRsZUxvYWRlcnMocmVxdWVzdCwgbG9jYXRpb24sIG1hdGNoZXMsIGlzRm9nT2ZXYXIsIG92ZXJyaWRlTmF2aWdhdGlvbiwgc3VibWlzc2lvbiwgZmV0Y2hlclN1Ym1pc3Npb24sIHJlcGxhY2UyLCBpbml0aWFsSHlkcmF0aW9uLCBmbHVzaFN5bmMsIHBlbmRpbmdBY3Rpb25SZXN1bHQpIHtcbiAgICBsZXQgbG9hZGluZ05hdmlnYXRpb24gPSBvdmVycmlkZU5hdmlnYXRpb24gfHwgZ2V0TG9hZGluZ05hdmlnYXRpb24obG9jYXRpb24sIHN1Ym1pc3Npb24pO1xuICAgIGxldCBhY3RpdmVTdWJtaXNzaW9uID0gc3VibWlzc2lvbiB8fCBmZXRjaGVyU3VibWlzc2lvbiB8fCBnZXRTdWJtaXNzaW9uRnJvbU5hdmlnYXRpb24obG9hZGluZ05hdmlnYXRpb24pO1xuICAgIGxldCBzaG91bGRVcGRhdGVOYXZpZ2F0aW9uU3RhdGUgPSAhaXNVbmludGVycnVwdGVkUmV2YWxpZGF0aW9uICYmICFpbml0aWFsSHlkcmF0aW9uO1xuICAgIGlmIChpc0ZvZ09mV2FyKSB7XG4gICAgICBpZiAoc2hvdWxkVXBkYXRlTmF2aWdhdGlvblN0YXRlKSB7XG4gICAgICAgIGxldCBhY3Rpb25EYXRhID0gZ2V0VXBkYXRlZEFjdGlvbkRhdGEocGVuZGluZ0FjdGlvblJlc3VsdCk7XG4gICAgICAgIHVwZGF0ZVN0YXRlKFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIG5hdmlnYXRpb246IGxvYWRpbmdOYXZpZ2F0aW9uLFxuICAgICAgICAgICAgLi4uYWN0aW9uRGF0YSAhPT0gdm9pZCAwID8geyBhY3Rpb25EYXRhIH0gOiB7fVxuICAgICAgICAgIH0sXG4gICAgICAgICAge1xuICAgICAgICAgICAgZmx1c2hTeW5jXG4gICAgICAgICAgfVxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgbGV0IGRpc2NvdmVyUmVzdWx0ID0gYXdhaXQgZGlzY292ZXJSb3V0ZXMoXG4gICAgICAgIG1hdGNoZXMsXG4gICAgICAgIGxvY2F0aW9uLnBhdGhuYW1lLFxuICAgICAgICByZXF1ZXN0LnNpZ25hbFxuICAgICAgKTtcbiAgICAgIGlmIChkaXNjb3ZlclJlc3VsdC50eXBlID09PSBcImFib3J0ZWRcIikge1xuICAgICAgICByZXR1cm4geyBzaG9ydENpcmN1aXRlZDogdHJ1ZSB9O1xuICAgICAgfSBlbHNlIGlmIChkaXNjb3ZlclJlc3VsdC50eXBlID09PSBcImVycm9yXCIpIHtcbiAgICAgICAgbGV0IGJvdW5kYXJ5SWQgPSBmaW5kTmVhcmVzdEJvdW5kYXJ5KGRpc2NvdmVyUmVzdWx0LnBhcnRpYWxNYXRjaGVzKS5yb3V0ZS5pZDtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBtYXRjaGVzOiBkaXNjb3ZlclJlc3VsdC5wYXJ0aWFsTWF0Y2hlcyxcbiAgICAgICAgICBsb2FkZXJEYXRhOiB7fSxcbiAgICAgICAgICBlcnJvcnM6IHtcbiAgICAgICAgICAgIFtib3VuZGFyeUlkXTogZGlzY292ZXJSZXN1bHQuZXJyb3JcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICB9IGVsc2UgaWYgKCFkaXNjb3ZlclJlc3VsdC5tYXRjaGVzKSB7XG4gICAgICAgIGxldCB7IGVycm9yLCBub3RGb3VuZE1hdGNoZXMsIHJvdXRlIH0gPSBoYW5kbGVOYXZpZ2F0aW9uYWw0MDQoXG4gICAgICAgICAgbG9jYXRpb24ucGF0aG5hbWVcbiAgICAgICAgKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBtYXRjaGVzOiBub3RGb3VuZE1hdGNoZXMsXG4gICAgICAgICAgbG9hZGVyRGF0YToge30sXG4gICAgICAgICAgZXJyb3JzOiB7XG4gICAgICAgICAgICBbcm91dGUuaWRdOiBlcnJvclxuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG1hdGNoZXMgPSBkaXNjb3ZlclJlc3VsdC5tYXRjaGVzO1xuICAgICAgfVxuICAgIH1cbiAgICBsZXQgcm91dGVzVG9Vc2UgPSBpbkZsaWdodERhdGFSb3V0ZXMgfHwgZGF0YVJvdXRlcztcbiAgICBsZXQgW21hdGNoZXNUb0xvYWQsIHJldmFsaWRhdGluZ0ZldGNoZXJzXSA9IGdldE1hdGNoZXNUb0xvYWQoXG4gICAgICBpbml0Lmhpc3RvcnksXG4gICAgICBzdGF0ZSxcbiAgICAgIG1hdGNoZXMsXG4gICAgICBhY3RpdmVTdWJtaXNzaW9uLFxuICAgICAgbG9jYXRpb24sXG4gICAgICBpbml0aWFsSHlkcmF0aW9uID09PSB0cnVlLFxuICAgICAgaXNSZXZhbGlkYXRpb25SZXF1aXJlZCxcbiAgICAgIGNhbmNlbGxlZEZldGNoZXJMb2FkcyxcbiAgICAgIGZldGNoZXJzUXVldWVkRm9yRGVsZXRpb24sXG4gICAgICBmZXRjaExvYWRNYXRjaGVzLFxuICAgICAgZmV0Y2hSZWRpcmVjdElkcyxcbiAgICAgIHJvdXRlc1RvVXNlLFxuICAgICAgYmFzZW5hbWUsXG4gICAgICBwZW5kaW5nQWN0aW9uUmVzdWx0XG4gICAgKTtcbiAgICBwZW5kaW5nTmF2aWdhdGlvbkxvYWRJZCA9ICsraW5jcmVtZW50aW5nTG9hZElkO1xuICAgIGlmIChtYXRjaGVzVG9Mb2FkLmxlbmd0aCA9PT0gMCAmJiByZXZhbGlkYXRpbmdGZXRjaGVycy5sZW5ndGggPT09IDApIHtcbiAgICAgIGxldCB1cGRhdGVkRmV0Y2hlcnMyID0gbWFya0ZldGNoUmVkaXJlY3RzRG9uZSgpO1xuICAgICAgY29tcGxldGVOYXZpZ2F0aW9uKFxuICAgICAgICBsb2NhdGlvbixcbiAgICAgICAge1xuICAgICAgICAgIG1hdGNoZXMsXG4gICAgICAgICAgbG9hZGVyRGF0YToge30sXG4gICAgICAgICAgLy8gQ29tbWl0IHBlbmRpbmcgZXJyb3IgaWYgd2UncmUgc2hvcnQgY2lyY3VpdGluZ1xuICAgICAgICAgIGVycm9yczogcGVuZGluZ0FjdGlvblJlc3VsdCAmJiBpc0Vycm9yUmVzdWx0KHBlbmRpbmdBY3Rpb25SZXN1bHRbMV0pID8geyBbcGVuZGluZ0FjdGlvblJlc3VsdFswXV06IHBlbmRpbmdBY3Rpb25SZXN1bHRbMV0uZXJyb3IgfSA6IG51bGwsXG4gICAgICAgICAgLi4uZ2V0QWN0aW9uRGF0YUZvckNvbW1pdChwZW5kaW5nQWN0aW9uUmVzdWx0KSxcbiAgICAgICAgICAuLi51cGRhdGVkRmV0Y2hlcnMyID8geyBmZXRjaGVyczogbmV3IE1hcChzdGF0ZS5mZXRjaGVycykgfSA6IHt9XG4gICAgICAgIH0sXG4gICAgICAgIHsgZmx1c2hTeW5jIH1cbiAgICAgICk7XG4gICAgICByZXR1cm4geyBzaG9ydENpcmN1aXRlZDogdHJ1ZSB9O1xuICAgIH1cbiAgICBpZiAoc2hvdWxkVXBkYXRlTmF2aWdhdGlvblN0YXRlKSB7XG4gICAgICBsZXQgdXBkYXRlcyA9IHt9O1xuICAgICAgaWYgKCFpc0ZvZ09mV2FyKSB7XG4gICAgICAgIHVwZGF0ZXMubmF2aWdhdGlvbiA9IGxvYWRpbmdOYXZpZ2F0aW9uO1xuICAgICAgICBsZXQgYWN0aW9uRGF0YSA9IGdldFVwZGF0ZWRBY3Rpb25EYXRhKHBlbmRpbmdBY3Rpb25SZXN1bHQpO1xuICAgICAgICBpZiAoYWN0aW9uRGF0YSAhPT0gdm9pZCAwKSB7XG4gICAgICAgICAgdXBkYXRlcy5hY3Rpb25EYXRhID0gYWN0aW9uRGF0YTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHJldmFsaWRhdGluZ0ZldGNoZXJzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgdXBkYXRlcy5mZXRjaGVycyA9IGdldFVwZGF0ZWRSZXZhbGlkYXRpbmdGZXRjaGVycyhyZXZhbGlkYXRpbmdGZXRjaGVycyk7XG4gICAgICB9XG4gICAgICB1cGRhdGVTdGF0ZSh1cGRhdGVzLCB7IGZsdXNoU3luYyB9KTtcbiAgICB9XG4gICAgcmV2YWxpZGF0aW5nRmV0Y2hlcnMuZm9yRWFjaCgocmYpID0+IHtcbiAgICAgIGFib3J0RmV0Y2hlcihyZi5rZXkpO1xuICAgICAgaWYgKHJmLmNvbnRyb2xsZXIpIHtcbiAgICAgICAgZmV0Y2hDb250cm9sbGVycy5zZXQocmYua2V5LCByZi5jb250cm9sbGVyKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBsZXQgYWJvcnRQZW5kaW5nRmV0Y2hSZXZhbGlkYXRpb25zID0gKCkgPT4gcmV2YWxpZGF0aW5nRmV0Y2hlcnMuZm9yRWFjaCgoZikgPT4gYWJvcnRGZXRjaGVyKGYua2V5KSk7XG4gICAgaWYgKHBlbmRpbmdOYXZpZ2F0aW9uQ29udHJvbGxlcikge1xuICAgICAgcGVuZGluZ05hdmlnYXRpb25Db250cm9sbGVyLnNpZ25hbC5hZGRFdmVudExpc3RlbmVyKFxuICAgICAgICBcImFib3J0XCIsXG4gICAgICAgIGFib3J0UGVuZGluZ0ZldGNoUmV2YWxpZGF0aW9uc1xuICAgICAgKTtcbiAgICB9XG4gICAgbGV0IHsgbG9hZGVyUmVzdWx0cywgZmV0Y2hlclJlc3VsdHMgfSA9IGF3YWl0IGNhbGxMb2FkZXJzQW5kTWF5YmVSZXNvbHZlRGF0YShcbiAgICAgIHN0YXRlLFxuICAgICAgbWF0Y2hlcyxcbiAgICAgIG1hdGNoZXNUb0xvYWQsXG4gICAgICByZXZhbGlkYXRpbmdGZXRjaGVycyxcbiAgICAgIHJlcXVlc3RcbiAgICApO1xuICAgIGlmIChyZXF1ZXN0LnNpZ25hbC5hYm9ydGVkKSB7XG4gICAgICByZXR1cm4geyBzaG9ydENpcmN1aXRlZDogdHJ1ZSB9O1xuICAgIH1cbiAgICBpZiAocGVuZGluZ05hdmlnYXRpb25Db250cm9sbGVyKSB7XG4gICAgICBwZW5kaW5nTmF2aWdhdGlvbkNvbnRyb2xsZXIuc2lnbmFsLnJlbW92ZUV2ZW50TGlzdGVuZXIoXG4gICAgICAgIFwiYWJvcnRcIixcbiAgICAgICAgYWJvcnRQZW5kaW5nRmV0Y2hSZXZhbGlkYXRpb25zXG4gICAgICApO1xuICAgIH1cbiAgICByZXZhbGlkYXRpbmdGZXRjaGVycy5mb3JFYWNoKChyZikgPT4gZmV0Y2hDb250cm9sbGVycy5kZWxldGUocmYua2V5KSk7XG4gICAgbGV0IHJlZGlyZWN0MiA9IGZpbmRSZWRpcmVjdChsb2FkZXJSZXN1bHRzKTtcbiAgICBpZiAocmVkaXJlY3QyKSB7XG4gICAgICBhd2FpdCBzdGFydFJlZGlyZWN0TmF2aWdhdGlvbihyZXF1ZXN0LCByZWRpcmVjdDIucmVzdWx0LCB0cnVlLCB7XG4gICAgICAgIHJlcGxhY2U6IHJlcGxhY2UyXG4gICAgICB9KTtcbiAgICAgIHJldHVybiB7IHNob3J0Q2lyY3VpdGVkOiB0cnVlIH07XG4gICAgfVxuICAgIHJlZGlyZWN0MiA9IGZpbmRSZWRpcmVjdChmZXRjaGVyUmVzdWx0cyk7XG4gICAgaWYgKHJlZGlyZWN0Mikge1xuICAgICAgZmV0Y2hSZWRpcmVjdElkcy5hZGQocmVkaXJlY3QyLmtleSk7XG4gICAgICBhd2FpdCBzdGFydFJlZGlyZWN0TmF2aWdhdGlvbihyZXF1ZXN0LCByZWRpcmVjdDIucmVzdWx0LCB0cnVlLCB7XG4gICAgICAgIHJlcGxhY2U6IHJlcGxhY2UyXG4gICAgICB9KTtcbiAgICAgIHJldHVybiB7IHNob3J0Q2lyY3VpdGVkOiB0cnVlIH07XG4gICAgfVxuICAgIGxldCB7IGxvYWRlckRhdGEsIGVycm9ycyB9ID0gcHJvY2Vzc0xvYWRlckRhdGEoXG4gICAgICBzdGF0ZSxcbiAgICAgIG1hdGNoZXMsXG4gICAgICBsb2FkZXJSZXN1bHRzLFxuICAgICAgcGVuZGluZ0FjdGlvblJlc3VsdCxcbiAgICAgIHJldmFsaWRhdGluZ0ZldGNoZXJzLFxuICAgICAgZmV0Y2hlclJlc3VsdHNcbiAgICApO1xuICAgIGlmIChpbml0aWFsSHlkcmF0aW9uICYmIHN0YXRlLmVycm9ycykge1xuICAgICAgZXJyb3JzID0geyAuLi5zdGF0ZS5lcnJvcnMsIC4uLmVycm9ycyB9O1xuICAgIH1cbiAgICBsZXQgdXBkYXRlZEZldGNoZXJzID0gbWFya0ZldGNoUmVkaXJlY3RzRG9uZSgpO1xuICAgIGxldCBkaWRBYm9ydEZldGNoTG9hZHMgPSBhYm9ydFN0YWxlRmV0Y2hMb2FkcyhwZW5kaW5nTmF2aWdhdGlvbkxvYWRJZCk7XG4gICAgbGV0IHNob3VsZFVwZGF0ZUZldGNoZXJzID0gdXBkYXRlZEZldGNoZXJzIHx8IGRpZEFib3J0RmV0Y2hMb2FkcyB8fCByZXZhbGlkYXRpbmdGZXRjaGVycy5sZW5ndGggPiAwO1xuICAgIHJldHVybiB7XG4gICAgICBtYXRjaGVzLFxuICAgICAgbG9hZGVyRGF0YSxcbiAgICAgIGVycm9ycyxcbiAgICAgIC4uLnNob3VsZFVwZGF0ZUZldGNoZXJzID8geyBmZXRjaGVyczogbmV3IE1hcChzdGF0ZS5mZXRjaGVycykgfSA6IHt9XG4gICAgfTtcbiAgfVxuICBmdW5jdGlvbiBnZXRVcGRhdGVkQWN0aW9uRGF0YShwZW5kaW5nQWN0aW9uUmVzdWx0KSB7XG4gICAgaWYgKHBlbmRpbmdBY3Rpb25SZXN1bHQgJiYgIWlzRXJyb3JSZXN1bHQocGVuZGluZ0FjdGlvblJlc3VsdFsxXSkpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIFtwZW5kaW5nQWN0aW9uUmVzdWx0WzBdXTogcGVuZGluZ0FjdGlvblJlc3VsdFsxXS5kYXRhXG4gICAgICB9O1xuICAgIH0gZWxzZSBpZiAoc3RhdGUuYWN0aW9uRGF0YSkge1xuICAgICAgaWYgKE9iamVjdC5rZXlzKHN0YXRlLmFjdGlvbkRhdGEpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBzdGF0ZS5hY3Rpb25EYXRhO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBnZXRVcGRhdGVkUmV2YWxpZGF0aW5nRmV0Y2hlcnMocmV2YWxpZGF0aW5nRmV0Y2hlcnMpIHtcbiAgICByZXZhbGlkYXRpbmdGZXRjaGVycy5mb3JFYWNoKChyZikgPT4ge1xuICAgICAgbGV0IGZldGNoZXIgPSBzdGF0ZS5mZXRjaGVycy5nZXQocmYua2V5KTtcbiAgICAgIGxldCByZXZhbGlkYXRpbmdGZXRjaGVyID0gZ2V0TG9hZGluZ0ZldGNoZXIoXG4gICAgICAgIHZvaWQgMCxcbiAgICAgICAgZmV0Y2hlciA/IGZldGNoZXIuZGF0YSA6IHZvaWQgMFxuICAgICAgKTtcbiAgICAgIHN0YXRlLmZldGNoZXJzLnNldChyZi5rZXksIHJldmFsaWRhdGluZ0ZldGNoZXIpO1xuICAgIH0pO1xuICAgIHJldHVybiBuZXcgTWFwKHN0YXRlLmZldGNoZXJzKTtcbiAgfVxuICBhc3luYyBmdW5jdGlvbiBmZXRjaDIoa2V5LCByb3V0ZUlkLCBocmVmLCBvcHRzKSB7XG4gICAgYWJvcnRGZXRjaGVyKGtleSk7XG4gICAgbGV0IGZsdXNoU3luYyA9IChvcHRzICYmIG9wdHMuZmx1c2hTeW5jKSA9PT0gdHJ1ZTtcbiAgICBsZXQgcm91dGVzVG9Vc2UgPSBpbkZsaWdodERhdGFSb3V0ZXMgfHwgZGF0YVJvdXRlcztcbiAgICBsZXQgbm9ybWFsaXplZFBhdGggPSBub3JtYWxpemVUbyhcbiAgICAgIHN0YXRlLmxvY2F0aW9uLFxuICAgICAgc3RhdGUubWF0Y2hlcyxcbiAgICAgIGJhc2VuYW1lLFxuICAgICAgaHJlZixcbiAgICAgIHJvdXRlSWQsXG4gICAgICBvcHRzPy5yZWxhdGl2ZVxuICAgICk7XG4gICAgbGV0IG1hdGNoZXMgPSBtYXRjaFJvdXRlcyhyb3V0ZXNUb1VzZSwgbm9ybWFsaXplZFBhdGgsIGJhc2VuYW1lKTtcbiAgICBsZXQgZm9nT2ZXYXIgPSBjaGVja0ZvZ09mV2FyKG1hdGNoZXMsIHJvdXRlc1RvVXNlLCBub3JtYWxpemVkUGF0aCk7XG4gICAgaWYgKGZvZ09mV2FyLmFjdGl2ZSAmJiBmb2dPZldhci5tYXRjaGVzKSB7XG4gICAgICBtYXRjaGVzID0gZm9nT2ZXYXIubWF0Y2hlcztcbiAgICB9XG4gICAgaWYgKCFtYXRjaGVzKSB7XG4gICAgICBzZXRGZXRjaGVyRXJyb3IoXG4gICAgICAgIGtleSxcbiAgICAgICAgcm91dGVJZCxcbiAgICAgICAgZ2V0SW50ZXJuYWxSb3V0ZXJFcnJvcig0MDQsIHsgcGF0aG5hbWU6IG5vcm1hbGl6ZWRQYXRoIH0pLFxuICAgICAgICB7IGZsdXNoU3luYyB9XG4gICAgICApO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBsZXQgeyBwYXRoLCBzdWJtaXNzaW9uLCBlcnJvciB9ID0gbm9ybWFsaXplTmF2aWdhdGVPcHRpb25zKFxuICAgICAgdHJ1ZSxcbiAgICAgIG5vcm1hbGl6ZWRQYXRoLFxuICAgICAgb3B0c1xuICAgICk7XG4gICAgaWYgKGVycm9yKSB7XG4gICAgICBzZXRGZXRjaGVyRXJyb3Ioa2V5LCByb3V0ZUlkLCBlcnJvciwgeyBmbHVzaFN5bmMgfSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGxldCBtYXRjaCA9IGdldFRhcmdldE1hdGNoKG1hdGNoZXMsIHBhdGgpO1xuICAgIGxldCBwcmV2ZW50U2Nyb2xsUmVzZXQgPSAob3B0cyAmJiBvcHRzLnByZXZlbnRTY3JvbGxSZXNldCkgPT09IHRydWU7XG4gICAgaWYgKHN1Ym1pc3Npb24gJiYgaXNNdXRhdGlvbk1ldGhvZChzdWJtaXNzaW9uLmZvcm1NZXRob2QpKSB7XG4gICAgICBhd2FpdCBoYW5kbGVGZXRjaGVyQWN0aW9uKFxuICAgICAgICBrZXksXG4gICAgICAgIHJvdXRlSWQsXG4gICAgICAgIHBhdGgsXG4gICAgICAgIG1hdGNoLFxuICAgICAgICBtYXRjaGVzLFxuICAgICAgICBmb2dPZldhci5hY3RpdmUsXG4gICAgICAgIGZsdXNoU3luYyxcbiAgICAgICAgcHJldmVudFNjcm9sbFJlc2V0LFxuICAgICAgICBzdWJtaXNzaW9uXG4gICAgICApO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBmZXRjaExvYWRNYXRjaGVzLnNldChrZXksIHsgcm91dGVJZCwgcGF0aCB9KTtcbiAgICBhd2FpdCBoYW5kbGVGZXRjaGVyTG9hZGVyKFxuICAgICAga2V5LFxuICAgICAgcm91dGVJZCxcbiAgICAgIHBhdGgsXG4gICAgICBtYXRjaCxcbiAgICAgIG1hdGNoZXMsXG4gICAgICBmb2dPZldhci5hY3RpdmUsXG4gICAgICBmbHVzaFN5bmMsXG4gICAgICBwcmV2ZW50U2Nyb2xsUmVzZXQsXG4gICAgICBzdWJtaXNzaW9uXG4gICAgKTtcbiAgfVxuICBhc3luYyBmdW5jdGlvbiBoYW5kbGVGZXRjaGVyQWN0aW9uKGtleSwgcm91dGVJZCwgcGF0aCwgbWF0Y2gsIHJlcXVlc3RNYXRjaGVzLCBpc0ZvZ09mV2FyLCBmbHVzaFN5bmMsIHByZXZlbnRTY3JvbGxSZXNldCwgc3VibWlzc2lvbikge1xuICAgIGludGVycnVwdEFjdGl2ZUxvYWRzKCk7XG4gICAgZmV0Y2hMb2FkTWF0Y2hlcy5kZWxldGUoa2V5KTtcbiAgICBmdW5jdGlvbiBkZXRlY3RBbmRIYW5kbGU0MDVFcnJvcihtKSB7XG4gICAgICBpZiAoIW0ucm91dGUuYWN0aW9uICYmICFtLnJvdXRlLmxhenkpIHtcbiAgICAgICAgbGV0IGVycm9yID0gZ2V0SW50ZXJuYWxSb3V0ZXJFcnJvcig0MDUsIHtcbiAgICAgICAgICBtZXRob2Q6IHN1Ym1pc3Npb24uZm9ybU1ldGhvZCxcbiAgICAgICAgICBwYXRobmFtZTogcGF0aCxcbiAgICAgICAgICByb3V0ZUlkXG4gICAgICAgIH0pO1xuICAgICAgICBzZXRGZXRjaGVyRXJyb3Ioa2V5LCByb3V0ZUlkLCBlcnJvciwgeyBmbHVzaFN5bmMgfSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAoIWlzRm9nT2ZXYXIgJiYgZGV0ZWN0QW5kSGFuZGxlNDA1RXJyb3IobWF0Y2gpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGxldCBleGlzdGluZ0ZldGNoZXIgPSBzdGF0ZS5mZXRjaGVycy5nZXQoa2V5KTtcbiAgICB1cGRhdGVGZXRjaGVyU3RhdGUoa2V5LCBnZXRTdWJtaXR0aW5nRmV0Y2hlcihzdWJtaXNzaW9uLCBleGlzdGluZ0ZldGNoZXIpLCB7XG4gICAgICBmbHVzaFN5bmNcbiAgICB9KTtcbiAgICBsZXQgYWJvcnRDb250cm9sbGVyID0gbmV3IEFib3J0Q29udHJvbGxlcigpO1xuICAgIGxldCBmZXRjaFJlcXVlc3QgPSBjcmVhdGVDbGllbnRTaWRlUmVxdWVzdChcbiAgICAgIGluaXQuaGlzdG9yeSxcbiAgICAgIHBhdGgsXG4gICAgICBhYm9ydENvbnRyb2xsZXIuc2lnbmFsLFxuICAgICAgc3VibWlzc2lvblxuICAgICk7XG4gICAgaWYgKGlzRm9nT2ZXYXIpIHtcbiAgICAgIGxldCBkaXNjb3ZlclJlc3VsdCA9IGF3YWl0IGRpc2NvdmVyUm91dGVzKFxuICAgICAgICByZXF1ZXN0TWF0Y2hlcyxcbiAgICAgICAgcGF0aCxcbiAgICAgICAgZmV0Y2hSZXF1ZXN0LnNpZ25hbFxuICAgICAgKTtcbiAgICAgIGlmIChkaXNjb3ZlclJlc3VsdC50eXBlID09PSBcImFib3J0ZWRcIikge1xuICAgICAgICByZXR1cm47XG4gICAgICB9IGVsc2UgaWYgKGRpc2NvdmVyUmVzdWx0LnR5cGUgPT09IFwiZXJyb3JcIikge1xuICAgICAgICBzZXRGZXRjaGVyRXJyb3Ioa2V5LCByb3V0ZUlkLCBkaXNjb3ZlclJlc3VsdC5lcnJvciwgeyBmbHVzaFN5bmMgfSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH0gZWxzZSBpZiAoIWRpc2NvdmVyUmVzdWx0Lm1hdGNoZXMpIHtcbiAgICAgICAgc2V0RmV0Y2hlckVycm9yKFxuICAgICAgICAgIGtleSxcbiAgICAgICAgICByb3V0ZUlkLFxuICAgICAgICAgIGdldEludGVybmFsUm91dGVyRXJyb3IoNDA0LCB7IHBhdGhuYW1lOiBwYXRoIH0pLFxuICAgICAgICAgIHsgZmx1c2hTeW5jIH1cbiAgICAgICAgKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVxdWVzdE1hdGNoZXMgPSBkaXNjb3ZlclJlc3VsdC5tYXRjaGVzO1xuICAgICAgICBtYXRjaCA9IGdldFRhcmdldE1hdGNoKHJlcXVlc3RNYXRjaGVzLCBwYXRoKTtcbiAgICAgICAgaWYgKGRldGVjdEFuZEhhbmRsZTQwNUVycm9yKG1hdGNoKSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBmZXRjaENvbnRyb2xsZXJzLnNldChrZXksIGFib3J0Q29udHJvbGxlcik7XG4gICAgbGV0IG9yaWdpbmF0aW5nTG9hZElkID0gaW5jcmVtZW50aW5nTG9hZElkO1xuICAgIGxldCBhY3Rpb25SZXN1bHRzID0gYXdhaXQgY2FsbERhdGFTdHJhdGVneShcbiAgICAgIFwiYWN0aW9uXCIsXG4gICAgICBzdGF0ZSxcbiAgICAgIGZldGNoUmVxdWVzdCxcbiAgICAgIFttYXRjaF0sXG4gICAgICByZXF1ZXN0TWF0Y2hlcyxcbiAgICAgIGtleVxuICAgICk7XG4gICAgbGV0IGFjdGlvblJlc3VsdCA9IGFjdGlvblJlc3VsdHNbbWF0Y2gucm91dGUuaWRdO1xuICAgIGlmIChmZXRjaFJlcXVlc3Quc2lnbmFsLmFib3J0ZWQpIHtcbiAgICAgIGlmIChmZXRjaENvbnRyb2xsZXJzLmdldChrZXkpID09PSBhYm9ydENvbnRyb2xsZXIpIHtcbiAgICAgICAgZmV0Y2hDb250cm9sbGVycy5kZWxldGUoa2V5KTtcbiAgICAgIH1cbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGZldGNoZXJzUXVldWVkRm9yRGVsZXRpb24uaGFzKGtleSkpIHtcbiAgICAgIGlmIChpc1JlZGlyZWN0UmVzdWx0KGFjdGlvblJlc3VsdCkgfHwgaXNFcnJvclJlc3VsdChhY3Rpb25SZXN1bHQpKSB7XG4gICAgICAgIHVwZGF0ZUZldGNoZXJTdGF0ZShrZXksIGdldERvbmVGZXRjaGVyKHZvaWQgMCkpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChpc1JlZGlyZWN0UmVzdWx0KGFjdGlvblJlc3VsdCkpIHtcbiAgICAgICAgZmV0Y2hDb250cm9sbGVycy5kZWxldGUoa2V5KTtcbiAgICAgICAgaWYgKHBlbmRpbmdOYXZpZ2F0aW9uTG9hZElkID4gb3JpZ2luYXRpbmdMb2FkSWQpIHtcbiAgICAgICAgICB1cGRhdGVGZXRjaGVyU3RhdGUoa2V5LCBnZXREb25lRmV0Y2hlcih2b2lkIDApKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZmV0Y2hSZWRpcmVjdElkcy5hZGQoa2V5KTtcbiAgICAgICAgICB1cGRhdGVGZXRjaGVyU3RhdGUoa2V5LCBnZXRMb2FkaW5nRmV0Y2hlcihzdWJtaXNzaW9uKSk7XG4gICAgICAgICAgcmV0dXJuIHN0YXJ0UmVkaXJlY3ROYXZpZ2F0aW9uKGZldGNoUmVxdWVzdCwgYWN0aW9uUmVzdWx0LCBmYWxzZSwge1xuICAgICAgICAgICAgZmV0Y2hlclN1Ym1pc3Npb246IHN1Ym1pc3Npb24sXG4gICAgICAgICAgICBwcmV2ZW50U2Nyb2xsUmVzZXRcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGlzRXJyb3JSZXN1bHQoYWN0aW9uUmVzdWx0KSkge1xuICAgICAgICBzZXRGZXRjaGVyRXJyb3Ioa2V5LCByb3V0ZUlkLCBhY3Rpb25SZXN1bHQuZXJyb3IpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuICAgIGxldCBuZXh0TG9jYXRpb24gPSBzdGF0ZS5uYXZpZ2F0aW9uLmxvY2F0aW9uIHx8IHN0YXRlLmxvY2F0aW9uO1xuICAgIGxldCByZXZhbGlkYXRpb25SZXF1ZXN0ID0gY3JlYXRlQ2xpZW50U2lkZVJlcXVlc3QoXG4gICAgICBpbml0Lmhpc3RvcnksXG4gICAgICBuZXh0TG9jYXRpb24sXG4gICAgICBhYm9ydENvbnRyb2xsZXIuc2lnbmFsXG4gICAgKTtcbiAgICBsZXQgcm91dGVzVG9Vc2UgPSBpbkZsaWdodERhdGFSb3V0ZXMgfHwgZGF0YVJvdXRlcztcbiAgICBsZXQgbWF0Y2hlcyA9IHN0YXRlLm5hdmlnYXRpb24uc3RhdGUgIT09IFwiaWRsZVwiID8gbWF0Y2hSb3V0ZXMocm91dGVzVG9Vc2UsIHN0YXRlLm5hdmlnYXRpb24ubG9jYXRpb24sIGJhc2VuYW1lKSA6IHN0YXRlLm1hdGNoZXM7XG4gICAgaW52YXJpYW50KG1hdGNoZXMsIFwiRGlkbid0IGZpbmQgYW55IG1hdGNoZXMgYWZ0ZXIgZmV0Y2hlciBhY3Rpb25cIik7XG4gICAgbGV0IGxvYWRJZCA9ICsraW5jcmVtZW50aW5nTG9hZElkO1xuICAgIGZldGNoUmVsb2FkSWRzLnNldChrZXksIGxvYWRJZCk7XG4gICAgbGV0IGxvYWRGZXRjaGVyID0gZ2V0TG9hZGluZ0ZldGNoZXIoc3VibWlzc2lvbiwgYWN0aW9uUmVzdWx0LmRhdGEpO1xuICAgIHN0YXRlLmZldGNoZXJzLnNldChrZXksIGxvYWRGZXRjaGVyKTtcbiAgICBsZXQgW21hdGNoZXNUb0xvYWQsIHJldmFsaWRhdGluZ0ZldGNoZXJzXSA9IGdldE1hdGNoZXNUb0xvYWQoXG4gICAgICBpbml0Lmhpc3RvcnksXG4gICAgICBzdGF0ZSxcbiAgICAgIG1hdGNoZXMsXG4gICAgICBzdWJtaXNzaW9uLFxuICAgICAgbmV4dExvY2F0aW9uLFxuICAgICAgZmFsc2UsXG4gICAgICBpc1JldmFsaWRhdGlvblJlcXVpcmVkLFxuICAgICAgY2FuY2VsbGVkRmV0Y2hlckxvYWRzLFxuICAgICAgZmV0Y2hlcnNRdWV1ZWRGb3JEZWxldGlvbixcbiAgICAgIGZldGNoTG9hZE1hdGNoZXMsXG4gICAgICBmZXRjaFJlZGlyZWN0SWRzLFxuICAgICAgcm91dGVzVG9Vc2UsXG4gICAgICBiYXNlbmFtZSxcbiAgICAgIFttYXRjaC5yb3V0ZS5pZCwgYWN0aW9uUmVzdWx0XVxuICAgICk7XG4gICAgcmV2YWxpZGF0aW5nRmV0Y2hlcnMuZmlsdGVyKChyZikgPT4gcmYua2V5ICE9PSBrZXkpLmZvckVhY2goKHJmKSA9PiB7XG4gICAgICBsZXQgc3RhbGVLZXkgPSByZi5rZXk7XG4gICAgICBsZXQgZXhpc3RpbmdGZXRjaGVyMiA9IHN0YXRlLmZldGNoZXJzLmdldChzdGFsZUtleSk7XG4gICAgICBsZXQgcmV2YWxpZGF0aW5nRmV0Y2hlciA9IGdldExvYWRpbmdGZXRjaGVyKFxuICAgICAgICB2b2lkIDAsXG4gICAgICAgIGV4aXN0aW5nRmV0Y2hlcjIgPyBleGlzdGluZ0ZldGNoZXIyLmRhdGEgOiB2b2lkIDBcbiAgICAgICk7XG4gICAgICBzdGF0ZS5mZXRjaGVycy5zZXQoc3RhbGVLZXksIHJldmFsaWRhdGluZ0ZldGNoZXIpO1xuICAgICAgYWJvcnRGZXRjaGVyKHN0YWxlS2V5KTtcbiAgICAgIGlmIChyZi5jb250cm9sbGVyKSB7XG4gICAgICAgIGZldGNoQ29udHJvbGxlcnMuc2V0KHN0YWxlS2V5LCByZi5jb250cm9sbGVyKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICB1cGRhdGVTdGF0ZSh7IGZldGNoZXJzOiBuZXcgTWFwKHN0YXRlLmZldGNoZXJzKSB9KTtcbiAgICBsZXQgYWJvcnRQZW5kaW5nRmV0Y2hSZXZhbGlkYXRpb25zID0gKCkgPT4gcmV2YWxpZGF0aW5nRmV0Y2hlcnMuZm9yRWFjaCgocmYpID0+IGFib3J0RmV0Y2hlcihyZi5rZXkpKTtcbiAgICBhYm9ydENvbnRyb2xsZXIuc2lnbmFsLmFkZEV2ZW50TGlzdGVuZXIoXG4gICAgICBcImFib3J0XCIsXG4gICAgICBhYm9ydFBlbmRpbmdGZXRjaFJldmFsaWRhdGlvbnNcbiAgICApO1xuICAgIGxldCB7IGxvYWRlclJlc3VsdHMsIGZldGNoZXJSZXN1bHRzIH0gPSBhd2FpdCBjYWxsTG9hZGVyc0FuZE1heWJlUmVzb2x2ZURhdGEoXG4gICAgICBzdGF0ZSxcbiAgICAgIG1hdGNoZXMsXG4gICAgICBtYXRjaGVzVG9Mb2FkLFxuICAgICAgcmV2YWxpZGF0aW5nRmV0Y2hlcnMsXG4gICAgICByZXZhbGlkYXRpb25SZXF1ZXN0XG4gICAgKTtcbiAgICBpZiAoYWJvcnRDb250cm9sbGVyLnNpZ25hbC5hYm9ydGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGFib3J0Q29udHJvbGxlci5zaWduYWwucmVtb3ZlRXZlbnRMaXN0ZW5lcihcbiAgICAgIFwiYWJvcnRcIixcbiAgICAgIGFib3J0UGVuZGluZ0ZldGNoUmV2YWxpZGF0aW9uc1xuICAgICk7XG4gICAgZmV0Y2hSZWxvYWRJZHMuZGVsZXRlKGtleSk7XG4gICAgZmV0Y2hDb250cm9sbGVycy5kZWxldGUoa2V5KTtcbiAgICByZXZhbGlkYXRpbmdGZXRjaGVycy5mb3JFYWNoKChyKSA9PiBmZXRjaENvbnRyb2xsZXJzLmRlbGV0ZShyLmtleSkpO1xuICAgIGxldCByZWRpcmVjdDIgPSBmaW5kUmVkaXJlY3QobG9hZGVyUmVzdWx0cyk7XG4gICAgaWYgKHJlZGlyZWN0Mikge1xuICAgICAgcmV0dXJuIHN0YXJ0UmVkaXJlY3ROYXZpZ2F0aW9uKFxuICAgICAgICByZXZhbGlkYXRpb25SZXF1ZXN0LFxuICAgICAgICByZWRpcmVjdDIucmVzdWx0LFxuICAgICAgICBmYWxzZSxcbiAgICAgICAgeyBwcmV2ZW50U2Nyb2xsUmVzZXQgfVxuICAgICAgKTtcbiAgICB9XG4gICAgcmVkaXJlY3QyID0gZmluZFJlZGlyZWN0KGZldGNoZXJSZXN1bHRzKTtcbiAgICBpZiAocmVkaXJlY3QyKSB7XG4gICAgICBmZXRjaFJlZGlyZWN0SWRzLmFkZChyZWRpcmVjdDIua2V5KTtcbiAgICAgIHJldHVybiBzdGFydFJlZGlyZWN0TmF2aWdhdGlvbihcbiAgICAgICAgcmV2YWxpZGF0aW9uUmVxdWVzdCxcbiAgICAgICAgcmVkaXJlY3QyLnJlc3VsdCxcbiAgICAgICAgZmFsc2UsXG4gICAgICAgIHsgcHJldmVudFNjcm9sbFJlc2V0IH1cbiAgICAgICk7XG4gICAgfVxuICAgIGxldCB7IGxvYWRlckRhdGEsIGVycm9ycyB9ID0gcHJvY2Vzc0xvYWRlckRhdGEoXG4gICAgICBzdGF0ZSxcbiAgICAgIG1hdGNoZXMsXG4gICAgICBsb2FkZXJSZXN1bHRzLFxuICAgICAgdm9pZCAwLFxuICAgICAgcmV2YWxpZGF0aW5nRmV0Y2hlcnMsXG4gICAgICBmZXRjaGVyUmVzdWx0c1xuICAgICk7XG4gICAgaWYgKHN0YXRlLmZldGNoZXJzLmhhcyhrZXkpKSB7XG4gICAgICBsZXQgZG9uZUZldGNoZXIgPSBnZXREb25lRmV0Y2hlcihhY3Rpb25SZXN1bHQuZGF0YSk7XG4gICAgICBzdGF0ZS5mZXRjaGVycy5zZXQoa2V5LCBkb25lRmV0Y2hlcik7XG4gICAgfVxuICAgIGFib3J0U3RhbGVGZXRjaExvYWRzKGxvYWRJZCk7XG4gICAgaWYgKHN0YXRlLm5hdmlnYXRpb24uc3RhdGUgPT09IFwibG9hZGluZ1wiICYmIGxvYWRJZCA+IHBlbmRpbmdOYXZpZ2F0aW9uTG9hZElkKSB7XG4gICAgICBpbnZhcmlhbnQocGVuZGluZ0FjdGlvbiwgXCJFeHBlY3RlZCBwZW5kaW5nIGFjdGlvblwiKTtcbiAgICAgIHBlbmRpbmdOYXZpZ2F0aW9uQ29udHJvbGxlciAmJiBwZW5kaW5nTmF2aWdhdGlvbkNvbnRyb2xsZXIuYWJvcnQoKTtcbiAgICAgIGNvbXBsZXRlTmF2aWdhdGlvbihzdGF0ZS5uYXZpZ2F0aW9uLmxvY2F0aW9uLCB7XG4gICAgICAgIG1hdGNoZXMsXG4gICAgICAgIGxvYWRlckRhdGEsXG4gICAgICAgIGVycm9ycyxcbiAgICAgICAgZmV0Y2hlcnM6IG5ldyBNYXAoc3RhdGUuZmV0Y2hlcnMpXG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdXBkYXRlU3RhdGUoe1xuICAgICAgICBlcnJvcnMsXG4gICAgICAgIGxvYWRlckRhdGE6IG1lcmdlTG9hZGVyRGF0YShcbiAgICAgICAgICBzdGF0ZS5sb2FkZXJEYXRhLFxuICAgICAgICAgIGxvYWRlckRhdGEsXG4gICAgICAgICAgbWF0Y2hlcyxcbiAgICAgICAgICBlcnJvcnNcbiAgICAgICAgKSxcbiAgICAgICAgZmV0Y2hlcnM6IG5ldyBNYXAoc3RhdGUuZmV0Y2hlcnMpXG4gICAgICB9KTtcbiAgICAgIGlzUmV2YWxpZGF0aW9uUmVxdWlyZWQgPSBmYWxzZTtcbiAgICB9XG4gIH1cbiAgYXN5bmMgZnVuY3Rpb24gaGFuZGxlRmV0Y2hlckxvYWRlcihrZXksIHJvdXRlSWQsIHBhdGgsIG1hdGNoLCBtYXRjaGVzLCBpc0ZvZ09mV2FyLCBmbHVzaFN5bmMsIHByZXZlbnRTY3JvbGxSZXNldCwgc3VibWlzc2lvbikge1xuICAgIGxldCBleGlzdGluZ0ZldGNoZXIgPSBzdGF0ZS5mZXRjaGVycy5nZXQoa2V5KTtcbiAgICB1cGRhdGVGZXRjaGVyU3RhdGUoXG4gICAgICBrZXksXG4gICAgICBnZXRMb2FkaW5nRmV0Y2hlcihcbiAgICAgICAgc3VibWlzc2lvbixcbiAgICAgICAgZXhpc3RpbmdGZXRjaGVyID8gZXhpc3RpbmdGZXRjaGVyLmRhdGEgOiB2b2lkIDBcbiAgICAgICksXG4gICAgICB7IGZsdXNoU3luYyB9XG4gICAgKTtcbiAgICBsZXQgYWJvcnRDb250cm9sbGVyID0gbmV3IEFib3J0Q29udHJvbGxlcigpO1xuICAgIGxldCBmZXRjaFJlcXVlc3QgPSBjcmVhdGVDbGllbnRTaWRlUmVxdWVzdChcbiAgICAgIGluaXQuaGlzdG9yeSxcbiAgICAgIHBhdGgsXG4gICAgICBhYm9ydENvbnRyb2xsZXIuc2lnbmFsXG4gICAgKTtcbiAgICBpZiAoaXNGb2dPZldhcikge1xuICAgICAgbGV0IGRpc2NvdmVyUmVzdWx0ID0gYXdhaXQgZGlzY292ZXJSb3V0ZXMoXG4gICAgICAgIG1hdGNoZXMsXG4gICAgICAgIHBhdGgsXG4gICAgICAgIGZldGNoUmVxdWVzdC5zaWduYWxcbiAgICAgICk7XG4gICAgICBpZiAoZGlzY292ZXJSZXN1bHQudHlwZSA9PT0gXCJhYm9ydGVkXCIpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfSBlbHNlIGlmIChkaXNjb3ZlclJlc3VsdC50eXBlID09PSBcImVycm9yXCIpIHtcbiAgICAgICAgc2V0RmV0Y2hlckVycm9yKGtleSwgcm91dGVJZCwgZGlzY292ZXJSZXN1bHQuZXJyb3IsIHsgZmx1c2hTeW5jIH0pO1xuICAgICAgICByZXR1cm47XG4gICAgICB9IGVsc2UgaWYgKCFkaXNjb3ZlclJlc3VsdC5tYXRjaGVzKSB7XG4gICAgICAgIHNldEZldGNoZXJFcnJvcihcbiAgICAgICAgICBrZXksXG4gICAgICAgICAgcm91dGVJZCxcbiAgICAgICAgICBnZXRJbnRlcm5hbFJvdXRlckVycm9yKDQwNCwgeyBwYXRobmFtZTogcGF0aCB9KSxcbiAgICAgICAgICB7IGZsdXNoU3luYyB9XG4gICAgICAgICk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG1hdGNoZXMgPSBkaXNjb3ZlclJlc3VsdC5tYXRjaGVzO1xuICAgICAgICBtYXRjaCA9IGdldFRhcmdldE1hdGNoKG1hdGNoZXMsIHBhdGgpO1xuICAgICAgfVxuICAgIH1cbiAgICBmZXRjaENvbnRyb2xsZXJzLnNldChrZXksIGFib3J0Q29udHJvbGxlcik7XG4gICAgbGV0IG9yaWdpbmF0aW5nTG9hZElkID0gaW5jcmVtZW50aW5nTG9hZElkO1xuICAgIGxldCByZXN1bHRzID0gYXdhaXQgY2FsbERhdGFTdHJhdGVneShcbiAgICAgIFwibG9hZGVyXCIsXG4gICAgICBzdGF0ZSxcbiAgICAgIGZldGNoUmVxdWVzdCxcbiAgICAgIFttYXRjaF0sXG4gICAgICBtYXRjaGVzLFxuICAgICAga2V5XG4gICAgKTtcbiAgICBsZXQgcmVzdWx0ID0gcmVzdWx0c1ttYXRjaC5yb3V0ZS5pZF07XG4gICAgaWYgKGZldGNoQ29udHJvbGxlcnMuZ2V0KGtleSkgPT09IGFib3J0Q29udHJvbGxlcikge1xuICAgICAgZmV0Y2hDb250cm9sbGVycy5kZWxldGUoa2V5KTtcbiAgICB9XG4gICAgaWYgKGZldGNoUmVxdWVzdC5zaWduYWwuYWJvcnRlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoZmV0Y2hlcnNRdWV1ZWRGb3JEZWxldGlvbi5oYXMoa2V5KSkge1xuICAgICAgdXBkYXRlRmV0Y2hlclN0YXRlKGtleSwgZ2V0RG9uZUZldGNoZXIodm9pZCAwKSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChpc1JlZGlyZWN0UmVzdWx0KHJlc3VsdCkpIHtcbiAgICAgIGlmIChwZW5kaW5nTmF2aWdhdGlvbkxvYWRJZCA+IG9yaWdpbmF0aW5nTG9hZElkKSB7XG4gICAgICAgIHVwZGF0ZUZldGNoZXJTdGF0ZShrZXksIGdldERvbmVGZXRjaGVyKHZvaWQgMCkpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmZXRjaFJlZGlyZWN0SWRzLmFkZChrZXkpO1xuICAgICAgICBhd2FpdCBzdGFydFJlZGlyZWN0TmF2aWdhdGlvbihmZXRjaFJlcXVlc3QsIHJlc3VsdCwgZmFsc2UsIHtcbiAgICAgICAgICBwcmV2ZW50U2Nyb2xsUmVzZXRcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGlzRXJyb3JSZXN1bHQocmVzdWx0KSkge1xuICAgICAgc2V0RmV0Y2hlckVycm9yKGtleSwgcm91dGVJZCwgcmVzdWx0LmVycm9yKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdXBkYXRlRmV0Y2hlclN0YXRlKGtleSwgZ2V0RG9uZUZldGNoZXIocmVzdWx0LmRhdGEpKTtcbiAgfVxuICBhc3luYyBmdW5jdGlvbiBzdGFydFJlZGlyZWN0TmF2aWdhdGlvbihyZXF1ZXN0LCByZWRpcmVjdDIsIGlzTmF2aWdhdGlvbiwge1xuICAgIHN1Ym1pc3Npb24sXG4gICAgZmV0Y2hlclN1Ym1pc3Npb24sXG4gICAgcHJldmVudFNjcm9sbFJlc2V0LFxuICAgIHJlcGxhY2U6IHJlcGxhY2UyXG4gIH0gPSB7fSkge1xuICAgIGlmIChyZWRpcmVjdDIucmVzcG9uc2UuaGVhZGVycy5oYXMoXCJYLVJlbWl4LVJldmFsaWRhdGVcIikpIHtcbiAgICAgIGlzUmV2YWxpZGF0aW9uUmVxdWlyZWQgPSB0cnVlO1xuICAgIH1cbiAgICBsZXQgbG9jYXRpb24gPSByZWRpcmVjdDIucmVzcG9uc2UuaGVhZGVycy5nZXQoXCJMb2NhdGlvblwiKTtcbiAgICBpbnZhcmlhbnQobG9jYXRpb24sIFwiRXhwZWN0ZWQgYSBMb2NhdGlvbiBoZWFkZXIgb24gdGhlIHJlZGlyZWN0IFJlc3BvbnNlXCIpO1xuICAgIGxvY2F0aW9uID0gbm9ybWFsaXplUmVkaXJlY3RMb2NhdGlvbihcbiAgICAgIGxvY2F0aW9uLFxuICAgICAgbmV3IFVSTChyZXF1ZXN0LnVybCksXG4gICAgICBiYXNlbmFtZVxuICAgICk7XG4gICAgbGV0IHJlZGlyZWN0TG9jYXRpb24gPSBjcmVhdGVMb2NhdGlvbihzdGF0ZS5sb2NhdGlvbiwgbG9jYXRpb24sIHtcbiAgICAgIF9pc1JlZGlyZWN0OiB0cnVlXG4gICAgfSk7XG4gICAgaWYgKGlzQnJvd3NlcjIpIHtcbiAgICAgIGxldCBpc0RvY3VtZW50UmVsb2FkID0gZmFsc2U7XG4gICAgICBpZiAocmVkaXJlY3QyLnJlc3BvbnNlLmhlYWRlcnMuaGFzKFwiWC1SZW1peC1SZWxvYWQtRG9jdW1lbnRcIikpIHtcbiAgICAgICAgaXNEb2N1bWVudFJlbG9hZCA9IHRydWU7XG4gICAgICB9IGVsc2UgaWYgKEFCU09MVVRFX1VSTF9SRUdFWC50ZXN0KGxvY2F0aW9uKSkge1xuICAgICAgICBjb25zdCB1cmwgPSBpbml0Lmhpc3RvcnkuY3JlYXRlVVJMKGxvY2F0aW9uKTtcbiAgICAgICAgaXNEb2N1bWVudFJlbG9hZCA9IC8vIEhhcmQgcmVsb2FkIGlmIGl0J3MgYW4gYWJzb2x1dGUgVVJMIHRvIGEgbmV3IG9yaWdpblxuICAgICAgICB1cmwub3JpZ2luICE9PSByb3V0ZXJXaW5kb3cubG9jYXRpb24ub3JpZ2luIHx8IC8vIEhhcmQgcmVsb2FkIGlmIGl0J3MgYW4gYWJzb2x1dGUgVVJMIHRoYXQgZG9lcyBub3QgbWF0Y2ggb3VyIGJhc2VuYW1lXG4gICAgICAgIHN0cmlwQmFzZW5hbWUodXJsLnBhdGhuYW1lLCBiYXNlbmFtZSkgPT0gbnVsbDtcbiAgICAgIH1cbiAgICAgIGlmIChpc0RvY3VtZW50UmVsb2FkKSB7XG4gICAgICAgIGlmIChyZXBsYWNlMikge1xuICAgICAgICAgIHJvdXRlcldpbmRvdy5sb2NhdGlvbi5yZXBsYWNlKGxvY2F0aW9uKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByb3V0ZXJXaW5kb3cubG9jYXRpb24uYXNzaWduKGxvY2F0aW9uKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuICAgIHBlbmRpbmdOYXZpZ2F0aW9uQ29udHJvbGxlciA9IG51bGw7XG4gICAgbGV0IHJlZGlyZWN0TmF2aWdhdGlvblR5cGUgPSByZXBsYWNlMiA9PT0gdHJ1ZSB8fCByZWRpcmVjdDIucmVzcG9uc2UuaGVhZGVycy5oYXMoXCJYLVJlbWl4LVJlcGxhY2VcIikgPyBcIlJFUExBQ0VcIiAvKiBSZXBsYWNlICovIDogXCJQVVNIXCIgLyogUHVzaCAqLztcbiAgICBsZXQgeyBmb3JtTWV0aG9kLCBmb3JtQWN0aW9uLCBmb3JtRW5jVHlwZSB9ID0gc3RhdGUubmF2aWdhdGlvbjtcbiAgICBpZiAoIXN1Ym1pc3Npb24gJiYgIWZldGNoZXJTdWJtaXNzaW9uICYmIGZvcm1NZXRob2QgJiYgZm9ybUFjdGlvbiAmJiBmb3JtRW5jVHlwZSkge1xuICAgICAgc3VibWlzc2lvbiA9IGdldFN1Ym1pc3Npb25Gcm9tTmF2aWdhdGlvbihzdGF0ZS5uYXZpZ2F0aW9uKTtcbiAgICB9XG4gICAgbGV0IGFjdGl2ZVN1Ym1pc3Npb24gPSBzdWJtaXNzaW9uIHx8IGZldGNoZXJTdWJtaXNzaW9uO1xuICAgIGlmIChyZWRpcmVjdFByZXNlcnZlTWV0aG9kU3RhdHVzQ29kZXMuaGFzKHJlZGlyZWN0Mi5yZXNwb25zZS5zdGF0dXMpICYmIGFjdGl2ZVN1Ym1pc3Npb24gJiYgaXNNdXRhdGlvbk1ldGhvZChhY3RpdmVTdWJtaXNzaW9uLmZvcm1NZXRob2QpKSB7XG4gICAgICBhd2FpdCBzdGFydE5hdmlnYXRpb24ocmVkaXJlY3ROYXZpZ2F0aW9uVHlwZSwgcmVkaXJlY3RMb2NhdGlvbiwge1xuICAgICAgICBzdWJtaXNzaW9uOiB7XG4gICAgICAgICAgLi4uYWN0aXZlU3VibWlzc2lvbixcbiAgICAgICAgICBmb3JtQWN0aW9uOiBsb2NhdGlvblxuICAgICAgICB9LFxuICAgICAgICAvLyBQcmVzZXJ2ZSB0aGVzZSBmbGFncyBhY3Jvc3MgcmVkaXJlY3RzXG4gICAgICAgIHByZXZlbnRTY3JvbGxSZXNldDogcHJldmVudFNjcm9sbFJlc2V0IHx8IHBlbmRpbmdQcmV2ZW50U2Nyb2xsUmVzZXQsXG4gICAgICAgIGVuYWJsZVZpZXdUcmFuc2l0aW9uOiBpc05hdmlnYXRpb24gPyBwZW5kaW5nVmlld1RyYW5zaXRpb25FbmFibGVkIDogdm9pZCAwXG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgbGV0IG92ZXJyaWRlTmF2aWdhdGlvbiA9IGdldExvYWRpbmdOYXZpZ2F0aW9uKFxuICAgICAgICByZWRpcmVjdExvY2F0aW9uLFxuICAgICAgICBzdWJtaXNzaW9uXG4gICAgICApO1xuICAgICAgYXdhaXQgc3RhcnROYXZpZ2F0aW9uKHJlZGlyZWN0TmF2aWdhdGlvblR5cGUsIHJlZGlyZWN0TG9jYXRpb24sIHtcbiAgICAgICAgb3ZlcnJpZGVOYXZpZ2F0aW9uLFxuICAgICAgICAvLyBTZW5kIGZldGNoZXIgc3VibWlzc2lvbnMgdGhyb3VnaCBmb3Igc2hvdWxkUmV2YWxpZGF0ZVxuICAgICAgICBmZXRjaGVyU3VibWlzc2lvbixcbiAgICAgICAgLy8gUHJlc2VydmUgdGhlc2UgZmxhZ3MgYWNyb3NzIHJlZGlyZWN0c1xuICAgICAgICBwcmV2ZW50U2Nyb2xsUmVzZXQ6IHByZXZlbnRTY3JvbGxSZXNldCB8fCBwZW5kaW5nUHJldmVudFNjcm9sbFJlc2V0LFxuICAgICAgICBlbmFibGVWaWV3VHJhbnNpdGlvbjogaXNOYXZpZ2F0aW9uID8gcGVuZGluZ1ZpZXdUcmFuc2l0aW9uRW5hYmxlZCA6IHZvaWQgMFxuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIGFzeW5jIGZ1bmN0aW9uIGNhbGxEYXRhU3RyYXRlZ3kodHlwZSwgc3RhdGUyLCByZXF1ZXN0LCBtYXRjaGVzVG9Mb2FkLCBtYXRjaGVzLCBmZXRjaGVyS2V5KSB7XG4gICAgbGV0IHJlc3VsdHM7XG4gICAgbGV0IGRhdGFSZXN1bHRzID0ge307XG4gICAgdHJ5IHtcbiAgICAgIHJlc3VsdHMgPSBhd2FpdCBjYWxsRGF0YVN0cmF0ZWd5SW1wbChcbiAgICAgICAgZGF0YVN0cmF0ZWd5SW1wbCxcbiAgICAgICAgdHlwZSxcbiAgICAgICAgc3RhdGUyLFxuICAgICAgICByZXF1ZXN0LFxuICAgICAgICBtYXRjaGVzVG9Mb2FkLFxuICAgICAgICBtYXRjaGVzLFxuICAgICAgICBmZXRjaGVyS2V5LFxuICAgICAgICBtYW5pZmVzdCxcbiAgICAgICAgbWFwUm91dGVQcm9wZXJ0aWVzMlxuICAgICAgKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBtYXRjaGVzVG9Mb2FkLmZvckVhY2goKG0pID0+IHtcbiAgICAgICAgZGF0YVJlc3VsdHNbbS5yb3V0ZS5pZF0gPSB7XG4gICAgICAgICAgdHlwZTogXCJlcnJvclwiIC8qIGVycm9yICovLFxuICAgICAgICAgIGVycm9yOiBlXG4gICAgICAgIH07XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBkYXRhUmVzdWx0cztcbiAgICB9XG4gICAgZm9yIChsZXQgW3JvdXRlSWQsIHJlc3VsdF0gb2YgT2JqZWN0LmVudHJpZXMocmVzdWx0cykpIHtcbiAgICAgIGlmIChpc1JlZGlyZWN0RGF0YVN0cmF0ZWd5UmVzdWx0KHJlc3VsdCkpIHtcbiAgICAgICAgbGV0IHJlc3BvbnNlID0gcmVzdWx0LnJlc3VsdDtcbiAgICAgICAgZGF0YVJlc3VsdHNbcm91dGVJZF0gPSB7XG4gICAgICAgICAgdHlwZTogXCJyZWRpcmVjdFwiIC8qIHJlZGlyZWN0ICovLFxuICAgICAgICAgIHJlc3BvbnNlOiBub3JtYWxpemVSZWxhdGl2ZVJvdXRpbmdSZWRpcmVjdFJlc3BvbnNlKFxuICAgICAgICAgICAgcmVzcG9uc2UsXG4gICAgICAgICAgICByZXF1ZXN0LFxuICAgICAgICAgICAgcm91dGVJZCxcbiAgICAgICAgICAgIG1hdGNoZXMsXG4gICAgICAgICAgICBiYXNlbmFtZVxuICAgICAgICAgIClcbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRhdGFSZXN1bHRzW3JvdXRlSWRdID0gYXdhaXQgY29udmVydERhdGFTdHJhdGVneVJlc3VsdFRvRGF0YVJlc3VsdChcbiAgICAgICAgICByZXN1bHRcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGRhdGFSZXN1bHRzO1xuICB9XG4gIGFzeW5jIGZ1bmN0aW9uIGNhbGxMb2FkZXJzQW5kTWF5YmVSZXNvbHZlRGF0YShzdGF0ZTIsIG1hdGNoZXMsIG1hdGNoZXNUb0xvYWQsIGZldGNoZXJzVG9Mb2FkLCByZXF1ZXN0KSB7XG4gICAgbGV0IGxvYWRlclJlc3VsdHNQcm9taXNlID0gY2FsbERhdGFTdHJhdGVneShcbiAgICAgIFwibG9hZGVyXCIsXG4gICAgICBzdGF0ZTIsXG4gICAgICByZXF1ZXN0LFxuICAgICAgbWF0Y2hlc1RvTG9hZCxcbiAgICAgIG1hdGNoZXMsXG4gICAgICBudWxsXG4gICAgKTtcbiAgICBsZXQgZmV0Y2hlclJlc3VsdHNQcm9taXNlID0gUHJvbWlzZS5hbGwoXG4gICAgICBmZXRjaGVyc1RvTG9hZC5tYXAoYXN5bmMgKGYpID0+IHtcbiAgICAgICAgaWYgKGYubWF0Y2hlcyAmJiBmLm1hdGNoICYmIGYuY29udHJvbGxlcikge1xuICAgICAgICAgIGxldCByZXN1bHRzID0gYXdhaXQgY2FsbERhdGFTdHJhdGVneShcbiAgICAgICAgICAgIFwibG9hZGVyXCIsXG4gICAgICAgICAgICBzdGF0ZTIsXG4gICAgICAgICAgICBjcmVhdGVDbGllbnRTaWRlUmVxdWVzdChpbml0Lmhpc3RvcnksIGYucGF0aCwgZi5jb250cm9sbGVyLnNpZ25hbCksXG4gICAgICAgICAgICBbZi5tYXRjaF0sXG4gICAgICAgICAgICBmLm1hdGNoZXMsXG4gICAgICAgICAgICBmLmtleVxuICAgICAgICAgICk7XG4gICAgICAgICAgbGV0IHJlc3VsdCA9IHJlc3VsdHNbZi5tYXRjaC5yb3V0ZS5pZF07XG4gICAgICAgICAgcmV0dXJuIHsgW2Yua2V5XTogcmVzdWx0IH07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh7XG4gICAgICAgICAgICBbZi5rZXldOiB7XG4gICAgICAgICAgICAgIHR5cGU6IFwiZXJyb3JcIiAvKiBlcnJvciAqLyxcbiAgICAgICAgICAgICAgZXJyb3I6IGdldEludGVybmFsUm91dGVyRXJyb3IoNDA0LCB7XG4gICAgICAgICAgICAgICAgcGF0aG5hbWU6IGYucGF0aFxuICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9KVxuICAgICk7XG4gICAgbGV0IGxvYWRlclJlc3VsdHMgPSBhd2FpdCBsb2FkZXJSZXN1bHRzUHJvbWlzZTtcbiAgICBsZXQgZmV0Y2hlclJlc3VsdHMgPSAoYXdhaXQgZmV0Y2hlclJlc3VsdHNQcm9taXNlKS5yZWR1Y2UoXG4gICAgICAoYWNjLCByKSA9PiBPYmplY3QuYXNzaWduKGFjYywgciksXG4gICAgICB7fVxuICAgICk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGxvYWRlclJlc3VsdHMsXG4gICAgICBmZXRjaGVyUmVzdWx0c1xuICAgIH07XG4gIH1cbiAgZnVuY3Rpb24gaW50ZXJydXB0QWN0aXZlTG9hZHMoKSB7XG4gICAgaXNSZXZhbGlkYXRpb25SZXF1aXJlZCA9IHRydWU7XG4gICAgZmV0Y2hMb2FkTWF0Y2hlcy5mb3JFYWNoKChfLCBrZXkpID0+IHtcbiAgICAgIGlmIChmZXRjaENvbnRyb2xsZXJzLmhhcyhrZXkpKSB7XG4gICAgICAgIGNhbmNlbGxlZEZldGNoZXJMb2Fkcy5hZGQoa2V5KTtcbiAgICAgIH1cbiAgICAgIGFib3J0RmV0Y2hlcihrZXkpO1xuICAgIH0pO1xuICB9XG4gIGZ1bmN0aW9uIHVwZGF0ZUZldGNoZXJTdGF0ZShrZXksIGZldGNoZXIsIG9wdHMgPSB7fSkge1xuICAgIHN0YXRlLmZldGNoZXJzLnNldChrZXksIGZldGNoZXIpO1xuICAgIHVwZGF0ZVN0YXRlKFxuICAgICAgeyBmZXRjaGVyczogbmV3IE1hcChzdGF0ZS5mZXRjaGVycykgfSxcbiAgICAgIHsgZmx1c2hTeW5jOiAob3B0cyAmJiBvcHRzLmZsdXNoU3luYykgPT09IHRydWUgfVxuICAgICk7XG4gIH1cbiAgZnVuY3Rpb24gc2V0RmV0Y2hlckVycm9yKGtleSwgcm91dGVJZCwgZXJyb3IsIG9wdHMgPSB7fSkge1xuICAgIGxldCBib3VuZGFyeU1hdGNoID0gZmluZE5lYXJlc3RCb3VuZGFyeShzdGF0ZS5tYXRjaGVzLCByb3V0ZUlkKTtcbiAgICBkZWxldGVGZXRjaGVyKGtleSk7XG4gICAgdXBkYXRlU3RhdGUoXG4gICAgICB7XG4gICAgICAgIGVycm9yczoge1xuICAgICAgICAgIFtib3VuZGFyeU1hdGNoLnJvdXRlLmlkXTogZXJyb3JcbiAgICAgICAgfSxcbiAgICAgICAgZmV0Y2hlcnM6IG5ldyBNYXAoc3RhdGUuZmV0Y2hlcnMpXG4gICAgICB9LFxuICAgICAgeyBmbHVzaFN5bmM6IChvcHRzICYmIG9wdHMuZmx1c2hTeW5jKSA9PT0gdHJ1ZSB9XG4gICAgKTtcbiAgfVxuICBmdW5jdGlvbiBnZXRGZXRjaGVyKGtleSkge1xuICAgIGFjdGl2ZUZldGNoZXJzLnNldChrZXksIChhY3RpdmVGZXRjaGVycy5nZXQoa2V5KSB8fCAwKSArIDEpO1xuICAgIGlmIChmZXRjaGVyc1F1ZXVlZEZvckRlbGV0aW9uLmhhcyhrZXkpKSB7XG4gICAgICBmZXRjaGVyc1F1ZXVlZEZvckRlbGV0aW9uLmRlbGV0ZShrZXkpO1xuICAgIH1cbiAgICByZXR1cm4gc3RhdGUuZmV0Y2hlcnMuZ2V0KGtleSkgfHwgSURMRV9GRVRDSEVSO1xuICB9XG4gIGZ1bmN0aW9uIGRlbGV0ZUZldGNoZXIoa2V5KSB7XG4gICAgbGV0IGZldGNoZXIgPSBzdGF0ZS5mZXRjaGVycy5nZXQoa2V5KTtcbiAgICBpZiAoZmV0Y2hDb250cm9sbGVycy5oYXMoa2V5KSAmJiAhKGZldGNoZXIgJiYgZmV0Y2hlci5zdGF0ZSA9PT0gXCJsb2FkaW5nXCIgJiYgZmV0Y2hSZWxvYWRJZHMuaGFzKGtleSkpKSB7XG4gICAgICBhYm9ydEZldGNoZXIoa2V5KTtcbiAgICB9XG4gICAgZmV0Y2hMb2FkTWF0Y2hlcy5kZWxldGUoa2V5KTtcbiAgICBmZXRjaFJlbG9hZElkcy5kZWxldGUoa2V5KTtcbiAgICBmZXRjaFJlZGlyZWN0SWRzLmRlbGV0ZShrZXkpO1xuICAgIGZldGNoZXJzUXVldWVkRm9yRGVsZXRpb24uZGVsZXRlKGtleSk7XG4gICAgY2FuY2VsbGVkRmV0Y2hlckxvYWRzLmRlbGV0ZShrZXkpO1xuICAgIHN0YXRlLmZldGNoZXJzLmRlbGV0ZShrZXkpO1xuICB9XG4gIGZ1bmN0aW9uIHF1ZXVlRmV0Y2hlckZvckRlbGV0aW9uKGtleSkge1xuICAgIGxldCBjb3VudCA9IChhY3RpdmVGZXRjaGVycy5nZXQoa2V5KSB8fCAwKSAtIDE7XG4gICAgaWYgKGNvdW50IDw9IDApIHtcbiAgICAgIGFjdGl2ZUZldGNoZXJzLmRlbGV0ZShrZXkpO1xuICAgICAgZmV0Y2hlcnNRdWV1ZWRGb3JEZWxldGlvbi5hZGQoa2V5KTtcbiAgICB9IGVsc2Uge1xuICAgICAgYWN0aXZlRmV0Y2hlcnMuc2V0KGtleSwgY291bnQpO1xuICAgIH1cbiAgICB1cGRhdGVTdGF0ZSh7IGZldGNoZXJzOiBuZXcgTWFwKHN0YXRlLmZldGNoZXJzKSB9KTtcbiAgfVxuICBmdW5jdGlvbiBhYm9ydEZldGNoZXIoa2V5KSB7XG4gICAgbGV0IGNvbnRyb2xsZXIgPSBmZXRjaENvbnRyb2xsZXJzLmdldChrZXkpO1xuICAgIGlmIChjb250cm9sbGVyKSB7XG4gICAgICBjb250cm9sbGVyLmFib3J0KCk7XG4gICAgICBmZXRjaENvbnRyb2xsZXJzLmRlbGV0ZShrZXkpO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBtYXJrRmV0Y2hlcnNEb25lKGtleXMpIHtcbiAgICBmb3IgKGxldCBrZXkgb2Yga2V5cykge1xuICAgICAgbGV0IGZldGNoZXIgPSBnZXRGZXRjaGVyKGtleSk7XG4gICAgICBsZXQgZG9uZUZldGNoZXIgPSBnZXREb25lRmV0Y2hlcihmZXRjaGVyLmRhdGEpO1xuICAgICAgc3RhdGUuZmV0Y2hlcnMuc2V0KGtleSwgZG9uZUZldGNoZXIpO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBtYXJrRmV0Y2hSZWRpcmVjdHNEb25lKCkge1xuICAgIGxldCBkb25lS2V5cyA9IFtdO1xuICAgIGxldCB1cGRhdGVkRmV0Y2hlcnMgPSBmYWxzZTtcbiAgICBmb3IgKGxldCBrZXkgb2YgZmV0Y2hSZWRpcmVjdElkcykge1xuICAgICAgbGV0IGZldGNoZXIgPSBzdGF0ZS5mZXRjaGVycy5nZXQoa2V5KTtcbiAgICAgIGludmFyaWFudChmZXRjaGVyLCBgRXhwZWN0ZWQgZmV0Y2hlcjogJHtrZXl9YCk7XG4gICAgICBpZiAoZmV0Y2hlci5zdGF0ZSA9PT0gXCJsb2FkaW5nXCIpIHtcbiAgICAgICAgZmV0Y2hSZWRpcmVjdElkcy5kZWxldGUoa2V5KTtcbiAgICAgICAgZG9uZUtleXMucHVzaChrZXkpO1xuICAgICAgICB1cGRhdGVkRmV0Y2hlcnMgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICBtYXJrRmV0Y2hlcnNEb25lKGRvbmVLZXlzKTtcbiAgICByZXR1cm4gdXBkYXRlZEZldGNoZXJzO1xuICB9XG4gIGZ1bmN0aW9uIGFib3J0U3RhbGVGZXRjaExvYWRzKGxhbmRlZElkKSB7XG4gICAgbGV0IHllZXRlZEtleXMgPSBbXTtcbiAgICBmb3IgKGxldCBba2V5LCBpZF0gb2YgZmV0Y2hSZWxvYWRJZHMpIHtcbiAgICAgIGlmIChpZCA8IGxhbmRlZElkKSB7XG4gICAgICAgIGxldCBmZXRjaGVyID0gc3RhdGUuZmV0Y2hlcnMuZ2V0KGtleSk7XG4gICAgICAgIGludmFyaWFudChmZXRjaGVyLCBgRXhwZWN0ZWQgZmV0Y2hlcjogJHtrZXl9YCk7XG4gICAgICAgIGlmIChmZXRjaGVyLnN0YXRlID09PSBcImxvYWRpbmdcIikge1xuICAgICAgICAgIGFib3J0RmV0Y2hlcihrZXkpO1xuICAgICAgICAgIGZldGNoUmVsb2FkSWRzLmRlbGV0ZShrZXkpO1xuICAgICAgICAgIHllZXRlZEtleXMucHVzaChrZXkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIG1hcmtGZXRjaGVyc0RvbmUoeWVldGVkS2V5cyk7XG4gICAgcmV0dXJuIHllZXRlZEtleXMubGVuZ3RoID4gMDtcbiAgfVxuICBmdW5jdGlvbiBnZXRCbG9ja2VyKGtleSwgZm4pIHtcbiAgICBsZXQgYmxvY2tlciA9IHN0YXRlLmJsb2NrZXJzLmdldChrZXkpIHx8IElETEVfQkxPQ0tFUjtcbiAgICBpZiAoYmxvY2tlckZ1bmN0aW9ucy5nZXQoa2V5KSAhPT0gZm4pIHtcbiAgICAgIGJsb2NrZXJGdW5jdGlvbnMuc2V0KGtleSwgZm4pO1xuICAgIH1cbiAgICByZXR1cm4gYmxvY2tlcjtcbiAgfVxuICBmdW5jdGlvbiBkZWxldGVCbG9ja2VyKGtleSkge1xuICAgIHN0YXRlLmJsb2NrZXJzLmRlbGV0ZShrZXkpO1xuICAgIGJsb2NrZXJGdW5jdGlvbnMuZGVsZXRlKGtleSk7XG4gIH1cbiAgZnVuY3Rpb24gdXBkYXRlQmxvY2tlcihrZXksIG5ld0Jsb2NrZXIpIHtcbiAgICBsZXQgYmxvY2tlciA9IHN0YXRlLmJsb2NrZXJzLmdldChrZXkpIHx8IElETEVfQkxPQ0tFUjtcbiAgICBpbnZhcmlhbnQoXG4gICAgICBibG9ja2VyLnN0YXRlID09PSBcInVuYmxvY2tlZFwiICYmIG5ld0Jsb2NrZXIuc3RhdGUgPT09IFwiYmxvY2tlZFwiIHx8IGJsb2NrZXIuc3RhdGUgPT09IFwiYmxvY2tlZFwiICYmIG5ld0Jsb2NrZXIuc3RhdGUgPT09IFwiYmxvY2tlZFwiIHx8IGJsb2NrZXIuc3RhdGUgPT09IFwiYmxvY2tlZFwiICYmIG5ld0Jsb2NrZXIuc3RhdGUgPT09IFwicHJvY2VlZGluZ1wiIHx8IGJsb2NrZXIuc3RhdGUgPT09IFwiYmxvY2tlZFwiICYmIG5ld0Jsb2NrZXIuc3RhdGUgPT09IFwidW5ibG9ja2VkXCIgfHwgYmxvY2tlci5zdGF0ZSA9PT0gXCJwcm9jZWVkaW5nXCIgJiYgbmV3QmxvY2tlci5zdGF0ZSA9PT0gXCJ1bmJsb2NrZWRcIixcbiAgICAgIGBJbnZhbGlkIGJsb2NrZXIgc3RhdGUgdHJhbnNpdGlvbjogJHtibG9ja2VyLnN0YXRlfSAtPiAke25ld0Jsb2NrZXIuc3RhdGV9YFxuICAgICk7XG4gICAgbGV0IGJsb2NrZXJzID0gbmV3IE1hcChzdGF0ZS5ibG9ja2Vycyk7XG4gICAgYmxvY2tlcnMuc2V0KGtleSwgbmV3QmxvY2tlcik7XG4gICAgdXBkYXRlU3RhdGUoeyBibG9ja2VycyB9KTtcbiAgfVxuICBmdW5jdGlvbiBzaG91bGRCbG9ja05hdmlnYXRpb24oe1xuICAgIGN1cnJlbnRMb2NhdGlvbixcbiAgICBuZXh0TG9jYXRpb24sXG4gICAgaGlzdG9yeUFjdGlvblxuICB9KSB7XG4gICAgaWYgKGJsb2NrZXJGdW5jdGlvbnMuc2l6ZSA9PT0gMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoYmxvY2tlckZ1bmN0aW9ucy5zaXplID4gMSkge1xuICAgICAgd2FybmluZyhmYWxzZSwgXCJBIHJvdXRlciBvbmx5IHN1cHBvcnRzIG9uZSBibG9ja2VyIGF0IGEgdGltZVwiKTtcbiAgICB9XG4gICAgbGV0IGVudHJpZXMgPSBBcnJheS5mcm9tKGJsb2NrZXJGdW5jdGlvbnMuZW50cmllcygpKTtcbiAgICBsZXQgW2Jsb2NrZXJLZXksIGJsb2NrZXJGdW5jdGlvbl0gPSBlbnRyaWVzW2VudHJpZXMubGVuZ3RoIC0gMV07XG4gICAgbGV0IGJsb2NrZXIgPSBzdGF0ZS5ibG9ja2Vycy5nZXQoYmxvY2tlcktleSk7XG4gICAgaWYgKGJsb2NrZXIgJiYgYmxvY2tlci5zdGF0ZSA9PT0gXCJwcm9jZWVkaW5nXCIpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGJsb2NrZXJGdW5jdGlvbih7IGN1cnJlbnRMb2NhdGlvbiwgbmV4dExvY2F0aW9uLCBoaXN0b3J5QWN0aW9uIH0pKSB7XG4gICAgICByZXR1cm4gYmxvY2tlcktleTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gaGFuZGxlTmF2aWdhdGlvbmFsNDA0KHBhdGhuYW1lKSB7XG4gICAgbGV0IGVycm9yID0gZ2V0SW50ZXJuYWxSb3V0ZXJFcnJvcig0MDQsIHsgcGF0aG5hbWUgfSk7XG4gICAgbGV0IHJvdXRlc1RvVXNlID0gaW5GbGlnaHREYXRhUm91dGVzIHx8IGRhdGFSb3V0ZXM7XG4gICAgbGV0IHsgbWF0Y2hlcywgcm91dGUgfSA9IGdldFNob3J0Q2lyY3VpdE1hdGNoZXMocm91dGVzVG9Vc2UpO1xuICAgIHJldHVybiB7IG5vdEZvdW5kTWF0Y2hlczogbWF0Y2hlcywgcm91dGUsIGVycm9yIH07XG4gIH1cbiAgZnVuY3Rpb24gZW5hYmxlU2Nyb2xsUmVzdG9yYXRpb24ocG9zaXRpb25zLCBnZXRQb3NpdGlvbiwgZ2V0S2V5KSB7XG4gICAgc2F2ZWRTY3JvbGxQb3NpdGlvbnMyID0gcG9zaXRpb25zO1xuICAgIGdldFNjcm9sbFBvc2l0aW9uID0gZ2V0UG9zaXRpb247XG4gICAgZ2V0U2Nyb2xsUmVzdG9yYXRpb25LZXkyID0gZ2V0S2V5IHx8IG51bGw7XG4gICAgaWYgKCFpbml0aWFsU2Nyb2xsUmVzdG9yZWQgJiYgc3RhdGUubmF2aWdhdGlvbiA9PT0gSURMRV9OQVZJR0FUSU9OKSB7XG4gICAgICBpbml0aWFsU2Nyb2xsUmVzdG9yZWQgPSB0cnVlO1xuICAgICAgbGV0IHkgPSBnZXRTYXZlZFNjcm9sbFBvc2l0aW9uKHN0YXRlLmxvY2F0aW9uLCBzdGF0ZS5tYXRjaGVzKTtcbiAgICAgIGlmICh5ICE9IG51bGwpIHtcbiAgICAgICAgdXBkYXRlU3RhdGUoeyByZXN0b3JlU2Nyb2xsUG9zaXRpb246IHkgfSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBzYXZlZFNjcm9sbFBvc2l0aW9uczIgPSBudWxsO1xuICAgICAgZ2V0U2Nyb2xsUG9zaXRpb24gPSBudWxsO1xuICAgICAgZ2V0U2Nyb2xsUmVzdG9yYXRpb25LZXkyID0gbnVsbDtcbiAgICB9O1xuICB9XG4gIGZ1bmN0aW9uIGdldFNjcm9sbEtleShsb2NhdGlvbiwgbWF0Y2hlcykge1xuICAgIGlmIChnZXRTY3JvbGxSZXN0b3JhdGlvbktleTIpIHtcbiAgICAgIGxldCBrZXkgPSBnZXRTY3JvbGxSZXN0b3JhdGlvbktleTIoXG4gICAgICAgIGxvY2F0aW9uLFxuICAgICAgICBtYXRjaGVzLm1hcCgobSkgPT4gY29udmVydFJvdXRlTWF0Y2hUb1VpTWF0Y2gobSwgc3RhdGUubG9hZGVyRGF0YSkpXG4gICAgICApO1xuICAgICAgcmV0dXJuIGtleSB8fCBsb2NhdGlvbi5rZXk7XG4gICAgfVxuICAgIHJldHVybiBsb2NhdGlvbi5rZXk7XG4gIH1cbiAgZnVuY3Rpb24gc2F2ZVNjcm9sbFBvc2l0aW9uKGxvY2F0aW9uLCBtYXRjaGVzKSB7XG4gICAgaWYgKHNhdmVkU2Nyb2xsUG9zaXRpb25zMiAmJiBnZXRTY3JvbGxQb3NpdGlvbikge1xuICAgICAgbGV0IGtleSA9IGdldFNjcm9sbEtleShsb2NhdGlvbiwgbWF0Y2hlcyk7XG4gICAgICBzYXZlZFNjcm9sbFBvc2l0aW9uczJba2V5XSA9IGdldFNjcm9sbFBvc2l0aW9uKCk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIGdldFNhdmVkU2Nyb2xsUG9zaXRpb24obG9jYXRpb24sIG1hdGNoZXMpIHtcbiAgICBpZiAoc2F2ZWRTY3JvbGxQb3NpdGlvbnMyKSB7XG4gICAgICBsZXQga2V5ID0gZ2V0U2Nyb2xsS2V5KGxvY2F0aW9uLCBtYXRjaGVzKTtcbiAgICAgIGxldCB5ID0gc2F2ZWRTY3JvbGxQb3NpdGlvbnMyW2tleV07XG4gICAgICBpZiAodHlwZW9mIHkgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgcmV0dXJuIHk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGZ1bmN0aW9uIGNoZWNrRm9nT2ZXYXIobWF0Y2hlcywgcm91dGVzVG9Vc2UsIHBhdGhuYW1lKSB7XG4gICAgaWYgKHBhdGNoUm91dGVzT25OYXZpZ2F0aW9uSW1wbCkge1xuICAgICAgaWYgKCFtYXRjaGVzKSB7XG4gICAgICAgIGxldCBmb2dNYXRjaGVzID0gbWF0Y2hSb3V0ZXNJbXBsKFxuICAgICAgICAgIHJvdXRlc1RvVXNlLFxuICAgICAgICAgIHBhdGhuYW1lLFxuICAgICAgICAgIGJhc2VuYW1lLFxuICAgICAgICAgIHRydWVcbiAgICAgICAgKTtcbiAgICAgICAgcmV0dXJuIHsgYWN0aXZlOiB0cnVlLCBtYXRjaGVzOiBmb2dNYXRjaGVzIHx8IFtdIH07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoT2JqZWN0LmtleXMobWF0Y2hlc1swXS5wYXJhbXMpLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICBsZXQgcGFydGlhbE1hdGNoZXMgPSBtYXRjaFJvdXRlc0ltcGwoXG4gICAgICAgICAgICByb3V0ZXNUb1VzZSxcbiAgICAgICAgICAgIHBhdGhuYW1lLFxuICAgICAgICAgICAgYmFzZW5hbWUsXG4gICAgICAgICAgICB0cnVlXG4gICAgICAgICAgKTtcbiAgICAgICAgICByZXR1cm4geyBhY3RpdmU6IHRydWUsIG1hdGNoZXM6IHBhcnRpYWxNYXRjaGVzIH07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHsgYWN0aXZlOiBmYWxzZSwgbWF0Y2hlczogbnVsbCB9O1xuICB9XG4gIGFzeW5jIGZ1bmN0aW9uIGRpc2NvdmVyUm91dGVzKG1hdGNoZXMsIHBhdGhuYW1lLCBzaWduYWwpIHtcbiAgICBpZiAoIXBhdGNoUm91dGVzT25OYXZpZ2F0aW9uSW1wbCkge1xuICAgICAgcmV0dXJuIHsgdHlwZTogXCJzdWNjZXNzXCIsIG1hdGNoZXMgfTtcbiAgICB9XG4gICAgbGV0IHBhcnRpYWxNYXRjaGVzID0gbWF0Y2hlcztcbiAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgbGV0IGlzTm9uSE1SID0gaW5GbGlnaHREYXRhUm91dGVzID09IG51bGw7XG4gICAgICBsZXQgcm91dGVzVG9Vc2UgPSBpbkZsaWdodERhdGFSb3V0ZXMgfHwgZGF0YVJvdXRlcztcbiAgICAgIGxldCBsb2NhbE1hbmlmZXN0ID0gbWFuaWZlc3Q7XG4gICAgICB0cnkge1xuICAgICAgICBhd2FpdCBwYXRjaFJvdXRlc09uTmF2aWdhdGlvbkltcGwoe1xuICAgICAgICAgIHBhdGg6IHBhdGhuYW1lLFxuICAgICAgICAgIG1hdGNoZXM6IHBhcnRpYWxNYXRjaGVzLFxuICAgICAgICAgIHBhdGNoOiAocm91dGVJZCwgY2hpbGRyZW4pID0+IHtcbiAgICAgICAgICAgIGlmIChzaWduYWwuYWJvcnRlZCkgcmV0dXJuO1xuICAgICAgICAgICAgcGF0Y2hSb3V0ZXNJbXBsKFxuICAgICAgICAgICAgICByb3V0ZUlkLFxuICAgICAgICAgICAgICBjaGlsZHJlbixcbiAgICAgICAgICAgICAgcm91dGVzVG9Vc2UsXG4gICAgICAgICAgICAgIGxvY2FsTWFuaWZlc3QsXG4gICAgICAgICAgICAgIG1hcFJvdXRlUHJvcGVydGllczJcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgcmV0dXJuIHsgdHlwZTogXCJlcnJvclwiLCBlcnJvcjogZSwgcGFydGlhbE1hdGNoZXMgfTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIGlmIChpc05vbkhNUiAmJiAhc2lnbmFsLmFib3J0ZWQpIHtcbiAgICAgICAgICBkYXRhUm91dGVzID0gWy4uLmRhdGFSb3V0ZXNdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoc2lnbmFsLmFib3J0ZWQpIHtcbiAgICAgICAgcmV0dXJuIHsgdHlwZTogXCJhYm9ydGVkXCIgfTtcbiAgICAgIH1cbiAgICAgIGxldCBuZXdNYXRjaGVzID0gbWF0Y2hSb3V0ZXMocm91dGVzVG9Vc2UsIHBhdGhuYW1lLCBiYXNlbmFtZSk7XG4gICAgICBpZiAobmV3TWF0Y2hlcykge1xuICAgICAgICByZXR1cm4geyB0eXBlOiBcInN1Y2Nlc3NcIiwgbWF0Y2hlczogbmV3TWF0Y2hlcyB9O1xuICAgICAgfVxuICAgICAgbGV0IG5ld1BhcnRpYWxNYXRjaGVzID0gbWF0Y2hSb3V0ZXNJbXBsKFxuICAgICAgICByb3V0ZXNUb1VzZSxcbiAgICAgICAgcGF0aG5hbWUsXG4gICAgICAgIGJhc2VuYW1lLFxuICAgICAgICB0cnVlXG4gICAgICApO1xuICAgICAgaWYgKCFuZXdQYXJ0aWFsTWF0Y2hlcyB8fCBwYXJ0aWFsTWF0Y2hlcy5sZW5ndGggPT09IG5ld1BhcnRpYWxNYXRjaGVzLmxlbmd0aCAmJiBwYXJ0aWFsTWF0Y2hlcy5ldmVyeShcbiAgICAgICAgKG0sIGkpID0+IG0ucm91dGUuaWQgPT09IG5ld1BhcnRpYWxNYXRjaGVzW2ldLnJvdXRlLmlkXG4gICAgICApKSB7XG4gICAgICAgIHJldHVybiB7IHR5cGU6IFwic3VjY2Vzc1wiLCBtYXRjaGVzOiBudWxsIH07XG4gICAgICB9XG4gICAgICBwYXJ0aWFsTWF0Y2hlcyA9IG5ld1BhcnRpYWxNYXRjaGVzO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBfaW50ZXJuYWxTZXRSb3V0ZXMobmV3Um91dGVzKSB7XG4gICAgbWFuaWZlc3QgPSB7fTtcbiAgICBpbkZsaWdodERhdGFSb3V0ZXMgPSBjb252ZXJ0Um91dGVzVG9EYXRhUm91dGVzKFxuICAgICAgbmV3Um91dGVzLFxuICAgICAgbWFwUm91dGVQcm9wZXJ0aWVzMixcbiAgICAgIHZvaWQgMCxcbiAgICAgIG1hbmlmZXN0XG4gICAgKTtcbiAgfVxuICBmdW5jdGlvbiBwYXRjaFJvdXRlcyhyb3V0ZUlkLCBjaGlsZHJlbikge1xuICAgIGxldCBpc05vbkhNUiA9IGluRmxpZ2h0RGF0YVJvdXRlcyA9PSBudWxsO1xuICAgIGxldCByb3V0ZXNUb1VzZSA9IGluRmxpZ2h0RGF0YVJvdXRlcyB8fCBkYXRhUm91dGVzO1xuICAgIHBhdGNoUm91dGVzSW1wbChcbiAgICAgIHJvdXRlSWQsXG4gICAgICBjaGlsZHJlbixcbiAgICAgIHJvdXRlc1RvVXNlLFxuICAgICAgbWFuaWZlc3QsXG4gICAgICBtYXBSb3V0ZVByb3BlcnRpZXMyXG4gICAgKTtcbiAgICBpZiAoaXNOb25ITVIpIHtcbiAgICAgIGRhdGFSb3V0ZXMgPSBbLi4uZGF0YVJvdXRlc107XG4gICAgICB1cGRhdGVTdGF0ZSh7fSk7XG4gICAgfVxuICB9XG4gIHJvdXRlciA9IHtcbiAgICBnZXQgYmFzZW5hbWUoKSB7XG4gICAgICByZXR1cm4gYmFzZW5hbWU7XG4gICAgfSxcbiAgICBnZXQgZnV0dXJlKCkge1xuICAgICAgcmV0dXJuIGZ1dHVyZTtcbiAgICB9LFxuICAgIGdldCBzdGF0ZSgpIHtcbiAgICAgIHJldHVybiBzdGF0ZTtcbiAgICB9LFxuICAgIGdldCByb3V0ZXMoKSB7XG4gICAgICByZXR1cm4gZGF0YVJvdXRlcztcbiAgICB9LFxuICAgIGdldCB3aW5kb3coKSB7XG4gICAgICByZXR1cm4gcm91dGVyV2luZG93O1xuICAgIH0sXG4gICAgaW5pdGlhbGl6ZSxcbiAgICBzdWJzY3JpYmUsXG4gICAgZW5hYmxlU2Nyb2xsUmVzdG9yYXRpb24sXG4gICAgbmF2aWdhdGUsXG4gICAgZmV0Y2g6IGZldGNoMixcbiAgICByZXZhbGlkYXRlLFxuICAgIC8vIFBhc3N0aHJvdWdoIHRvIGhpc3RvcnktYXdhcmUgY3JlYXRlSHJlZiB1c2VkIGJ5IHVzZUhyZWYgc28gd2UgZ2V0IHByb3BlclxuICAgIC8vIGhhc2gtYXdhcmUgVVJMcyBpbiBET00gcGF0aHNcbiAgICBjcmVhdGVIcmVmOiAodG8pID0+IGluaXQuaGlzdG9yeS5jcmVhdGVIcmVmKHRvKSxcbiAgICBlbmNvZGVMb2NhdGlvbjogKHRvKSA9PiBpbml0Lmhpc3RvcnkuZW5jb2RlTG9jYXRpb24odG8pLFxuICAgIGdldEZldGNoZXIsXG4gICAgZGVsZXRlRmV0Y2hlcjogcXVldWVGZXRjaGVyRm9yRGVsZXRpb24sXG4gICAgZGlzcG9zZSxcbiAgICBnZXRCbG9ja2VyLFxuICAgIGRlbGV0ZUJsb2NrZXIsXG4gICAgcGF0Y2hSb3V0ZXMsXG4gICAgX2ludGVybmFsRmV0Y2hDb250cm9sbGVyczogZmV0Y2hDb250cm9sbGVycyxcbiAgICAvLyBUT0RPOiBSZW1vdmUgc2V0Um91dGVzLCBpdCdzIHRlbXBvcmFyeSB0byBhdm9pZCBkZWFsaW5nIHdpdGhcbiAgICAvLyB1cGRhdGluZyB0aGUgdHJlZSB3aGlsZSB2YWxpZGF0aW5nIHRoZSB1cGRhdGUgYWxnb3JpdGhtLlxuICAgIF9pbnRlcm5hbFNldFJvdXRlc1xuICB9O1xuICByZXR1cm4gcm91dGVyO1xufVxuZnVuY3Rpb24gY3JlYXRlU3RhdGljSGFuZGxlcihyb3V0ZXMsIG9wdHMpIHtcbiAgaW52YXJpYW50KFxuICAgIHJvdXRlcy5sZW5ndGggPiAwLFxuICAgIFwiWW91IG11c3QgcHJvdmlkZSBhIG5vbi1lbXB0eSByb3V0ZXMgYXJyYXkgdG8gY3JlYXRlU3RhdGljSGFuZGxlclwiXG4gICk7XG4gIGxldCBtYW5pZmVzdCA9IHt9O1xuICBsZXQgYmFzZW5hbWUgPSAob3B0cyA/IG9wdHMuYmFzZW5hbWUgOiBudWxsKSB8fCBcIi9cIjtcbiAgbGV0IG1hcFJvdXRlUHJvcGVydGllczIgPSBvcHRzPy5tYXBSb3V0ZVByb3BlcnRpZXMgfHwgZGVmYXVsdE1hcFJvdXRlUHJvcGVydGllcztcbiAgbGV0IGRhdGFSb3V0ZXMgPSBjb252ZXJ0Um91dGVzVG9EYXRhUm91dGVzKFxuICAgIHJvdXRlcyxcbiAgICBtYXBSb3V0ZVByb3BlcnRpZXMyLFxuICAgIHZvaWQgMCxcbiAgICBtYW5pZmVzdFxuICApO1xuICBhc3luYyBmdW5jdGlvbiBxdWVyeShyZXF1ZXN0LCB7XG4gICAgcmVxdWVzdENvbnRleHQsXG4gICAgc2tpcExvYWRlckVycm9yQnViYmxpbmcsXG4gICAgZGF0YVN0cmF0ZWd5XG4gIH0gPSB7fSkge1xuICAgIGxldCB1cmwgPSBuZXcgVVJMKHJlcXVlc3QudXJsKTtcbiAgICBsZXQgbWV0aG9kID0gcmVxdWVzdC5tZXRob2Q7XG4gICAgbGV0IGxvY2F0aW9uID0gY3JlYXRlTG9jYXRpb24oXCJcIiwgY3JlYXRlUGF0aCh1cmwpLCBudWxsLCBcImRlZmF1bHRcIik7XG4gICAgbGV0IG1hdGNoZXMgPSBtYXRjaFJvdXRlcyhkYXRhUm91dGVzLCBsb2NhdGlvbiwgYmFzZW5hbWUpO1xuICAgIGlmICghaXNWYWxpZE1ldGhvZChtZXRob2QpICYmIG1ldGhvZCAhPT0gXCJIRUFEXCIpIHtcbiAgICAgIGxldCBlcnJvciA9IGdldEludGVybmFsUm91dGVyRXJyb3IoNDA1LCB7IG1ldGhvZCB9KTtcbiAgICAgIGxldCB7IG1hdGNoZXM6IG1ldGhvZE5vdEFsbG93ZWRNYXRjaGVzLCByb3V0ZSB9ID0gZ2V0U2hvcnRDaXJjdWl0TWF0Y2hlcyhkYXRhUm91dGVzKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGJhc2VuYW1lLFxuICAgICAgICBsb2NhdGlvbixcbiAgICAgICAgbWF0Y2hlczogbWV0aG9kTm90QWxsb3dlZE1hdGNoZXMsXG4gICAgICAgIGxvYWRlckRhdGE6IHt9LFxuICAgICAgICBhY3Rpb25EYXRhOiBudWxsLFxuICAgICAgICBlcnJvcnM6IHtcbiAgICAgICAgICBbcm91dGUuaWRdOiBlcnJvclxuICAgICAgICB9LFxuICAgICAgICBzdGF0dXNDb2RlOiBlcnJvci5zdGF0dXMsXG4gICAgICAgIGxvYWRlckhlYWRlcnM6IHt9LFxuICAgICAgICBhY3Rpb25IZWFkZXJzOiB7fVxuICAgICAgfTtcbiAgICB9IGVsc2UgaWYgKCFtYXRjaGVzKSB7XG4gICAgICBsZXQgZXJyb3IgPSBnZXRJbnRlcm5hbFJvdXRlckVycm9yKDQwNCwgeyBwYXRobmFtZTogbG9jYXRpb24ucGF0aG5hbWUgfSk7XG4gICAgICBsZXQgeyBtYXRjaGVzOiBub3RGb3VuZE1hdGNoZXMsIHJvdXRlIH0gPSBnZXRTaG9ydENpcmN1aXRNYXRjaGVzKGRhdGFSb3V0ZXMpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgYmFzZW5hbWUsXG4gICAgICAgIGxvY2F0aW9uLFxuICAgICAgICBtYXRjaGVzOiBub3RGb3VuZE1hdGNoZXMsXG4gICAgICAgIGxvYWRlckRhdGE6IHt9LFxuICAgICAgICBhY3Rpb25EYXRhOiBudWxsLFxuICAgICAgICBlcnJvcnM6IHtcbiAgICAgICAgICBbcm91dGUuaWRdOiBlcnJvclxuICAgICAgICB9LFxuICAgICAgICBzdGF0dXNDb2RlOiBlcnJvci5zdGF0dXMsXG4gICAgICAgIGxvYWRlckhlYWRlcnM6IHt9LFxuICAgICAgICBhY3Rpb25IZWFkZXJzOiB7fVxuICAgICAgfTtcbiAgICB9XG4gICAgbGV0IHJlc3VsdCA9IGF3YWl0IHF1ZXJ5SW1wbChcbiAgICAgIHJlcXVlc3QsXG4gICAgICBsb2NhdGlvbixcbiAgICAgIG1hdGNoZXMsXG4gICAgICByZXF1ZXN0Q29udGV4dCxcbiAgICAgIGRhdGFTdHJhdGVneSB8fCBudWxsLFxuICAgICAgc2tpcExvYWRlckVycm9yQnViYmxpbmcgPT09IHRydWUsXG4gICAgICBudWxsXG4gICAgKTtcbiAgICBpZiAoaXNSZXNwb25zZShyZXN1bHQpKSB7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICByZXR1cm4geyBsb2NhdGlvbiwgYmFzZW5hbWUsIC4uLnJlc3VsdCB9O1xuICB9XG4gIGFzeW5jIGZ1bmN0aW9uIHF1ZXJ5Um91dGUocmVxdWVzdCwge1xuICAgIHJvdXRlSWQsXG4gICAgcmVxdWVzdENvbnRleHQsXG4gICAgZGF0YVN0cmF0ZWd5XG4gIH0gPSB7fSkge1xuICAgIGxldCB1cmwgPSBuZXcgVVJMKHJlcXVlc3QudXJsKTtcbiAgICBsZXQgbWV0aG9kID0gcmVxdWVzdC5tZXRob2Q7XG4gICAgbGV0IGxvY2F0aW9uID0gY3JlYXRlTG9jYXRpb24oXCJcIiwgY3JlYXRlUGF0aCh1cmwpLCBudWxsLCBcImRlZmF1bHRcIik7XG4gICAgbGV0IG1hdGNoZXMgPSBtYXRjaFJvdXRlcyhkYXRhUm91dGVzLCBsb2NhdGlvbiwgYmFzZW5hbWUpO1xuICAgIGlmICghaXNWYWxpZE1ldGhvZChtZXRob2QpICYmIG1ldGhvZCAhPT0gXCJIRUFEXCIgJiYgbWV0aG9kICE9PSBcIk9QVElPTlNcIikge1xuICAgICAgdGhyb3cgZ2V0SW50ZXJuYWxSb3V0ZXJFcnJvcig0MDUsIHsgbWV0aG9kIH0pO1xuICAgIH0gZWxzZSBpZiAoIW1hdGNoZXMpIHtcbiAgICAgIHRocm93IGdldEludGVybmFsUm91dGVyRXJyb3IoNDA0LCB7IHBhdGhuYW1lOiBsb2NhdGlvbi5wYXRobmFtZSB9KTtcbiAgICB9XG4gICAgbGV0IG1hdGNoID0gcm91dGVJZCA/IG1hdGNoZXMuZmluZCgobSkgPT4gbS5yb3V0ZS5pZCA9PT0gcm91dGVJZCkgOiBnZXRUYXJnZXRNYXRjaChtYXRjaGVzLCBsb2NhdGlvbik7XG4gICAgaWYgKHJvdXRlSWQgJiYgIW1hdGNoKSB7XG4gICAgICB0aHJvdyBnZXRJbnRlcm5hbFJvdXRlckVycm9yKDQwMywge1xuICAgICAgICBwYXRobmFtZTogbG9jYXRpb24ucGF0aG5hbWUsXG4gICAgICAgIHJvdXRlSWRcbiAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAoIW1hdGNoKSB7XG4gICAgICB0aHJvdyBnZXRJbnRlcm5hbFJvdXRlckVycm9yKDQwNCwgeyBwYXRobmFtZTogbG9jYXRpb24ucGF0aG5hbWUgfSk7XG4gICAgfVxuICAgIGxldCByZXN1bHQgPSBhd2FpdCBxdWVyeUltcGwoXG4gICAgICByZXF1ZXN0LFxuICAgICAgbG9jYXRpb24sXG4gICAgICBtYXRjaGVzLFxuICAgICAgcmVxdWVzdENvbnRleHQsXG4gICAgICBkYXRhU3RyYXRlZ3kgfHwgbnVsbCxcbiAgICAgIGZhbHNlLFxuICAgICAgbWF0Y2hcbiAgICApO1xuICAgIGlmIChpc1Jlc3BvbnNlKHJlc3VsdCkpIHtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIGxldCBlcnJvciA9IHJlc3VsdC5lcnJvcnMgPyBPYmplY3QudmFsdWVzKHJlc3VsdC5lcnJvcnMpWzBdIDogdm9pZCAwO1xuICAgIGlmIChlcnJvciAhPT0gdm9pZCAwKSB7XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gICAgaWYgKHJlc3VsdC5hY3Rpb25EYXRhKSB7XG4gICAgICByZXR1cm4gT2JqZWN0LnZhbHVlcyhyZXN1bHQuYWN0aW9uRGF0YSlbMF07XG4gICAgfVxuICAgIGlmIChyZXN1bHQubG9hZGVyRGF0YSkge1xuICAgICAgcmV0dXJuIE9iamVjdC52YWx1ZXMocmVzdWx0LmxvYWRlckRhdGEpWzBdO1xuICAgIH1cbiAgICByZXR1cm4gdm9pZCAwO1xuICB9XG4gIGFzeW5jIGZ1bmN0aW9uIHF1ZXJ5SW1wbChyZXF1ZXN0LCBsb2NhdGlvbiwgbWF0Y2hlcywgcmVxdWVzdENvbnRleHQsIGRhdGFTdHJhdGVneSwgc2tpcExvYWRlckVycm9yQnViYmxpbmcsIHJvdXRlTWF0Y2gpIHtcbiAgICBpbnZhcmlhbnQoXG4gICAgICByZXF1ZXN0LnNpZ25hbCxcbiAgICAgIFwicXVlcnkoKS9xdWVyeVJvdXRlKCkgcmVxdWVzdHMgbXVzdCBjb250YWluIGFuIEFib3J0Q29udHJvbGxlciBzaWduYWxcIlxuICAgICk7XG4gICAgdHJ5IHtcbiAgICAgIGlmIChpc011dGF0aW9uTWV0aG9kKHJlcXVlc3QubWV0aG9kKSkge1xuICAgICAgICBsZXQgcmVzdWx0MiA9IGF3YWl0IHN1Ym1pdChcbiAgICAgICAgICByZXF1ZXN0LFxuICAgICAgICAgIG1hdGNoZXMsXG4gICAgICAgICAgcm91dGVNYXRjaCB8fCBnZXRUYXJnZXRNYXRjaChtYXRjaGVzLCBsb2NhdGlvbiksXG4gICAgICAgICAgcmVxdWVzdENvbnRleHQsXG4gICAgICAgICAgZGF0YVN0cmF0ZWd5LFxuICAgICAgICAgIHNraXBMb2FkZXJFcnJvckJ1YmJsaW5nLFxuICAgICAgICAgIHJvdXRlTWF0Y2ggIT0gbnVsbFxuICAgICAgICApO1xuICAgICAgICByZXR1cm4gcmVzdWx0MjtcbiAgICAgIH1cbiAgICAgIGxldCByZXN1bHQgPSBhd2FpdCBsb2FkUm91dGVEYXRhKFxuICAgICAgICByZXF1ZXN0LFxuICAgICAgICBtYXRjaGVzLFxuICAgICAgICByZXF1ZXN0Q29udGV4dCxcbiAgICAgICAgZGF0YVN0cmF0ZWd5LFxuICAgICAgICBza2lwTG9hZGVyRXJyb3JCdWJibGluZyxcbiAgICAgICAgcm91dGVNYXRjaFxuICAgICAgKTtcbiAgICAgIHJldHVybiBpc1Jlc3BvbnNlKHJlc3VsdCkgPyByZXN1bHQgOiB7XG4gICAgICAgIC4uLnJlc3VsdCxcbiAgICAgICAgYWN0aW9uRGF0YTogbnVsbCxcbiAgICAgICAgYWN0aW9uSGVhZGVyczoge31cbiAgICAgIH07XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgaWYgKGlzRGF0YVN0cmF0ZWd5UmVzdWx0KGUpICYmIGlzUmVzcG9uc2UoZS5yZXN1bHQpKSB7XG4gICAgICAgIGlmIChlLnR5cGUgPT09IFwiZXJyb3JcIiAvKiBlcnJvciAqLykge1xuICAgICAgICAgIHRocm93IGUucmVzdWx0O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlLnJlc3VsdDtcbiAgICAgIH1cbiAgICAgIGlmIChpc1JlZGlyZWN0UmVzcG9uc2UoZSkpIHtcbiAgICAgICAgcmV0dXJuIGU7XG4gICAgICB9XG4gICAgICB0aHJvdyBlO1xuICAgIH1cbiAgfVxuICBhc3luYyBmdW5jdGlvbiBzdWJtaXQocmVxdWVzdCwgbWF0Y2hlcywgYWN0aW9uTWF0Y2gsIHJlcXVlc3RDb250ZXh0LCBkYXRhU3RyYXRlZ3ksIHNraXBMb2FkZXJFcnJvckJ1YmJsaW5nLCBpc1JvdXRlUmVxdWVzdCkge1xuICAgIGxldCByZXN1bHQ7XG4gICAgaWYgKCFhY3Rpb25NYXRjaC5yb3V0ZS5hY3Rpb24gJiYgIWFjdGlvbk1hdGNoLnJvdXRlLmxhenkpIHtcbiAgICAgIGxldCBlcnJvciA9IGdldEludGVybmFsUm91dGVyRXJyb3IoNDA1LCB7XG4gICAgICAgIG1ldGhvZDogcmVxdWVzdC5tZXRob2QsXG4gICAgICAgIHBhdGhuYW1lOiBuZXcgVVJMKHJlcXVlc3QudXJsKS5wYXRobmFtZSxcbiAgICAgICAgcm91dGVJZDogYWN0aW9uTWF0Y2gucm91dGUuaWRcbiAgICAgIH0pO1xuICAgICAgaWYgKGlzUm91dGVSZXF1ZXN0KSB7XG4gICAgICAgIHRocm93IGVycm9yO1xuICAgICAgfVxuICAgICAgcmVzdWx0ID0ge1xuICAgICAgICB0eXBlOiBcImVycm9yXCIgLyogZXJyb3IgKi8sXG4gICAgICAgIGVycm9yXG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICBsZXQgcmVzdWx0cyA9IGF3YWl0IGNhbGxEYXRhU3RyYXRlZ3koXG4gICAgICAgIFwiYWN0aW9uXCIsXG4gICAgICAgIHJlcXVlc3QsXG4gICAgICAgIFthY3Rpb25NYXRjaF0sXG4gICAgICAgIG1hdGNoZXMsXG4gICAgICAgIGlzUm91dGVSZXF1ZXN0LFxuICAgICAgICByZXF1ZXN0Q29udGV4dCxcbiAgICAgICAgZGF0YVN0cmF0ZWd5XG4gICAgICApO1xuICAgICAgcmVzdWx0ID0gcmVzdWx0c1thY3Rpb25NYXRjaC5yb3V0ZS5pZF07XG4gICAgICBpZiAocmVxdWVzdC5zaWduYWwuYWJvcnRlZCkge1xuICAgICAgICB0aHJvd1N0YXRpY0hhbmRsZXJBYm9ydGVkRXJyb3IocmVxdWVzdCwgaXNSb3V0ZVJlcXVlc3QpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoaXNSZWRpcmVjdFJlc3VsdChyZXN1bHQpKSB7XG4gICAgICB0aHJvdyBuZXcgUmVzcG9uc2UobnVsbCwge1xuICAgICAgICBzdGF0dXM6IHJlc3VsdC5yZXNwb25zZS5zdGF0dXMsXG4gICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICBMb2NhdGlvbjogcmVzdWx0LnJlc3BvbnNlLmhlYWRlcnMuZ2V0KFwiTG9jYXRpb25cIilcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICAgIGlmIChpc1JvdXRlUmVxdWVzdCkge1xuICAgICAgaWYgKGlzRXJyb3JSZXN1bHQocmVzdWx0KSkge1xuICAgICAgICB0aHJvdyByZXN1bHQuZXJyb3I7XG4gICAgICB9XG4gICAgICByZXR1cm4ge1xuICAgICAgICBtYXRjaGVzOiBbYWN0aW9uTWF0Y2hdLFxuICAgICAgICBsb2FkZXJEYXRhOiB7fSxcbiAgICAgICAgYWN0aW9uRGF0YTogeyBbYWN0aW9uTWF0Y2gucm91dGUuaWRdOiByZXN1bHQuZGF0YSB9LFxuICAgICAgICBlcnJvcnM6IG51bGwsXG4gICAgICAgIC8vIE5vdGU6IHN0YXR1c0NvZGUgKyBoZWFkZXJzIGFyZSB1bnVzZWQgaGVyZSBzaW5jZSBxdWVyeVJvdXRlIHdpbGxcbiAgICAgICAgLy8gcmV0dXJuIHRoZSByYXcgUmVzcG9uc2Ugb3IgdmFsdWVcbiAgICAgICAgc3RhdHVzQ29kZTogMjAwLFxuICAgICAgICBsb2FkZXJIZWFkZXJzOiB7fSxcbiAgICAgICAgYWN0aW9uSGVhZGVyczoge31cbiAgICAgIH07XG4gICAgfVxuICAgIGxldCBsb2FkZXJSZXF1ZXN0ID0gbmV3IFJlcXVlc3QocmVxdWVzdC51cmwsIHtcbiAgICAgIGhlYWRlcnM6IHJlcXVlc3QuaGVhZGVycyxcbiAgICAgIHJlZGlyZWN0OiByZXF1ZXN0LnJlZGlyZWN0LFxuICAgICAgc2lnbmFsOiByZXF1ZXN0LnNpZ25hbFxuICAgIH0pO1xuICAgIGlmIChpc0Vycm9yUmVzdWx0KHJlc3VsdCkpIHtcbiAgICAgIGxldCBib3VuZGFyeU1hdGNoID0gc2tpcExvYWRlckVycm9yQnViYmxpbmcgPyBhY3Rpb25NYXRjaCA6IGZpbmROZWFyZXN0Qm91bmRhcnkobWF0Y2hlcywgYWN0aW9uTWF0Y2gucm91dGUuaWQpO1xuICAgICAgbGV0IGNvbnRleHQyID0gYXdhaXQgbG9hZFJvdXRlRGF0YShcbiAgICAgICAgbG9hZGVyUmVxdWVzdCxcbiAgICAgICAgbWF0Y2hlcyxcbiAgICAgICAgcmVxdWVzdENvbnRleHQsXG4gICAgICAgIGRhdGFTdHJhdGVneSxcbiAgICAgICAgc2tpcExvYWRlckVycm9yQnViYmxpbmcsXG4gICAgICAgIG51bGwsXG4gICAgICAgIFtib3VuZGFyeU1hdGNoLnJvdXRlLmlkLCByZXN1bHRdXG4gICAgICApO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgLi4uY29udGV4dDIsXG4gICAgICAgIHN0YXR1c0NvZGU6IGlzUm91dGVFcnJvclJlc3BvbnNlKHJlc3VsdC5lcnJvcikgPyByZXN1bHQuZXJyb3Iuc3RhdHVzIDogcmVzdWx0LnN0YXR1c0NvZGUgIT0gbnVsbCA/IHJlc3VsdC5zdGF0dXNDb2RlIDogNTAwLFxuICAgICAgICBhY3Rpb25EYXRhOiBudWxsLFxuICAgICAgICBhY3Rpb25IZWFkZXJzOiB7XG4gICAgICAgICAgLi4ucmVzdWx0LmhlYWRlcnMgPyB7IFthY3Rpb25NYXRjaC5yb3V0ZS5pZF06IHJlc3VsdC5oZWFkZXJzIH0gOiB7fVxuICAgICAgICB9XG4gICAgICB9O1xuICAgIH1cbiAgICBsZXQgY29udGV4dCA9IGF3YWl0IGxvYWRSb3V0ZURhdGEoXG4gICAgICBsb2FkZXJSZXF1ZXN0LFxuICAgICAgbWF0Y2hlcyxcbiAgICAgIHJlcXVlc3RDb250ZXh0LFxuICAgICAgZGF0YVN0cmF0ZWd5LFxuICAgICAgc2tpcExvYWRlckVycm9yQnViYmxpbmcsXG4gICAgICBudWxsXG4gICAgKTtcbiAgICByZXR1cm4ge1xuICAgICAgLi4uY29udGV4dCxcbiAgICAgIGFjdGlvbkRhdGE6IHtcbiAgICAgICAgW2FjdGlvbk1hdGNoLnJvdXRlLmlkXTogcmVzdWx0LmRhdGFcbiAgICAgIH0sXG4gICAgICAvLyBhY3Rpb24gc3RhdHVzIGNvZGVzIHRha2UgcHJlY2VkZW5jZSBvdmVyIGxvYWRlciBzdGF0dXMgY29kZXNcbiAgICAgIC4uLnJlc3VsdC5zdGF0dXNDb2RlID8geyBzdGF0dXNDb2RlOiByZXN1bHQuc3RhdHVzQ29kZSB9IDoge30sXG4gICAgICBhY3Rpb25IZWFkZXJzOiByZXN1bHQuaGVhZGVycyA/IHsgW2FjdGlvbk1hdGNoLnJvdXRlLmlkXTogcmVzdWx0LmhlYWRlcnMgfSA6IHt9XG4gICAgfTtcbiAgfVxuICBhc3luYyBmdW5jdGlvbiBsb2FkUm91dGVEYXRhKHJlcXVlc3QsIG1hdGNoZXMsIHJlcXVlc3RDb250ZXh0LCBkYXRhU3RyYXRlZ3ksIHNraXBMb2FkZXJFcnJvckJ1YmJsaW5nLCByb3V0ZU1hdGNoLCBwZW5kaW5nQWN0aW9uUmVzdWx0KSB7XG4gICAgbGV0IGlzUm91dGVSZXF1ZXN0ID0gcm91dGVNYXRjaCAhPSBudWxsO1xuICAgIGlmIChpc1JvdXRlUmVxdWVzdCAmJiAhcm91dGVNYXRjaD8ucm91dGUubG9hZGVyICYmICFyb3V0ZU1hdGNoPy5yb3V0ZS5sYXp5KSB7XG4gICAgICB0aHJvdyBnZXRJbnRlcm5hbFJvdXRlckVycm9yKDQwMCwge1xuICAgICAgICBtZXRob2Q6IHJlcXVlc3QubWV0aG9kLFxuICAgICAgICBwYXRobmFtZTogbmV3IFVSTChyZXF1ZXN0LnVybCkucGF0aG5hbWUsXG4gICAgICAgIHJvdXRlSWQ6IHJvdXRlTWF0Y2g/LnJvdXRlLmlkXG4gICAgICB9KTtcbiAgICB9XG4gICAgbGV0IHJlcXVlc3RNYXRjaGVzID0gcm91dGVNYXRjaCA/IFtyb3V0ZU1hdGNoXSA6IHBlbmRpbmdBY3Rpb25SZXN1bHQgJiYgaXNFcnJvclJlc3VsdChwZW5kaW5nQWN0aW9uUmVzdWx0WzFdKSA/IGdldExvYWRlck1hdGNoZXNVbnRpbEJvdW5kYXJ5KG1hdGNoZXMsIHBlbmRpbmdBY3Rpb25SZXN1bHRbMF0pIDogbWF0Y2hlcztcbiAgICBsZXQgbWF0Y2hlc1RvTG9hZCA9IHJlcXVlc3RNYXRjaGVzLmZpbHRlcihcbiAgICAgIChtKSA9PiBtLnJvdXRlLmxvYWRlciB8fCBtLnJvdXRlLmxhenlcbiAgICApO1xuICAgIGlmIChtYXRjaGVzVG9Mb2FkLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbWF0Y2hlcyxcbiAgICAgICAgLy8gQWRkIGEgbnVsbCBmb3IgYWxsIG1hdGNoZWQgcm91dGVzIGZvciBwcm9wZXIgcmV2YWxpZGF0aW9uIG9uIHRoZSBjbGllbnRcbiAgICAgICAgbG9hZGVyRGF0YTogbWF0Y2hlcy5yZWR1Y2UoXG4gICAgICAgICAgKGFjYywgbSkgPT4gT2JqZWN0LmFzc2lnbihhY2MsIHsgW20ucm91dGUuaWRdOiBudWxsIH0pLFxuICAgICAgICAgIHt9XG4gICAgICAgICksXG4gICAgICAgIGVycm9yczogcGVuZGluZ0FjdGlvblJlc3VsdCAmJiBpc0Vycm9yUmVzdWx0KHBlbmRpbmdBY3Rpb25SZXN1bHRbMV0pID8ge1xuICAgICAgICAgIFtwZW5kaW5nQWN0aW9uUmVzdWx0WzBdXTogcGVuZGluZ0FjdGlvblJlc3VsdFsxXS5lcnJvclxuICAgICAgICB9IDogbnVsbCxcbiAgICAgICAgc3RhdHVzQ29kZTogMjAwLFxuICAgICAgICBsb2FkZXJIZWFkZXJzOiB7fVxuICAgICAgfTtcbiAgICB9XG4gICAgbGV0IHJlc3VsdHMgPSBhd2FpdCBjYWxsRGF0YVN0cmF0ZWd5KFxuICAgICAgXCJsb2FkZXJcIixcbiAgICAgIHJlcXVlc3QsXG4gICAgICBtYXRjaGVzVG9Mb2FkLFxuICAgICAgbWF0Y2hlcyxcbiAgICAgIGlzUm91dGVSZXF1ZXN0LFxuICAgICAgcmVxdWVzdENvbnRleHQsXG4gICAgICBkYXRhU3RyYXRlZ3lcbiAgICApO1xuICAgIGlmIChyZXF1ZXN0LnNpZ25hbC5hYm9ydGVkKSB7XG4gICAgICB0aHJvd1N0YXRpY0hhbmRsZXJBYm9ydGVkRXJyb3IocmVxdWVzdCwgaXNSb3V0ZVJlcXVlc3QpO1xuICAgIH1cbiAgICBsZXQgY29udGV4dCA9IHByb2Nlc3NSb3V0ZUxvYWRlckRhdGEoXG4gICAgICBtYXRjaGVzLFxuICAgICAgcmVzdWx0cyxcbiAgICAgIHBlbmRpbmdBY3Rpb25SZXN1bHQsXG4gICAgICB0cnVlLFxuICAgICAgc2tpcExvYWRlckVycm9yQnViYmxpbmdcbiAgICApO1xuICAgIGxldCBleGVjdXRlZExvYWRlcnMgPSBuZXcgU2V0KFxuICAgICAgbWF0Y2hlc1RvTG9hZC5tYXAoKG1hdGNoKSA9PiBtYXRjaC5yb3V0ZS5pZClcbiAgICApO1xuICAgIG1hdGNoZXMuZm9yRWFjaCgobWF0Y2gpID0+IHtcbiAgICAgIGlmICghZXhlY3V0ZWRMb2FkZXJzLmhhcyhtYXRjaC5yb3V0ZS5pZCkpIHtcbiAgICAgICAgY29udGV4dC5sb2FkZXJEYXRhW21hdGNoLnJvdXRlLmlkXSA9IG51bGw7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLmNvbnRleHQsXG4gICAgICBtYXRjaGVzXG4gICAgfTtcbiAgfVxuICBhc3luYyBmdW5jdGlvbiBjYWxsRGF0YVN0cmF0ZWd5KHR5cGUsIHJlcXVlc3QsIG1hdGNoZXNUb0xvYWQsIG1hdGNoZXMsIGlzUm91dGVSZXF1ZXN0LCByZXF1ZXN0Q29udGV4dCwgZGF0YVN0cmF0ZWd5KSB7XG4gICAgbGV0IHJlc3VsdHMgPSBhd2FpdCBjYWxsRGF0YVN0cmF0ZWd5SW1wbChcbiAgICAgIGRhdGFTdHJhdGVneSB8fCBkZWZhdWx0RGF0YVN0cmF0ZWd5LFxuICAgICAgdHlwZSxcbiAgICAgIG51bGwsXG4gICAgICByZXF1ZXN0LFxuICAgICAgbWF0Y2hlc1RvTG9hZCxcbiAgICAgIG1hdGNoZXMsXG4gICAgICBudWxsLFxuICAgICAgbWFuaWZlc3QsXG4gICAgICBtYXBSb3V0ZVByb3BlcnRpZXMyLFxuICAgICAgcmVxdWVzdENvbnRleHRcbiAgICApO1xuICAgIGxldCBkYXRhUmVzdWx0cyA9IHt9O1xuICAgIGF3YWl0IFByb21pc2UuYWxsKFxuICAgICAgbWF0Y2hlcy5tYXAoYXN5bmMgKG1hdGNoKSA9PiB7XG4gICAgICAgIGlmICghKG1hdGNoLnJvdXRlLmlkIGluIHJlc3VsdHMpKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGxldCByZXN1bHQgPSByZXN1bHRzW21hdGNoLnJvdXRlLmlkXTtcbiAgICAgICAgaWYgKGlzUmVkaXJlY3REYXRhU3RyYXRlZ3lSZXN1bHQocmVzdWx0KSkge1xuICAgICAgICAgIGxldCByZXNwb25zZSA9IHJlc3VsdC5yZXN1bHQ7XG4gICAgICAgICAgdGhyb3cgbm9ybWFsaXplUmVsYXRpdmVSb3V0aW5nUmVkaXJlY3RSZXNwb25zZShcbiAgICAgICAgICAgIHJlc3BvbnNlLFxuICAgICAgICAgICAgcmVxdWVzdCxcbiAgICAgICAgICAgIG1hdGNoLnJvdXRlLmlkLFxuICAgICAgICAgICAgbWF0Y2hlcyxcbiAgICAgICAgICAgIGJhc2VuYW1lXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNSZXNwb25zZShyZXN1bHQucmVzdWx0KSAmJiBpc1JvdXRlUmVxdWVzdCkge1xuICAgICAgICAgIHRocm93IHJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgICBkYXRhUmVzdWx0c1ttYXRjaC5yb3V0ZS5pZF0gPSBhd2FpdCBjb252ZXJ0RGF0YVN0cmF0ZWd5UmVzdWx0VG9EYXRhUmVzdWx0KHJlc3VsdCk7XG4gICAgICB9KVxuICAgICk7XG4gICAgcmV0dXJuIGRhdGFSZXN1bHRzO1xuICB9XG4gIHJldHVybiB7XG4gICAgZGF0YVJvdXRlcyxcbiAgICBxdWVyeSxcbiAgICBxdWVyeVJvdXRlXG4gIH07XG59XG5mdW5jdGlvbiBnZXRTdGF0aWNDb250ZXh0RnJvbUVycm9yKHJvdXRlcywgY29udGV4dCwgZXJyb3IpIHtcbiAgbGV0IG5ld0NvbnRleHQgPSB7XG4gICAgLi4uY29udGV4dCxcbiAgICBzdGF0dXNDb2RlOiBpc1JvdXRlRXJyb3JSZXNwb25zZShlcnJvcikgPyBlcnJvci5zdGF0dXMgOiA1MDAsXG4gICAgZXJyb3JzOiB7XG4gICAgICBbY29udGV4dC5fZGVlcGVzdFJlbmRlcmVkQm91bmRhcnlJZCB8fCByb3V0ZXNbMF0uaWRdOiBlcnJvclxuICAgIH1cbiAgfTtcbiAgcmV0dXJuIG5ld0NvbnRleHQ7XG59XG5mdW5jdGlvbiB0aHJvd1N0YXRpY0hhbmRsZXJBYm9ydGVkRXJyb3IocmVxdWVzdCwgaXNSb3V0ZVJlcXVlc3QpIHtcbiAgaWYgKHJlcXVlc3Quc2lnbmFsLnJlYXNvbiAhPT0gdm9pZCAwKSB7XG4gICAgdGhyb3cgcmVxdWVzdC5zaWduYWwucmVhc29uO1xuICB9XG4gIGxldCBtZXRob2QgPSBpc1JvdXRlUmVxdWVzdCA/IFwicXVlcnlSb3V0ZVwiIDogXCJxdWVyeVwiO1xuICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgYCR7bWV0aG9kfSgpIGNhbGwgYWJvcnRlZCB3aXRob3V0IGFuIFxcYEFib3J0U2lnbmFsLnJlYXNvblxcYDogJHtyZXF1ZXN0Lm1ldGhvZH0gJHtyZXF1ZXN0LnVybH1gXG4gICk7XG59XG5mdW5jdGlvbiBpc1N1Ym1pc3Npb25OYXZpZ2F0aW9uKG9wdHMpIHtcbiAgcmV0dXJuIG9wdHMgIT0gbnVsbCAmJiAoXCJmb3JtRGF0YVwiIGluIG9wdHMgJiYgb3B0cy5mb3JtRGF0YSAhPSBudWxsIHx8IFwiYm9keVwiIGluIG9wdHMgJiYgb3B0cy5ib2R5ICE9PSB2b2lkIDApO1xufVxuZnVuY3Rpb24gbm9ybWFsaXplVG8obG9jYXRpb24sIG1hdGNoZXMsIGJhc2VuYW1lLCB0bywgZnJvbVJvdXRlSWQsIHJlbGF0aXZlKSB7XG4gIGxldCBjb250ZXh0dWFsTWF0Y2hlcztcbiAgbGV0IGFjdGl2ZVJvdXRlTWF0Y2g7XG4gIGlmIChmcm9tUm91dGVJZCkge1xuICAgIGNvbnRleHR1YWxNYXRjaGVzID0gW107XG4gICAgZm9yIChsZXQgbWF0Y2ggb2YgbWF0Y2hlcykge1xuICAgICAgY29udGV4dHVhbE1hdGNoZXMucHVzaChtYXRjaCk7XG4gICAgICBpZiAobWF0Y2gucm91dGUuaWQgPT09IGZyb21Sb3V0ZUlkKSB7XG4gICAgICAgIGFjdGl2ZVJvdXRlTWF0Y2ggPSBtYXRjaDtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGNvbnRleHR1YWxNYXRjaGVzID0gbWF0Y2hlcztcbiAgICBhY3RpdmVSb3V0ZU1hdGNoID0gbWF0Y2hlc1ttYXRjaGVzLmxlbmd0aCAtIDFdO1xuICB9XG4gIGxldCBwYXRoID0gcmVzb2x2ZVRvKFxuICAgIHRvID8gdG8gOiBcIi5cIixcbiAgICBnZXRSZXNvbHZlVG9NYXRjaGVzKGNvbnRleHR1YWxNYXRjaGVzKSxcbiAgICBzdHJpcEJhc2VuYW1lKGxvY2F0aW9uLnBhdGhuYW1lLCBiYXNlbmFtZSkgfHwgbG9jYXRpb24ucGF0aG5hbWUsXG4gICAgcmVsYXRpdmUgPT09IFwicGF0aFwiXG4gICk7XG4gIGlmICh0byA9PSBudWxsKSB7XG4gICAgcGF0aC5zZWFyY2ggPSBsb2NhdGlvbi5zZWFyY2g7XG4gICAgcGF0aC5oYXNoID0gbG9jYXRpb24uaGFzaDtcbiAgfVxuICBpZiAoKHRvID09IG51bGwgfHwgdG8gPT09IFwiXCIgfHwgdG8gPT09IFwiLlwiKSAmJiBhY3RpdmVSb3V0ZU1hdGNoKSB7XG4gICAgbGV0IG5ha2VkSW5kZXggPSBoYXNOYWtlZEluZGV4UXVlcnkocGF0aC5zZWFyY2gpO1xuICAgIGlmIChhY3RpdmVSb3V0ZU1hdGNoLnJvdXRlLmluZGV4ICYmICFuYWtlZEluZGV4KSB7XG4gICAgICBwYXRoLnNlYXJjaCA9IHBhdGguc2VhcmNoID8gcGF0aC5zZWFyY2gucmVwbGFjZSgvXlxcPy8sIFwiP2luZGV4JlwiKSA6IFwiP2luZGV4XCI7XG4gICAgfSBlbHNlIGlmICghYWN0aXZlUm91dGVNYXRjaC5yb3V0ZS5pbmRleCAmJiBuYWtlZEluZGV4KSB7XG4gICAgICBsZXQgcGFyYW1zID0gbmV3IFVSTFNlYXJjaFBhcmFtcyhwYXRoLnNlYXJjaCk7XG4gICAgICBsZXQgaW5kZXhWYWx1ZXMgPSBwYXJhbXMuZ2V0QWxsKFwiaW5kZXhcIik7XG4gICAgICBwYXJhbXMuZGVsZXRlKFwiaW5kZXhcIik7XG4gICAgICBpbmRleFZhbHVlcy5maWx0ZXIoKHYpID0+IHYpLmZvckVhY2goKHYpID0+IHBhcmFtcy5hcHBlbmQoXCJpbmRleFwiLCB2KSk7XG4gICAgICBsZXQgcXMgPSBwYXJhbXMudG9TdHJpbmcoKTtcbiAgICAgIHBhdGguc2VhcmNoID0gcXMgPyBgPyR7cXN9YCA6IFwiXCI7XG4gICAgfVxuICB9XG4gIGlmIChiYXNlbmFtZSAhPT0gXCIvXCIpIHtcbiAgICBwYXRoLnBhdGhuYW1lID0gcGF0aC5wYXRobmFtZSA9PT0gXCIvXCIgPyBiYXNlbmFtZSA6IGpvaW5QYXRocyhbYmFzZW5hbWUsIHBhdGgucGF0aG5hbWVdKTtcbiAgfVxuICByZXR1cm4gY3JlYXRlUGF0aChwYXRoKTtcbn1cbmZ1bmN0aW9uIG5vcm1hbGl6ZU5hdmlnYXRlT3B0aW9ucyhpc0ZldGNoZXIsIHBhdGgsIG9wdHMpIHtcbiAgaWYgKCFvcHRzIHx8ICFpc1N1Ym1pc3Npb25OYXZpZ2F0aW9uKG9wdHMpKSB7XG4gICAgcmV0dXJuIHsgcGF0aCB9O1xuICB9XG4gIGlmIChvcHRzLmZvcm1NZXRob2QgJiYgIWlzVmFsaWRNZXRob2Qob3B0cy5mb3JtTWV0aG9kKSkge1xuICAgIHJldHVybiB7XG4gICAgICBwYXRoLFxuICAgICAgZXJyb3I6IGdldEludGVybmFsUm91dGVyRXJyb3IoNDA1LCB7IG1ldGhvZDogb3B0cy5mb3JtTWV0aG9kIH0pXG4gICAgfTtcbiAgfVxuICBsZXQgZ2V0SW52YWxpZEJvZHlFcnJvciA9ICgpID0+ICh7XG4gICAgcGF0aCxcbiAgICBlcnJvcjogZ2V0SW50ZXJuYWxSb3V0ZXJFcnJvcig0MDAsIHsgdHlwZTogXCJpbnZhbGlkLWJvZHlcIiB9KVxuICB9KTtcbiAgbGV0IHJhd0Zvcm1NZXRob2QgPSBvcHRzLmZvcm1NZXRob2QgfHwgXCJnZXRcIjtcbiAgbGV0IGZvcm1NZXRob2QgPSByYXdGb3JtTWV0aG9kLnRvVXBwZXJDYXNlKCk7XG4gIGxldCBmb3JtQWN0aW9uID0gc3RyaXBIYXNoRnJvbVBhdGgocGF0aCk7XG4gIGlmIChvcHRzLmJvZHkgIT09IHZvaWQgMCkge1xuICAgIGlmIChvcHRzLmZvcm1FbmNUeXBlID09PSBcInRleHQvcGxhaW5cIikge1xuICAgICAgaWYgKCFpc011dGF0aW9uTWV0aG9kKGZvcm1NZXRob2QpKSB7XG4gICAgICAgIHJldHVybiBnZXRJbnZhbGlkQm9keUVycm9yKCk7XG4gICAgICB9XG4gICAgICBsZXQgdGV4dCA9IHR5cGVvZiBvcHRzLmJvZHkgPT09IFwic3RyaW5nXCIgPyBvcHRzLmJvZHkgOiBvcHRzLmJvZHkgaW5zdGFuY2VvZiBGb3JtRGF0YSB8fCBvcHRzLmJvZHkgaW5zdGFuY2VvZiBVUkxTZWFyY2hQYXJhbXMgPyAoXG4gICAgICAgIC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL2Zvcm0tY29udHJvbC1pbmZyYXN0cnVjdHVyZS5odG1sI3BsYWluLXRleHQtZm9ybS1kYXRhXG4gICAgICAgIEFycmF5LmZyb20ob3B0cy5ib2R5LmVudHJpZXMoKSkucmVkdWNlKFxuICAgICAgICAgIChhY2MsIFtuYW1lLCB2YWx1ZV0pID0+IGAke2FjY30ke25hbWV9PSR7dmFsdWV9XG5gLFxuICAgICAgICAgIFwiXCJcbiAgICAgICAgKVxuICAgICAgKSA6IFN0cmluZyhvcHRzLmJvZHkpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcGF0aCxcbiAgICAgICAgc3VibWlzc2lvbjoge1xuICAgICAgICAgIGZvcm1NZXRob2QsXG4gICAgICAgICAgZm9ybUFjdGlvbixcbiAgICAgICAgICBmb3JtRW5jVHlwZTogb3B0cy5mb3JtRW5jVHlwZSxcbiAgICAgICAgICBmb3JtRGF0YTogdm9pZCAwLFxuICAgICAgICAgIGpzb246IHZvaWQgMCxcbiAgICAgICAgICB0ZXh0XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfSBlbHNlIGlmIChvcHRzLmZvcm1FbmNUeXBlID09PSBcImFwcGxpY2F0aW9uL2pzb25cIikge1xuICAgICAgaWYgKCFpc011dGF0aW9uTWV0aG9kKGZvcm1NZXRob2QpKSB7XG4gICAgICAgIHJldHVybiBnZXRJbnZhbGlkQm9keUVycm9yKCk7XG4gICAgICB9XG4gICAgICB0cnkge1xuICAgICAgICBsZXQganNvbiA9IHR5cGVvZiBvcHRzLmJvZHkgPT09IFwic3RyaW5nXCIgPyBKU09OLnBhcnNlKG9wdHMuYm9keSkgOiBvcHRzLmJvZHk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgcGF0aCxcbiAgICAgICAgICBzdWJtaXNzaW9uOiB7XG4gICAgICAgICAgICBmb3JtTWV0aG9kLFxuICAgICAgICAgICAgZm9ybUFjdGlvbixcbiAgICAgICAgICAgIGZvcm1FbmNUeXBlOiBvcHRzLmZvcm1FbmNUeXBlLFxuICAgICAgICAgICAgZm9ybURhdGE6IHZvaWQgMCxcbiAgICAgICAgICAgIGpzb24sXG4gICAgICAgICAgICB0ZXh0OiB2b2lkIDBcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHJldHVybiBnZXRJbnZhbGlkQm9keUVycm9yKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGludmFyaWFudChcbiAgICB0eXBlb2YgRm9ybURhdGEgPT09IFwiZnVuY3Rpb25cIixcbiAgICBcIkZvcm1EYXRhIGlzIG5vdCBhdmFpbGFibGUgaW4gdGhpcyBlbnZpcm9ubWVudFwiXG4gICk7XG4gIGxldCBzZWFyY2hQYXJhbXM7XG4gIGxldCBmb3JtRGF0YTtcbiAgaWYgKG9wdHMuZm9ybURhdGEpIHtcbiAgICBzZWFyY2hQYXJhbXMgPSBjb252ZXJ0Rm9ybURhdGFUb1NlYXJjaFBhcmFtcyhvcHRzLmZvcm1EYXRhKTtcbiAgICBmb3JtRGF0YSA9IG9wdHMuZm9ybURhdGE7XG4gIH0gZWxzZSBpZiAob3B0cy5ib2R5IGluc3RhbmNlb2YgRm9ybURhdGEpIHtcbiAgICBzZWFyY2hQYXJhbXMgPSBjb252ZXJ0Rm9ybURhdGFUb1NlYXJjaFBhcmFtcyhvcHRzLmJvZHkpO1xuICAgIGZvcm1EYXRhID0gb3B0cy5ib2R5O1xuICB9IGVsc2UgaWYgKG9wdHMuYm9keSBpbnN0YW5jZW9mIFVSTFNlYXJjaFBhcmFtcykge1xuICAgIHNlYXJjaFBhcmFtcyA9IG9wdHMuYm9keTtcbiAgICBmb3JtRGF0YSA9IGNvbnZlcnRTZWFyY2hQYXJhbXNUb0Zvcm1EYXRhKHNlYXJjaFBhcmFtcyk7XG4gIH0gZWxzZSBpZiAob3B0cy5ib2R5ID09IG51bGwpIHtcbiAgICBzZWFyY2hQYXJhbXMgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKCk7XG4gICAgZm9ybURhdGEgPSBuZXcgRm9ybURhdGEoKTtcbiAgfSBlbHNlIHtcbiAgICB0cnkge1xuICAgICAgc2VhcmNoUGFyYW1zID0gbmV3IFVSTFNlYXJjaFBhcmFtcyhvcHRzLmJvZHkpO1xuICAgICAgZm9ybURhdGEgPSBjb252ZXJ0U2VhcmNoUGFyYW1zVG9Gb3JtRGF0YShzZWFyY2hQYXJhbXMpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHJldHVybiBnZXRJbnZhbGlkQm9keUVycm9yKCk7XG4gICAgfVxuICB9XG4gIGxldCBzdWJtaXNzaW9uID0ge1xuICAgIGZvcm1NZXRob2QsXG4gICAgZm9ybUFjdGlvbixcbiAgICBmb3JtRW5jVHlwZTogb3B0cyAmJiBvcHRzLmZvcm1FbmNUeXBlIHx8IFwiYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkXCIsXG4gICAgZm9ybURhdGEsXG4gICAganNvbjogdm9pZCAwLFxuICAgIHRleHQ6IHZvaWQgMFxuICB9O1xuICBpZiAoaXNNdXRhdGlvbk1ldGhvZChzdWJtaXNzaW9uLmZvcm1NZXRob2QpKSB7XG4gICAgcmV0dXJuIHsgcGF0aCwgc3VibWlzc2lvbiB9O1xuICB9XG4gIGxldCBwYXJzZWRQYXRoID0gcGFyc2VQYXRoKHBhdGgpO1xuICBpZiAoaXNGZXRjaGVyICYmIHBhcnNlZFBhdGguc2VhcmNoICYmIGhhc05ha2VkSW5kZXhRdWVyeShwYXJzZWRQYXRoLnNlYXJjaCkpIHtcbiAgICBzZWFyY2hQYXJhbXMuYXBwZW5kKFwiaW5kZXhcIiwgXCJcIik7XG4gIH1cbiAgcGFyc2VkUGF0aC5zZWFyY2ggPSBgPyR7c2VhcmNoUGFyYW1zfWA7XG4gIHJldHVybiB7IHBhdGg6IGNyZWF0ZVBhdGgocGFyc2VkUGF0aCksIHN1Ym1pc3Npb24gfTtcbn1cbmZ1bmN0aW9uIGdldExvYWRlck1hdGNoZXNVbnRpbEJvdW5kYXJ5KG1hdGNoZXMsIGJvdW5kYXJ5SWQsIGluY2x1ZGVCb3VuZGFyeSA9IGZhbHNlKSB7XG4gIGxldCBpbmRleCA9IG1hdGNoZXMuZmluZEluZGV4KChtKSA9PiBtLnJvdXRlLmlkID09PSBib3VuZGFyeUlkKTtcbiAgaWYgKGluZGV4ID49IDApIHtcbiAgICByZXR1cm4gbWF0Y2hlcy5zbGljZSgwLCBpbmNsdWRlQm91bmRhcnkgPyBpbmRleCArIDEgOiBpbmRleCk7XG4gIH1cbiAgcmV0dXJuIG1hdGNoZXM7XG59XG5mdW5jdGlvbiBnZXRNYXRjaGVzVG9Mb2FkKGhpc3RvcnksIHN0YXRlLCBtYXRjaGVzLCBzdWJtaXNzaW9uLCBsb2NhdGlvbiwgaW5pdGlhbEh5ZHJhdGlvbiwgaXNSZXZhbGlkYXRpb25SZXF1aXJlZCwgY2FuY2VsbGVkRmV0Y2hlckxvYWRzLCBmZXRjaGVyc1F1ZXVlZEZvckRlbGV0aW9uLCBmZXRjaExvYWRNYXRjaGVzLCBmZXRjaFJlZGlyZWN0SWRzLCByb3V0ZXNUb1VzZSwgYmFzZW5hbWUsIHBlbmRpbmdBY3Rpb25SZXN1bHQpIHtcbiAgbGV0IGFjdGlvblJlc3VsdCA9IHBlbmRpbmdBY3Rpb25SZXN1bHQgPyBpc0Vycm9yUmVzdWx0KHBlbmRpbmdBY3Rpb25SZXN1bHRbMV0pID8gcGVuZGluZ0FjdGlvblJlc3VsdFsxXS5lcnJvciA6IHBlbmRpbmdBY3Rpb25SZXN1bHRbMV0uZGF0YSA6IHZvaWQgMDtcbiAgbGV0IGN1cnJlbnRVcmwgPSBoaXN0b3J5LmNyZWF0ZVVSTChzdGF0ZS5sb2NhdGlvbik7XG4gIGxldCBuZXh0VXJsID0gaGlzdG9yeS5jcmVhdGVVUkwobG9jYXRpb24pO1xuICBsZXQgYm91bmRhcnlNYXRjaGVzID0gbWF0Y2hlcztcbiAgaWYgKGluaXRpYWxIeWRyYXRpb24gJiYgc3RhdGUuZXJyb3JzKSB7XG4gICAgYm91bmRhcnlNYXRjaGVzID0gZ2V0TG9hZGVyTWF0Y2hlc1VudGlsQm91bmRhcnkoXG4gICAgICBtYXRjaGVzLFxuICAgICAgT2JqZWN0LmtleXMoc3RhdGUuZXJyb3JzKVswXSxcbiAgICAgIHRydWVcbiAgICApO1xuICB9IGVsc2UgaWYgKHBlbmRpbmdBY3Rpb25SZXN1bHQgJiYgaXNFcnJvclJlc3VsdChwZW5kaW5nQWN0aW9uUmVzdWx0WzFdKSkge1xuICAgIGJvdW5kYXJ5TWF0Y2hlcyA9IGdldExvYWRlck1hdGNoZXNVbnRpbEJvdW5kYXJ5KFxuICAgICAgbWF0Y2hlcyxcbiAgICAgIHBlbmRpbmdBY3Rpb25SZXN1bHRbMF1cbiAgICApO1xuICB9XG4gIGxldCBhY3Rpb25TdGF0dXMgPSBwZW5kaW5nQWN0aW9uUmVzdWx0ID8gcGVuZGluZ0FjdGlvblJlc3VsdFsxXS5zdGF0dXNDb2RlIDogdm9pZCAwO1xuICBsZXQgc2hvdWxkU2tpcFJldmFsaWRhdGlvbiA9IGFjdGlvblN0YXR1cyAmJiBhY3Rpb25TdGF0dXMgPj0gNDAwO1xuICBsZXQgbmF2aWdhdGlvbk1hdGNoZXMgPSBib3VuZGFyeU1hdGNoZXMuZmlsdGVyKChtYXRjaCwgaW5kZXgpID0+IHtcbiAgICBsZXQgeyByb3V0ZSB9ID0gbWF0Y2g7XG4gICAgaWYgKHJvdXRlLmxhenkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBpZiAocm91dGUubG9hZGVyID09IG51bGwpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKGluaXRpYWxIeWRyYXRpb24pIHtcbiAgICAgIHJldHVybiBzaG91bGRMb2FkUm91dGVPbkh5ZHJhdGlvbihyb3V0ZSwgc3RhdGUubG9hZGVyRGF0YSwgc3RhdGUuZXJyb3JzKTtcbiAgICB9XG4gICAgaWYgKGlzTmV3TG9hZGVyKHN0YXRlLmxvYWRlckRhdGEsIHN0YXRlLm1hdGNoZXNbaW5kZXhdLCBtYXRjaCkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBsZXQgY3VycmVudFJvdXRlTWF0Y2ggPSBzdGF0ZS5tYXRjaGVzW2luZGV4XTtcbiAgICBsZXQgbmV4dFJvdXRlTWF0Y2ggPSBtYXRjaDtcbiAgICByZXR1cm4gc2hvdWxkUmV2YWxpZGF0ZUxvYWRlcihtYXRjaCwge1xuICAgICAgY3VycmVudFVybCxcbiAgICAgIGN1cnJlbnRQYXJhbXM6IGN1cnJlbnRSb3V0ZU1hdGNoLnBhcmFtcyxcbiAgICAgIG5leHRVcmwsXG4gICAgICBuZXh0UGFyYW1zOiBuZXh0Um91dGVNYXRjaC5wYXJhbXMsXG4gICAgICAuLi5zdWJtaXNzaW9uLFxuICAgICAgYWN0aW9uUmVzdWx0LFxuICAgICAgYWN0aW9uU3RhdHVzLFxuICAgICAgZGVmYXVsdFNob3VsZFJldmFsaWRhdGU6IHNob3VsZFNraXBSZXZhbGlkYXRpb24gPyBmYWxzZSA6IChcbiAgICAgICAgLy8gRm9yY2VkIHJldmFsaWRhdGlvbiBkdWUgdG8gc3VibWlzc2lvbiwgdXNlUmV2YWxpZGF0b3IsIG9yIFgtUmVtaXgtUmV2YWxpZGF0ZVxuICAgICAgICBpc1JldmFsaWRhdGlvblJlcXVpcmVkIHx8IGN1cnJlbnRVcmwucGF0aG5hbWUgKyBjdXJyZW50VXJsLnNlYXJjaCA9PT0gbmV4dFVybC5wYXRobmFtZSArIG5leHRVcmwuc2VhcmNoIHx8IC8vIFNlYXJjaCBwYXJhbXMgYWZmZWN0IGFsbCBsb2FkZXJzXG4gICAgICAgIGN1cnJlbnRVcmwuc2VhcmNoICE9PSBuZXh0VXJsLnNlYXJjaCB8fCBpc05ld1JvdXRlSW5zdGFuY2UoY3VycmVudFJvdXRlTWF0Y2gsIG5leHRSb3V0ZU1hdGNoKVxuICAgICAgKVxuICAgIH0pO1xuICB9KTtcbiAgbGV0IHJldmFsaWRhdGluZ0ZldGNoZXJzID0gW107XG4gIGZldGNoTG9hZE1hdGNoZXMuZm9yRWFjaCgoZiwga2V5KSA9PiB7XG4gICAgaWYgKGluaXRpYWxIeWRyYXRpb24gfHwgIW1hdGNoZXMuc29tZSgobSkgPT4gbS5yb3V0ZS5pZCA9PT0gZi5yb3V0ZUlkKSB8fCBmZXRjaGVyc1F1ZXVlZEZvckRlbGV0aW9uLmhhcyhrZXkpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGxldCBmZXRjaGVyTWF0Y2hlcyA9IG1hdGNoUm91dGVzKHJvdXRlc1RvVXNlLCBmLnBhdGgsIGJhc2VuYW1lKTtcbiAgICBpZiAoIWZldGNoZXJNYXRjaGVzKSB7XG4gICAgICByZXZhbGlkYXRpbmdGZXRjaGVycy5wdXNoKHtcbiAgICAgICAga2V5LFxuICAgICAgICByb3V0ZUlkOiBmLnJvdXRlSWQsXG4gICAgICAgIHBhdGg6IGYucGF0aCxcbiAgICAgICAgbWF0Y2hlczogbnVsbCxcbiAgICAgICAgbWF0Y2g6IG51bGwsXG4gICAgICAgIGNvbnRyb2xsZXI6IG51bGxcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBsZXQgZmV0Y2hlciA9IHN0YXRlLmZldGNoZXJzLmdldChrZXkpO1xuICAgIGxldCBmZXRjaGVyTWF0Y2ggPSBnZXRUYXJnZXRNYXRjaChmZXRjaGVyTWF0Y2hlcywgZi5wYXRoKTtcbiAgICBsZXQgc2hvdWxkUmV2YWxpZGF0ZSA9IGZhbHNlO1xuICAgIGlmIChmZXRjaFJlZGlyZWN0SWRzLmhhcyhrZXkpKSB7XG4gICAgICBzaG91bGRSZXZhbGlkYXRlID0gZmFsc2U7XG4gICAgfSBlbHNlIGlmIChjYW5jZWxsZWRGZXRjaGVyTG9hZHMuaGFzKGtleSkpIHtcbiAgICAgIGNhbmNlbGxlZEZldGNoZXJMb2Fkcy5kZWxldGUoa2V5KTtcbiAgICAgIHNob3VsZFJldmFsaWRhdGUgPSB0cnVlO1xuICAgIH0gZWxzZSBpZiAoZmV0Y2hlciAmJiBmZXRjaGVyLnN0YXRlICE9PSBcImlkbGVcIiAmJiBmZXRjaGVyLmRhdGEgPT09IHZvaWQgMCkge1xuICAgICAgc2hvdWxkUmV2YWxpZGF0ZSA9IGlzUmV2YWxpZGF0aW9uUmVxdWlyZWQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNob3VsZFJldmFsaWRhdGUgPSBzaG91bGRSZXZhbGlkYXRlTG9hZGVyKGZldGNoZXJNYXRjaCwge1xuICAgICAgICBjdXJyZW50VXJsLFxuICAgICAgICBjdXJyZW50UGFyYW1zOiBzdGF0ZS5tYXRjaGVzW3N0YXRlLm1hdGNoZXMubGVuZ3RoIC0gMV0ucGFyYW1zLFxuICAgICAgICBuZXh0VXJsLFxuICAgICAgICBuZXh0UGFyYW1zOiBtYXRjaGVzW21hdGNoZXMubGVuZ3RoIC0gMV0ucGFyYW1zLFxuICAgICAgICAuLi5zdWJtaXNzaW9uLFxuICAgICAgICBhY3Rpb25SZXN1bHQsXG4gICAgICAgIGFjdGlvblN0YXR1cyxcbiAgICAgICAgZGVmYXVsdFNob3VsZFJldmFsaWRhdGU6IHNob3VsZFNraXBSZXZhbGlkYXRpb24gPyBmYWxzZSA6IGlzUmV2YWxpZGF0aW9uUmVxdWlyZWRcbiAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAoc2hvdWxkUmV2YWxpZGF0ZSkge1xuICAgICAgcmV2YWxpZGF0aW5nRmV0Y2hlcnMucHVzaCh7XG4gICAgICAgIGtleSxcbiAgICAgICAgcm91dGVJZDogZi5yb3V0ZUlkLFxuICAgICAgICBwYXRoOiBmLnBhdGgsXG4gICAgICAgIG1hdGNoZXM6IGZldGNoZXJNYXRjaGVzLFxuICAgICAgICBtYXRjaDogZmV0Y2hlck1hdGNoLFxuICAgICAgICBjb250cm9sbGVyOiBuZXcgQWJvcnRDb250cm9sbGVyKClcbiAgICAgIH0pO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiBbbmF2aWdhdGlvbk1hdGNoZXMsIHJldmFsaWRhdGluZ0ZldGNoZXJzXTtcbn1cbmZ1bmN0aW9uIHNob3VsZExvYWRSb3V0ZU9uSHlkcmF0aW9uKHJvdXRlLCBsb2FkZXJEYXRhLCBlcnJvcnMpIHtcbiAgaWYgKHJvdXRlLmxhenkpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBpZiAoIXJvdXRlLmxvYWRlcikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBsZXQgaGFzRGF0YSA9IGxvYWRlckRhdGEgIT0gbnVsbCAmJiBsb2FkZXJEYXRhW3JvdXRlLmlkXSAhPT0gdm9pZCAwO1xuICBsZXQgaGFzRXJyb3IgPSBlcnJvcnMgIT0gbnVsbCAmJiBlcnJvcnNbcm91dGUuaWRdICE9PSB2b2lkIDA7XG4gIGlmICghaGFzRGF0YSAmJiBoYXNFcnJvcikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAodHlwZW9mIHJvdXRlLmxvYWRlciA9PT0gXCJmdW5jdGlvblwiICYmIHJvdXRlLmxvYWRlci5oeWRyYXRlID09PSB0cnVlKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuICFoYXNEYXRhICYmICFoYXNFcnJvcjtcbn1cbmZ1bmN0aW9uIGlzTmV3TG9hZGVyKGN1cnJlbnRMb2FkZXJEYXRhLCBjdXJyZW50TWF0Y2gsIG1hdGNoKSB7XG4gIGxldCBpc05ldyA9IChcbiAgICAvLyBbYV0gLT4gW2EsIGJdXG4gICAgIWN1cnJlbnRNYXRjaCB8fCAvLyBbYSwgYl0gLT4gW2EsIGNdXG4gICAgbWF0Y2gucm91dGUuaWQgIT09IGN1cnJlbnRNYXRjaC5yb3V0ZS5pZFxuICApO1xuICBsZXQgaXNNaXNzaW5nRGF0YSA9ICFjdXJyZW50TG9hZGVyRGF0YS5oYXNPd25Qcm9wZXJ0eShtYXRjaC5yb3V0ZS5pZCk7XG4gIHJldHVybiBpc05ldyB8fCBpc01pc3NpbmdEYXRhO1xufVxuZnVuY3Rpb24gaXNOZXdSb3V0ZUluc3RhbmNlKGN1cnJlbnRNYXRjaCwgbWF0Y2gpIHtcbiAgbGV0IGN1cnJlbnRQYXRoID0gY3VycmVudE1hdGNoLnJvdXRlLnBhdGg7XG4gIHJldHVybiAoXG4gICAgLy8gcGFyYW0gY2hhbmdlIGZvciB0aGlzIG1hdGNoLCAvdXNlcnMvMTIzIC0+IC91c2Vycy80NTZcbiAgICBjdXJyZW50TWF0Y2gucGF0aG5hbWUgIT09IG1hdGNoLnBhdGhuYW1lIHx8IC8vIHNwbGF0IHBhcmFtIGNoYW5nZWQsIHdoaWNoIGlzIG5vdCBwcmVzZW50IGluIG1hdGNoLnBhdGhcbiAgICAvLyBlLmcuIC9maWxlcy9pbWFnZXMvYXZhdGFyLmpwZyAtPiBmaWxlcy9maW5hbmNlcy54bHNcbiAgICBjdXJyZW50UGF0aCAhPSBudWxsICYmIGN1cnJlbnRQYXRoLmVuZHNXaXRoKFwiKlwiKSAmJiBjdXJyZW50TWF0Y2gucGFyYW1zW1wiKlwiXSAhPT0gbWF0Y2gucGFyYW1zW1wiKlwiXVxuICApO1xufVxuZnVuY3Rpb24gc2hvdWxkUmV2YWxpZGF0ZUxvYWRlcihsb2FkZXJNYXRjaCwgYXJnKSB7XG4gIGlmIChsb2FkZXJNYXRjaC5yb3V0ZS5zaG91bGRSZXZhbGlkYXRlKSB7XG4gICAgbGV0IHJvdXRlQ2hvaWNlID0gbG9hZGVyTWF0Y2gucm91dGUuc2hvdWxkUmV2YWxpZGF0ZShhcmcpO1xuICAgIGlmICh0eXBlb2Ygcm91dGVDaG9pY2UgPT09IFwiYm9vbGVhblwiKSB7XG4gICAgICByZXR1cm4gcm91dGVDaG9pY2U7XG4gICAgfVxuICB9XG4gIHJldHVybiBhcmcuZGVmYXVsdFNob3VsZFJldmFsaWRhdGU7XG59XG5mdW5jdGlvbiBwYXRjaFJvdXRlc0ltcGwocm91dGVJZCwgY2hpbGRyZW4sIHJvdXRlc1RvVXNlLCBtYW5pZmVzdCwgbWFwUm91dGVQcm9wZXJ0aWVzMikge1xuICBsZXQgY2hpbGRyZW5Ub1BhdGNoO1xuICBpZiAocm91dGVJZCkge1xuICAgIGxldCByb3V0ZSA9IG1hbmlmZXN0W3JvdXRlSWRdO1xuICAgIGludmFyaWFudChcbiAgICAgIHJvdXRlLFxuICAgICAgYE5vIHJvdXRlIGZvdW5kIHRvIHBhdGNoIGNoaWxkcmVuIGludG86IHJvdXRlSWQgPSAke3JvdXRlSWR9YFxuICAgICk7XG4gICAgaWYgKCFyb3V0ZS5jaGlsZHJlbikge1xuICAgICAgcm91dGUuY2hpbGRyZW4gPSBbXTtcbiAgICB9XG4gICAgY2hpbGRyZW5Ub1BhdGNoID0gcm91dGUuY2hpbGRyZW47XG4gIH0gZWxzZSB7XG4gICAgY2hpbGRyZW5Ub1BhdGNoID0gcm91dGVzVG9Vc2U7XG4gIH1cbiAgbGV0IHVuaXF1ZUNoaWxkcmVuID0gY2hpbGRyZW4uZmlsdGVyKFxuICAgIChuZXdSb3V0ZSkgPT4gIWNoaWxkcmVuVG9QYXRjaC5zb21lKFxuICAgICAgKGV4aXN0aW5nUm91dGUpID0+IGlzU2FtZVJvdXRlKG5ld1JvdXRlLCBleGlzdGluZ1JvdXRlKVxuICAgIClcbiAgKTtcbiAgbGV0IG5ld1JvdXRlcyA9IGNvbnZlcnRSb3V0ZXNUb0RhdGFSb3V0ZXMoXG4gICAgdW5pcXVlQ2hpbGRyZW4sXG4gICAgbWFwUm91dGVQcm9wZXJ0aWVzMixcbiAgICBbcm91dGVJZCB8fCBcIl9cIiwgXCJwYXRjaFwiLCBTdHJpbmcoY2hpbGRyZW5Ub1BhdGNoPy5sZW5ndGggfHwgXCIwXCIpXSxcbiAgICBtYW5pZmVzdFxuICApO1xuICBjaGlsZHJlblRvUGF0Y2gucHVzaCguLi5uZXdSb3V0ZXMpO1xufVxuZnVuY3Rpb24gaXNTYW1lUm91dGUobmV3Um91dGUsIGV4aXN0aW5nUm91dGUpIHtcbiAgaWYgKFwiaWRcIiBpbiBuZXdSb3V0ZSAmJiBcImlkXCIgaW4gZXhpc3RpbmdSb3V0ZSAmJiBuZXdSb3V0ZS5pZCA9PT0gZXhpc3RpbmdSb3V0ZS5pZCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGlmICghKG5ld1JvdXRlLmluZGV4ID09PSBleGlzdGluZ1JvdXRlLmluZGV4ICYmIG5ld1JvdXRlLnBhdGggPT09IGV4aXN0aW5nUm91dGUucGF0aCAmJiBuZXdSb3V0ZS5jYXNlU2Vuc2l0aXZlID09PSBleGlzdGluZ1JvdXRlLmNhc2VTZW5zaXRpdmUpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmICgoIW5ld1JvdXRlLmNoaWxkcmVuIHx8IG5ld1JvdXRlLmNoaWxkcmVuLmxlbmd0aCA9PT0gMCkgJiYgKCFleGlzdGluZ1JvdXRlLmNoaWxkcmVuIHx8IGV4aXN0aW5nUm91dGUuY2hpbGRyZW4ubGVuZ3RoID09PSAwKSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiBuZXdSb3V0ZS5jaGlsZHJlbi5ldmVyeShcbiAgICAoYUNoaWxkLCBpKSA9PiBleGlzdGluZ1JvdXRlLmNoaWxkcmVuPy5zb21lKChiQ2hpbGQpID0+IGlzU2FtZVJvdXRlKGFDaGlsZCwgYkNoaWxkKSlcbiAgKTtcbn1cbmFzeW5jIGZ1bmN0aW9uIGxvYWRMYXp5Um91dGVNb2R1bGUocm91dGUsIG1hcFJvdXRlUHJvcGVydGllczIsIG1hbmlmZXN0KSB7XG4gIGlmICghcm91dGUubGF6eSkge1xuICAgIHJldHVybjtcbiAgfVxuICBsZXQgbGF6eVJvdXRlID0gYXdhaXQgcm91dGUubGF6eSgpO1xuICBpZiAoIXJvdXRlLmxhenkpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgbGV0IHJvdXRlVG9VcGRhdGUgPSBtYW5pZmVzdFtyb3V0ZS5pZF07XG4gIGludmFyaWFudChyb3V0ZVRvVXBkYXRlLCBcIk5vIHJvdXRlIGZvdW5kIGluIG1hbmlmZXN0XCIpO1xuICBsZXQgcm91dGVVcGRhdGVzID0ge307XG4gIGZvciAobGV0IGxhenlSb3V0ZVByb3BlcnR5IGluIGxhenlSb3V0ZSkge1xuICAgIGxldCBzdGF0aWNSb3V0ZVZhbHVlID0gcm91dGVUb1VwZGF0ZVtsYXp5Um91dGVQcm9wZXJ0eV07XG4gICAgbGV0IGlzUHJvcGVydHlTdGF0aWNhbGx5RGVmaW5lZCA9IHN0YXRpY1JvdXRlVmFsdWUgIT09IHZvaWQgMCAmJiAvLyBUaGlzIHByb3BlcnR5IGlzbid0IHN0YXRpYyBzaW5jZSBpdCBzaG91bGQgYWx3YXlzIGJlIHVwZGF0ZWQgYmFzZWRcbiAgICAvLyBvbiB0aGUgcm91dGUgdXBkYXRlc1xuICAgIGxhenlSb3V0ZVByb3BlcnR5ICE9PSBcImhhc0Vycm9yQm91bmRhcnlcIjtcbiAgICB3YXJuaW5nKFxuICAgICAgIWlzUHJvcGVydHlTdGF0aWNhbGx5RGVmaW5lZCxcbiAgICAgIGBSb3V0ZSBcIiR7cm91dGVUb1VwZGF0ZS5pZH1cIiBoYXMgYSBzdGF0aWMgcHJvcGVydHkgXCIke2xhenlSb3V0ZVByb3BlcnR5fVwiIGRlZmluZWQgYnV0IGl0cyBsYXp5IGZ1bmN0aW9uIGlzIGFsc28gcmV0dXJuaW5nIGEgdmFsdWUgZm9yIHRoaXMgcHJvcGVydHkuIFRoZSBsYXp5IHJvdXRlIHByb3BlcnR5IFwiJHtsYXp5Um91dGVQcm9wZXJ0eX1cIiB3aWxsIGJlIGlnbm9yZWQuYFxuICAgICk7XG4gICAgaWYgKCFpc1Byb3BlcnR5U3RhdGljYWxseURlZmluZWQgJiYgIWltbXV0YWJsZVJvdXRlS2V5cy5oYXMobGF6eVJvdXRlUHJvcGVydHkpKSB7XG4gICAgICByb3V0ZVVwZGF0ZXNbbGF6eVJvdXRlUHJvcGVydHldID0gbGF6eVJvdXRlW2xhenlSb3V0ZVByb3BlcnR5XTtcbiAgICB9XG4gIH1cbiAgT2JqZWN0LmFzc2lnbihyb3V0ZVRvVXBkYXRlLCByb3V0ZVVwZGF0ZXMpO1xuICBPYmplY3QuYXNzaWduKHJvdXRlVG9VcGRhdGUsIHtcbiAgICAvLyBUbyBrZWVwIHRoaW5ncyBmcmFtZXdvcmsgYWdub3N0aWMsIHdlIHVzZSB0aGUgcHJvdmlkZWQgYG1hcFJvdXRlUHJvcGVydGllc2BcbiAgICAvLyBmdW5jdGlvbiB0byBzZXQgdGhlIGZyYW1ld29yay1hd2FyZSBwcm9wZXJ0aWVzIChgZWxlbWVudGAvYGhhc0Vycm9yQm91bmRhcnlgKVxuICAgIC8vIHNpbmNlIHRoZSBsb2dpYyB3aWxsIGRpZmZlciBiZXR3ZWVuIGZyYW1ld29ya3MuXG4gICAgLi4ubWFwUm91dGVQcm9wZXJ0aWVzMihyb3V0ZVRvVXBkYXRlKSxcbiAgICBsYXp5OiB2b2lkIDBcbiAgfSk7XG59XG5hc3luYyBmdW5jdGlvbiBkZWZhdWx0RGF0YVN0cmF0ZWd5KHtcbiAgbWF0Y2hlc1xufSkge1xuICBsZXQgbWF0Y2hlc1RvTG9hZCA9IG1hdGNoZXMuZmlsdGVyKChtKSA9PiBtLnNob3VsZExvYWQpO1xuICBsZXQgcmVzdWx0cyA9IGF3YWl0IFByb21pc2UuYWxsKG1hdGNoZXNUb0xvYWQubWFwKChtKSA9PiBtLnJlc29sdmUoKSkpO1xuICByZXR1cm4gcmVzdWx0cy5yZWR1Y2UoXG4gICAgKGFjYywgcmVzdWx0LCBpKSA9PiBPYmplY3QuYXNzaWduKGFjYywgeyBbbWF0Y2hlc1RvTG9hZFtpXS5yb3V0ZS5pZF06IHJlc3VsdCB9KSxcbiAgICB7fVxuICApO1xufVxuYXN5bmMgZnVuY3Rpb24gY2FsbERhdGFTdHJhdGVneUltcGwoZGF0YVN0cmF0ZWd5SW1wbCwgdHlwZSwgc3RhdGUsIHJlcXVlc3QsIG1hdGNoZXNUb0xvYWQsIG1hdGNoZXMsIGZldGNoZXJLZXksIG1hbmlmZXN0LCBtYXBSb3V0ZVByb3BlcnRpZXMyLCByZXF1ZXN0Q29udGV4dCkge1xuICBsZXQgbG9hZFJvdXRlRGVmaW5pdGlvbnNQcm9taXNlcyA9IG1hdGNoZXMubWFwKFxuICAgIChtKSA9PiBtLnJvdXRlLmxhenkgPyBsb2FkTGF6eVJvdXRlTW9kdWxlKG0ucm91dGUsIG1hcFJvdXRlUHJvcGVydGllczIsIG1hbmlmZXN0KSA6IHZvaWQgMFxuICApO1xuICBsZXQgZHNNYXRjaGVzID0gbWF0Y2hlcy5tYXAoKG1hdGNoLCBpKSA9PiB7XG4gICAgbGV0IGxvYWRSb3V0ZVByb21pc2UgPSBsb2FkUm91dGVEZWZpbml0aW9uc1Byb21pc2VzW2ldO1xuICAgIGxldCBzaG91bGRMb2FkID0gbWF0Y2hlc1RvTG9hZC5zb21lKChtKSA9PiBtLnJvdXRlLmlkID09PSBtYXRjaC5yb3V0ZS5pZCk7XG4gICAgbGV0IHJlc29sdmUgPSBhc3luYyAoaGFuZGxlck92ZXJyaWRlKSA9PiB7XG4gICAgICBpZiAoaGFuZGxlck92ZXJyaWRlICYmIHJlcXVlc3QubWV0aG9kID09PSBcIkdFVFwiICYmIChtYXRjaC5yb3V0ZS5sYXp5IHx8IG1hdGNoLnJvdXRlLmxvYWRlcikpIHtcbiAgICAgICAgc2hvdWxkTG9hZCA9IHRydWU7XG4gICAgICB9XG4gICAgICByZXR1cm4gc2hvdWxkTG9hZCA/IGNhbGxMb2FkZXJPckFjdGlvbihcbiAgICAgICAgdHlwZSxcbiAgICAgICAgcmVxdWVzdCxcbiAgICAgICAgbWF0Y2gsXG4gICAgICAgIGxvYWRSb3V0ZVByb21pc2UsXG4gICAgICAgIGhhbmRsZXJPdmVycmlkZSxcbiAgICAgICAgcmVxdWVzdENvbnRleHRcbiAgICAgICkgOiBQcm9taXNlLnJlc29sdmUoeyB0eXBlOiBcImRhdGFcIiAvKiBkYXRhICovLCByZXN1bHQ6IHZvaWQgMCB9KTtcbiAgICB9O1xuICAgIHJldHVybiB7XG4gICAgICAuLi5tYXRjaCxcbiAgICAgIHNob3VsZExvYWQsXG4gICAgICByZXNvbHZlXG4gICAgfTtcbiAgfSk7XG4gIGxldCByZXN1bHRzID0gYXdhaXQgZGF0YVN0cmF0ZWd5SW1wbCh7XG4gICAgbWF0Y2hlczogZHNNYXRjaGVzLFxuICAgIHJlcXVlc3QsXG4gICAgcGFyYW1zOiBtYXRjaGVzWzBdLnBhcmFtcyxcbiAgICBmZXRjaGVyS2V5LFxuICAgIGNvbnRleHQ6IHJlcXVlc3RDb250ZXh0XG4gIH0pO1xuICB0cnkge1xuICAgIGF3YWl0IFByb21pc2UuYWxsKGxvYWRSb3V0ZURlZmluaXRpb25zUHJvbWlzZXMpO1xuICB9IGNhdGNoIChlKSB7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdHM7XG59XG5hc3luYyBmdW5jdGlvbiBjYWxsTG9hZGVyT3JBY3Rpb24odHlwZSwgcmVxdWVzdCwgbWF0Y2gsIGxvYWRSb3V0ZVByb21pc2UsIGhhbmRsZXJPdmVycmlkZSwgc3RhdGljQ29udGV4dCkge1xuICBsZXQgcmVzdWx0O1xuICBsZXQgb25SZWplY3Q7XG4gIGxldCBydW5IYW5kbGVyID0gKGhhbmRsZXIpID0+IHtcbiAgICBsZXQgcmVqZWN0O1xuICAgIGxldCBhYm9ydFByb21pc2UgPSBuZXcgUHJvbWlzZSgoXywgcikgPT4gcmVqZWN0ID0gcik7XG4gICAgb25SZWplY3QgPSAoKSA9PiByZWplY3QoKTtcbiAgICByZXF1ZXN0LnNpZ25hbC5hZGRFdmVudExpc3RlbmVyKFwiYWJvcnRcIiwgb25SZWplY3QpO1xuICAgIGxldCBhY3R1YWxIYW5kbGVyID0gKGN0eCkgPT4ge1xuICAgICAgaWYgKHR5cGVvZiBoYW5kbGVyICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KFxuICAgICAgICAgIG5ldyBFcnJvcihcbiAgICAgICAgICAgIGBZb3UgY2Fubm90IGNhbGwgdGhlIGhhbmRsZXIgZm9yIGEgcm91dGUgd2hpY2ggZGVmaW5lcyBhIGJvb2xlYW4gXCIke3R5cGV9XCIgW3JvdXRlSWQ6ICR7bWF0Y2gucm91dGUuaWR9XWBcbiAgICAgICAgICApXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICByZXR1cm4gaGFuZGxlcihcbiAgICAgICAge1xuICAgICAgICAgIHJlcXVlc3QsXG4gICAgICAgICAgcGFyYW1zOiBtYXRjaC5wYXJhbXMsXG4gICAgICAgICAgY29udGV4dDogc3RhdGljQ29udGV4dFxuICAgICAgICB9LFxuICAgICAgICAuLi5jdHggIT09IHZvaWQgMCA/IFtjdHhdIDogW11cbiAgICAgICk7XG4gICAgfTtcbiAgICBsZXQgaGFuZGxlclByb21pc2UgPSAoYXN5bmMgKCkgPT4ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgbGV0IHZhbCA9IGF3YWl0IChoYW5kbGVyT3ZlcnJpZGUgPyBoYW5kbGVyT3ZlcnJpZGUoKGN0eCkgPT4gYWN0dWFsSGFuZGxlcihjdHgpKSA6IGFjdHVhbEhhbmRsZXIoKSk7XG4gICAgICAgIHJldHVybiB7IHR5cGU6IFwiZGF0YVwiLCByZXN1bHQ6IHZhbCB9O1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICByZXR1cm4geyB0eXBlOiBcImVycm9yXCIsIHJlc3VsdDogZSB9O1xuICAgICAgfVxuICAgIH0pKCk7XG4gICAgcmV0dXJuIFByb21pc2UucmFjZShbaGFuZGxlclByb21pc2UsIGFib3J0UHJvbWlzZV0pO1xuICB9O1xuICB0cnkge1xuICAgIGxldCBoYW5kbGVyID0gbWF0Y2gucm91dGVbdHlwZV07XG4gICAgaWYgKGxvYWRSb3V0ZVByb21pc2UpIHtcbiAgICAgIGlmIChoYW5kbGVyKSB7XG4gICAgICAgIGxldCBoYW5kbGVyRXJyb3I7XG4gICAgICAgIGxldCBbdmFsdWVdID0gYXdhaXQgUHJvbWlzZS5hbGwoW1xuICAgICAgICAgIC8vIElmIHRoZSBoYW5kbGVyIHRocm93cywgZG9uJ3QgbGV0IGl0IGltbWVkaWF0ZWx5IGJ1YmJsZSBvdXQsXG4gICAgICAgICAgLy8gc2luY2Ugd2UgbmVlZCB0byBsZXQgdGhlIGxhenkoKSBleGVjdXRpb24gZmluaXNoIHNvIHdlIGtub3cgaWYgdGhpc1xuICAgICAgICAgIC8vIHJvdXRlIGhhcyBhIGJvdW5kYXJ5IHRoYXQgY2FuIGhhbmRsZSB0aGUgZXJyb3JcbiAgICAgICAgICBydW5IYW5kbGVyKGhhbmRsZXIpLmNhdGNoKChlKSA9PiB7XG4gICAgICAgICAgICBoYW5kbGVyRXJyb3IgPSBlO1xuICAgICAgICAgIH0pLFxuICAgICAgICAgIGxvYWRSb3V0ZVByb21pc2VcbiAgICAgICAgXSk7XG4gICAgICAgIGlmIChoYW5kbGVyRXJyb3IgIT09IHZvaWQgMCkge1xuICAgICAgICAgIHRocm93IGhhbmRsZXJFcnJvcjtcbiAgICAgICAgfVxuICAgICAgICByZXN1bHQgPSB2YWx1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGF3YWl0IGxvYWRSb3V0ZVByb21pc2U7XG4gICAgICAgIGhhbmRsZXIgPSBtYXRjaC5yb3V0ZVt0eXBlXTtcbiAgICAgICAgaWYgKGhhbmRsZXIpIHtcbiAgICAgICAgICByZXN1bHQgPSBhd2FpdCBydW5IYW5kbGVyKGhhbmRsZXIpO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGUgPT09IFwiYWN0aW9uXCIpIHtcbiAgICAgICAgICBsZXQgdXJsID0gbmV3IFVSTChyZXF1ZXN0LnVybCk7XG4gICAgICAgICAgbGV0IHBhdGhuYW1lID0gdXJsLnBhdGhuYW1lICsgdXJsLnNlYXJjaDtcbiAgICAgICAgICB0aHJvdyBnZXRJbnRlcm5hbFJvdXRlckVycm9yKDQwNSwge1xuICAgICAgICAgICAgbWV0aG9kOiByZXF1ZXN0Lm1ldGhvZCxcbiAgICAgICAgICAgIHBhdGhuYW1lLFxuICAgICAgICAgICAgcm91dGVJZDogbWF0Y2gucm91dGUuaWRcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4geyB0eXBlOiBcImRhdGFcIiAvKiBkYXRhICovLCByZXN1bHQ6IHZvaWQgMCB9O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICghaGFuZGxlcikge1xuICAgICAgbGV0IHVybCA9IG5ldyBVUkwocmVxdWVzdC51cmwpO1xuICAgICAgbGV0IHBhdGhuYW1lID0gdXJsLnBhdGhuYW1lICsgdXJsLnNlYXJjaDtcbiAgICAgIHRocm93IGdldEludGVybmFsUm91dGVyRXJyb3IoNDA0LCB7XG4gICAgICAgIHBhdGhuYW1lXG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzdWx0ID0gYXdhaXQgcnVuSGFuZGxlcihoYW5kbGVyKTtcbiAgICB9XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4geyB0eXBlOiBcImVycm9yXCIgLyogZXJyb3IgKi8sIHJlc3VsdDogZSB9O1xuICB9IGZpbmFsbHkge1xuICAgIGlmIChvblJlamVjdCkge1xuICAgICAgcmVxdWVzdC5zaWduYWwucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImFib3J0XCIsIG9uUmVqZWN0KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cbmFzeW5jIGZ1bmN0aW9uIGNvbnZlcnREYXRhU3RyYXRlZ3lSZXN1bHRUb0RhdGFSZXN1bHQoZGF0YVN0cmF0ZWd5UmVzdWx0KSB7XG4gIGxldCB7IHJlc3VsdCwgdHlwZSB9ID0gZGF0YVN0cmF0ZWd5UmVzdWx0O1xuICBpZiAoaXNSZXNwb25zZShyZXN1bHQpKSB7XG4gICAgbGV0IGRhdGEyO1xuICAgIHRyeSB7XG4gICAgICBsZXQgY29udGVudFR5cGUgPSByZXN1bHQuaGVhZGVycy5nZXQoXCJDb250ZW50LVR5cGVcIik7XG4gICAgICBpZiAoY29udGVudFR5cGUgJiYgL1xcYmFwcGxpY2F0aW9uXFwvanNvblxcYi8udGVzdChjb250ZW50VHlwZSkpIHtcbiAgICAgICAgaWYgKHJlc3VsdC5ib2R5ID09IG51bGwpIHtcbiAgICAgICAgICBkYXRhMiA9IG51bGw7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZGF0YTIgPSBhd2FpdCByZXN1bHQuanNvbigpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkYXRhMiA9IGF3YWl0IHJlc3VsdC50ZXh0KCk7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgcmV0dXJuIHsgdHlwZTogXCJlcnJvclwiIC8qIGVycm9yICovLCBlcnJvcjogZSB9O1xuICAgIH1cbiAgICBpZiAodHlwZSA9PT0gXCJlcnJvclwiIC8qIGVycm9yICovKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiBcImVycm9yXCIgLyogZXJyb3IgKi8sXG4gICAgICAgIGVycm9yOiBuZXcgRXJyb3JSZXNwb25zZUltcGwocmVzdWx0LnN0YXR1cywgcmVzdWx0LnN0YXR1c1RleHQsIGRhdGEyKSxcbiAgICAgICAgc3RhdHVzQ29kZTogcmVzdWx0LnN0YXR1cyxcbiAgICAgICAgaGVhZGVyczogcmVzdWx0LmhlYWRlcnNcbiAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcImRhdGFcIiAvKiBkYXRhICovLFxuICAgICAgZGF0YTogZGF0YTIsXG4gICAgICBzdGF0dXNDb2RlOiByZXN1bHQuc3RhdHVzLFxuICAgICAgaGVhZGVyczogcmVzdWx0LmhlYWRlcnNcbiAgICB9O1xuICB9XG4gIGlmICh0eXBlID09PSBcImVycm9yXCIgLyogZXJyb3IgKi8pIHtcbiAgICBpZiAoaXNEYXRhV2l0aFJlc3BvbnNlSW5pdChyZXN1bHQpKSB7XG4gICAgICBpZiAocmVzdWx0LmRhdGEgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHR5cGU6IFwiZXJyb3JcIiAvKiBlcnJvciAqLyxcbiAgICAgICAgICBlcnJvcjogcmVzdWx0LmRhdGEsXG4gICAgICAgICAgc3RhdHVzQ29kZTogcmVzdWx0LmluaXQ/LnN0YXR1c1xuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgcmVzdWx0ID0gbmV3IEVycm9yUmVzcG9uc2VJbXBsKFxuICAgICAgICByZXN1bHQuaW5pdD8uc3RhdHVzIHx8IDUwMCxcbiAgICAgICAgdm9pZCAwLFxuICAgICAgICByZXN1bHQuZGF0YVxuICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiZXJyb3JcIiAvKiBlcnJvciAqLyxcbiAgICAgIGVycm9yOiByZXN1bHQsXG4gICAgICBzdGF0dXNDb2RlOiBpc1JvdXRlRXJyb3JSZXNwb25zZShyZXN1bHQpID8gcmVzdWx0LnN0YXR1cyA6IHZvaWQgMFxuICAgIH07XG4gIH1cbiAgaWYgKGlzRGF0YVdpdGhSZXNwb25zZUluaXQocmVzdWx0KSkge1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcImRhdGFcIiAvKiBkYXRhICovLFxuICAgICAgZGF0YTogcmVzdWx0LmRhdGEsXG4gICAgICBzdGF0dXNDb2RlOiByZXN1bHQuaW5pdD8uc3RhdHVzLFxuICAgICAgaGVhZGVyczogcmVzdWx0LmluaXQ/LmhlYWRlcnMgPyBuZXcgSGVhZGVycyhyZXN1bHQuaW5pdC5oZWFkZXJzKSA6IHZvaWQgMFxuICAgIH07XG4gIH1cbiAgcmV0dXJuIHsgdHlwZTogXCJkYXRhXCIgLyogZGF0YSAqLywgZGF0YTogcmVzdWx0IH07XG59XG5mdW5jdGlvbiBub3JtYWxpemVSZWxhdGl2ZVJvdXRpbmdSZWRpcmVjdFJlc3BvbnNlKHJlc3BvbnNlLCByZXF1ZXN0LCByb3V0ZUlkLCBtYXRjaGVzLCBiYXNlbmFtZSkge1xuICBsZXQgbG9jYXRpb24gPSByZXNwb25zZS5oZWFkZXJzLmdldChcIkxvY2F0aW9uXCIpO1xuICBpbnZhcmlhbnQoXG4gICAgbG9jYXRpb24sXG4gICAgXCJSZWRpcmVjdHMgcmV0dXJuZWQvdGhyb3duIGZyb20gbG9hZGVycy9hY3Rpb25zIG11c3QgaGF2ZSBhIExvY2F0aW9uIGhlYWRlclwiXG4gICk7XG4gIGlmICghQUJTT0xVVEVfVVJMX1JFR0VYLnRlc3QobG9jYXRpb24pKSB7XG4gICAgbGV0IHRyaW1tZWRNYXRjaGVzID0gbWF0Y2hlcy5zbGljZShcbiAgICAgIDAsXG4gICAgICBtYXRjaGVzLmZpbmRJbmRleCgobSkgPT4gbS5yb3V0ZS5pZCA9PT0gcm91dGVJZCkgKyAxXG4gICAgKTtcbiAgICBsb2NhdGlvbiA9IG5vcm1hbGl6ZVRvKFxuICAgICAgbmV3IFVSTChyZXF1ZXN0LnVybCksXG4gICAgICB0cmltbWVkTWF0Y2hlcyxcbiAgICAgIGJhc2VuYW1lLFxuICAgICAgbG9jYXRpb25cbiAgICApO1xuICAgIHJlc3BvbnNlLmhlYWRlcnMuc2V0KFwiTG9jYXRpb25cIiwgbG9jYXRpb24pO1xuICB9XG4gIHJldHVybiByZXNwb25zZTtcbn1cbmZ1bmN0aW9uIG5vcm1hbGl6ZVJlZGlyZWN0TG9jYXRpb24obG9jYXRpb24sIGN1cnJlbnRVcmwsIGJhc2VuYW1lKSB7XG4gIGlmIChBQlNPTFVURV9VUkxfUkVHRVgudGVzdChsb2NhdGlvbikpIHtcbiAgICBsZXQgbm9ybWFsaXplZExvY2F0aW9uID0gbG9jYXRpb247XG4gICAgbGV0IHVybCA9IG5vcm1hbGl6ZWRMb2NhdGlvbi5zdGFydHNXaXRoKFwiLy9cIikgPyBuZXcgVVJMKGN1cnJlbnRVcmwucHJvdG9jb2wgKyBub3JtYWxpemVkTG9jYXRpb24pIDogbmV3IFVSTChub3JtYWxpemVkTG9jYXRpb24pO1xuICAgIGxldCBpc1NhbWVCYXNlbmFtZSA9IHN0cmlwQmFzZW5hbWUodXJsLnBhdGhuYW1lLCBiYXNlbmFtZSkgIT0gbnVsbDtcbiAgICBpZiAodXJsLm9yaWdpbiA9PT0gY3VycmVudFVybC5vcmlnaW4gJiYgaXNTYW1lQmFzZW5hbWUpIHtcbiAgICAgIHJldHVybiB1cmwucGF0aG5hbWUgKyB1cmwuc2VhcmNoICsgdXJsLmhhc2g7XG4gICAgfVxuICB9XG4gIHJldHVybiBsb2NhdGlvbjtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUNsaWVudFNpZGVSZXF1ZXN0KGhpc3RvcnksIGxvY2F0aW9uLCBzaWduYWwsIHN1Ym1pc3Npb24pIHtcbiAgbGV0IHVybCA9IGhpc3RvcnkuY3JlYXRlVVJMKHN0cmlwSGFzaEZyb21QYXRoKGxvY2F0aW9uKSkudG9TdHJpbmcoKTtcbiAgbGV0IGluaXQgPSB7IHNpZ25hbCB9O1xuICBpZiAoc3VibWlzc2lvbiAmJiBpc011dGF0aW9uTWV0aG9kKHN1Ym1pc3Npb24uZm9ybU1ldGhvZCkpIHtcbiAgICBsZXQgeyBmb3JtTWV0aG9kLCBmb3JtRW5jVHlwZSB9ID0gc3VibWlzc2lvbjtcbiAgICBpbml0Lm1ldGhvZCA9IGZvcm1NZXRob2QudG9VcHBlckNhc2UoKTtcbiAgICBpZiAoZm9ybUVuY1R5cGUgPT09IFwiYXBwbGljYXRpb24vanNvblwiKSB7XG4gICAgICBpbml0LmhlYWRlcnMgPSBuZXcgSGVhZGVycyh7IFwiQ29udGVudC1UeXBlXCI6IGZvcm1FbmNUeXBlIH0pO1xuICAgICAgaW5pdC5ib2R5ID0gSlNPTi5zdHJpbmdpZnkoc3VibWlzc2lvbi5qc29uKTtcbiAgICB9IGVsc2UgaWYgKGZvcm1FbmNUeXBlID09PSBcInRleHQvcGxhaW5cIikge1xuICAgICAgaW5pdC5ib2R5ID0gc3VibWlzc2lvbi50ZXh0O1xuICAgIH0gZWxzZSBpZiAoZm9ybUVuY1R5cGUgPT09IFwiYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkXCIgJiYgc3VibWlzc2lvbi5mb3JtRGF0YSkge1xuICAgICAgaW5pdC5ib2R5ID0gY29udmVydEZvcm1EYXRhVG9TZWFyY2hQYXJhbXMoc3VibWlzc2lvbi5mb3JtRGF0YSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGluaXQuYm9keSA9IHN1Ym1pc3Npb24uZm9ybURhdGE7XG4gICAgfVxuICB9XG4gIHJldHVybiBuZXcgUmVxdWVzdCh1cmwsIGluaXQpO1xufVxuZnVuY3Rpb24gY29udmVydEZvcm1EYXRhVG9TZWFyY2hQYXJhbXMoZm9ybURhdGEpIHtcbiAgbGV0IHNlYXJjaFBhcmFtcyA9IG5ldyBVUkxTZWFyY2hQYXJhbXMoKTtcbiAgZm9yIChsZXQgW2tleSwgdmFsdWVdIG9mIGZvcm1EYXRhLmVudHJpZXMoKSkge1xuICAgIHNlYXJjaFBhcmFtcy5hcHBlbmQoa2V5LCB0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIgPyB2YWx1ZSA6IHZhbHVlLm5hbWUpO1xuICB9XG4gIHJldHVybiBzZWFyY2hQYXJhbXM7XG59XG5mdW5jdGlvbiBjb252ZXJ0U2VhcmNoUGFyYW1zVG9Gb3JtRGF0YShzZWFyY2hQYXJhbXMpIHtcbiAgbGV0IGZvcm1EYXRhID0gbmV3IEZvcm1EYXRhKCk7XG4gIGZvciAobGV0IFtrZXksIHZhbHVlXSBvZiBzZWFyY2hQYXJhbXMuZW50cmllcygpKSB7XG4gICAgZm9ybURhdGEuYXBwZW5kKGtleSwgdmFsdWUpO1xuICB9XG4gIHJldHVybiBmb3JtRGF0YTtcbn1cbmZ1bmN0aW9uIHByb2Nlc3NSb3V0ZUxvYWRlckRhdGEobWF0Y2hlcywgcmVzdWx0cywgcGVuZGluZ0FjdGlvblJlc3VsdCwgaXNTdGF0aWNIYW5kbGVyID0gZmFsc2UsIHNraXBMb2FkZXJFcnJvckJ1YmJsaW5nID0gZmFsc2UpIHtcbiAgbGV0IGxvYWRlckRhdGEgPSB7fTtcbiAgbGV0IGVycm9ycyA9IG51bGw7XG4gIGxldCBzdGF0dXNDb2RlO1xuICBsZXQgZm91bmRFcnJvciA9IGZhbHNlO1xuICBsZXQgbG9hZGVySGVhZGVycyA9IHt9O1xuICBsZXQgcGVuZGluZ0Vycm9yID0gcGVuZGluZ0FjdGlvblJlc3VsdCAmJiBpc0Vycm9yUmVzdWx0KHBlbmRpbmdBY3Rpb25SZXN1bHRbMV0pID8gcGVuZGluZ0FjdGlvblJlc3VsdFsxXS5lcnJvciA6IHZvaWQgMDtcbiAgbWF0Y2hlcy5mb3JFYWNoKChtYXRjaCkgPT4ge1xuICAgIGlmICghKG1hdGNoLnJvdXRlLmlkIGluIHJlc3VsdHMpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGxldCBpZCA9IG1hdGNoLnJvdXRlLmlkO1xuICAgIGxldCByZXN1bHQgPSByZXN1bHRzW2lkXTtcbiAgICBpbnZhcmlhbnQoXG4gICAgICAhaXNSZWRpcmVjdFJlc3VsdChyZXN1bHQpLFxuICAgICAgXCJDYW5ub3QgaGFuZGxlIHJlZGlyZWN0IHJlc3VsdHMgaW4gcHJvY2Vzc0xvYWRlckRhdGFcIlxuICAgICk7XG4gICAgaWYgKGlzRXJyb3JSZXN1bHQocmVzdWx0KSkge1xuICAgICAgbGV0IGVycm9yID0gcmVzdWx0LmVycm9yO1xuICAgICAgaWYgKHBlbmRpbmdFcnJvciAhPT0gdm9pZCAwKSB7XG4gICAgICAgIGVycm9yID0gcGVuZGluZ0Vycm9yO1xuICAgICAgICBwZW5kaW5nRXJyb3IgPSB2b2lkIDA7XG4gICAgICB9XG4gICAgICBlcnJvcnMgPSBlcnJvcnMgfHwge307XG4gICAgICBpZiAoc2tpcExvYWRlckVycm9yQnViYmxpbmcpIHtcbiAgICAgICAgZXJyb3JzW2lkXSA9IGVycm9yO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGV0IGJvdW5kYXJ5TWF0Y2ggPSBmaW5kTmVhcmVzdEJvdW5kYXJ5KG1hdGNoZXMsIGlkKTtcbiAgICAgICAgaWYgKGVycm9yc1tib3VuZGFyeU1hdGNoLnJvdXRlLmlkXSA9PSBudWxsKSB7XG4gICAgICAgICAgZXJyb3JzW2JvdW5kYXJ5TWF0Y2gucm91dGUuaWRdID0gZXJyb3I7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICghaXNTdGF0aWNIYW5kbGVyKSB7XG4gICAgICAgIGxvYWRlckRhdGFbaWRdID0gUmVzZXRMb2FkZXJEYXRhU3ltYm9sO1xuICAgICAgfVxuICAgICAgaWYgKCFmb3VuZEVycm9yKSB7XG4gICAgICAgIGZvdW5kRXJyb3IgPSB0cnVlO1xuICAgICAgICBzdGF0dXNDb2RlID0gaXNSb3V0ZUVycm9yUmVzcG9uc2UocmVzdWx0LmVycm9yKSA/IHJlc3VsdC5lcnJvci5zdGF0dXMgOiA1MDA7XG4gICAgICB9XG4gICAgICBpZiAocmVzdWx0LmhlYWRlcnMpIHtcbiAgICAgICAgbG9hZGVySGVhZGVyc1tpZF0gPSByZXN1bHQuaGVhZGVycztcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgbG9hZGVyRGF0YVtpZF0gPSByZXN1bHQuZGF0YTtcbiAgICAgIGlmIChyZXN1bHQuc3RhdHVzQ29kZSAmJiByZXN1bHQuc3RhdHVzQ29kZSAhPT0gMjAwICYmICFmb3VuZEVycm9yKSB7XG4gICAgICAgIHN0YXR1c0NvZGUgPSByZXN1bHQuc3RhdHVzQ29kZTtcbiAgICAgIH1cbiAgICAgIGlmIChyZXN1bHQuaGVhZGVycykge1xuICAgICAgICBsb2FkZXJIZWFkZXJzW2lkXSA9IHJlc3VsdC5oZWFkZXJzO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG4gIGlmIChwZW5kaW5nRXJyb3IgIT09IHZvaWQgMCAmJiBwZW5kaW5nQWN0aW9uUmVzdWx0KSB7XG4gICAgZXJyb3JzID0geyBbcGVuZGluZ0FjdGlvblJlc3VsdFswXV06IHBlbmRpbmdFcnJvciB9O1xuICAgIGxvYWRlckRhdGFbcGVuZGluZ0FjdGlvblJlc3VsdFswXV0gPSB2b2lkIDA7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBsb2FkZXJEYXRhLFxuICAgIGVycm9ycyxcbiAgICBzdGF0dXNDb2RlOiBzdGF0dXNDb2RlIHx8IDIwMCxcbiAgICBsb2FkZXJIZWFkZXJzXG4gIH07XG59XG5mdW5jdGlvbiBwcm9jZXNzTG9hZGVyRGF0YShzdGF0ZSwgbWF0Y2hlcywgcmVzdWx0cywgcGVuZGluZ0FjdGlvblJlc3VsdCwgcmV2YWxpZGF0aW5nRmV0Y2hlcnMsIGZldGNoZXJSZXN1bHRzKSB7XG4gIGxldCB7IGxvYWRlckRhdGEsIGVycm9ycyB9ID0gcHJvY2Vzc1JvdXRlTG9hZGVyRGF0YShcbiAgICBtYXRjaGVzLFxuICAgIHJlc3VsdHMsXG4gICAgcGVuZGluZ0FjdGlvblJlc3VsdFxuICApO1xuICByZXZhbGlkYXRpbmdGZXRjaGVycy5mb3JFYWNoKChyZikgPT4ge1xuICAgIGxldCB7IGtleSwgbWF0Y2gsIGNvbnRyb2xsZXIgfSA9IHJmO1xuICAgIGxldCByZXN1bHQgPSBmZXRjaGVyUmVzdWx0c1trZXldO1xuICAgIGludmFyaWFudChyZXN1bHQsIFwiRGlkIG5vdCBmaW5kIGNvcnJlc3BvbmRpbmcgZmV0Y2hlciByZXN1bHRcIik7XG4gICAgaWYgKGNvbnRyb2xsZXIgJiYgY29udHJvbGxlci5zaWduYWwuYWJvcnRlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH0gZWxzZSBpZiAoaXNFcnJvclJlc3VsdChyZXN1bHQpKSB7XG4gICAgICBsZXQgYm91bmRhcnlNYXRjaCA9IGZpbmROZWFyZXN0Qm91bmRhcnkoc3RhdGUubWF0Y2hlcywgbWF0Y2g/LnJvdXRlLmlkKTtcbiAgICAgIGlmICghKGVycm9ycyAmJiBlcnJvcnNbYm91bmRhcnlNYXRjaC5yb3V0ZS5pZF0pKSB7XG4gICAgICAgIGVycm9ycyA9IHtcbiAgICAgICAgICAuLi5lcnJvcnMsXG4gICAgICAgICAgW2JvdW5kYXJ5TWF0Y2gucm91dGUuaWRdOiByZXN1bHQuZXJyb3JcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIHN0YXRlLmZldGNoZXJzLmRlbGV0ZShrZXkpO1xuICAgIH0gZWxzZSBpZiAoaXNSZWRpcmVjdFJlc3VsdChyZXN1bHQpKSB7XG4gICAgICBpbnZhcmlhbnQoZmFsc2UsIFwiVW5oYW5kbGVkIGZldGNoZXIgcmV2YWxpZGF0aW9uIHJlZGlyZWN0XCIpO1xuICAgIH0gZWxzZSB7XG4gICAgICBsZXQgZG9uZUZldGNoZXIgPSBnZXREb25lRmV0Y2hlcihyZXN1bHQuZGF0YSk7XG4gICAgICBzdGF0ZS5mZXRjaGVycy5zZXQoa2V5LCBkb25lRmV0Y2hlcik7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIHsgbG9hZGVyRGF0YSwgZXJyb3JzIH07XG59XG5mdW5jdGlvbiBtZXJnZUxvYWRlckRhdGEobG9hZGVyRGF0YSwgbmV3TG9hZGVyRGF0YSwgbWF0Y2hlcywgZXJyb3JzKSB7XG4gIGxldCBtZXJnZWRMb2FkZXJEYXRhID0gT2JqZWN0LmVudHJpZXMobmV3TG9hZGVyRGF0YSkuZmlsdGVyKChbLCB2XSkgPT4gdiAhPT0gUmVzZXRMb2FkZXJEYXRhU3ltYm9sKS5yZWR1Y2UoKG1lcmdlZCwgW2ssIHZdKSA9PiB7XG4gICAgbWVyZ2VkW2tdID0gdjtcbiAgICByZXR1cm4gbWVyZ2VkO1xuICB9LCB7fSk7XG4gIGZvciAobGV0IG1hdGNoIG9mIG1hdGNoZXMpIHtcbiAgICBsZXQgaWQgPSBtYXRjaC5yb3V0ZS5pZDtcbiAgICBpZiAoIW5ld0xvYWRlckRhdGEuaGFzT3duUHJvcGVydHkoaWQpICYmIGxvYWRlckRhdGEuaGFzT3duUHJvcGVydHkoaWQpICYmIG1hdGNoLnJvdXRlLmxvYWRlcikge1xuICAgICAgbWVyZ2VkTG9hZGVyRGF0YVtpZF0gPSBsb2FkZXJEYXRhW2lkXTtcbiAgICB9XG4gICAgaWYgKGVycm9ycyAmJiBlcnJvcnMuaGFzT3duUHJvcGVydHkoaWQpKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG1lcmdlZExvYWRlckRhdGE7XG59XG5mdW5jdGlvbiBnZXRBY3Rpb25EYXRhRm9yQ29tbWl0KHBlbmRpbmdBY3Rpb25SZXN1bHQpIHtcbiAgaWYgKCFwZW5kaW5nQWN0aW9uUmVzdWx0KSB7XG4gICAgcmV0dXJuIHt9O1xuICB9XG4gIHJldHVybiBpc0Vycm9yUmVzdWx0KHBlbmRpbmdBY3Rpb25SZXN1bHRbMV0pID8ge1xuICAgIC8vIENsZWFyIG91dCBwcmlvciBhY3Rpb25EYXRhIG9uIGVycm9yc1xuICAgIGFjdGlvbkRhdGE6IHt9XG4gIH0gOiB7XG4gICAgYWN0aW9uRGF0YToge1xuICAgICAgW3BlbmRpbmdBY3Rpb25SZXN1bHRbMF1dOiBwZW5kaW5nQWN0aW9uUmVzdWx0WzFdLmRhdGFcbiAgICB9XG4gIH07XG59XG5mdW5jdGlvbiBmaW5kTmVhcmVzdEJvdW5kYXJ5KG1hdGNoZXMsIHJvdXRlSWQpIHtcbiAgbGV0IGVsaWdpYmxlTWF0Y2hlcyA9IHJvdXRlSWQgPyBtYXRjaGVzLnNsaWNlKDAsIG1hdGNoZXMuZmluZEluZGV4KChtKSA9PiBtLnJvdXRlLmlkID09PSByb3V0ZUlkKSArIDEpIDogWy4uLm1hdGNoZXNdO1xuICByZXR1cm4gZWxpZ2libGVNYXRjaGVzLnJldmVyc2UoKS5maW5kKChtKSA9PiBtLnJvdXRlLmhhc0Vycm9yQm91bmRhcnkgPT09IHRydWUpIHx8IG1hdGNoZXNbMF07XG59XG5mdW5jdGlvbiBnZXRTaG9ydENpcmN1aXRNYXRjaGVzKHJvdXRlcykge1xuICBsZXQgcm91dGUgPSByb3V0ZXMubGVuZ3RoID09PSAxID8gcm91dGVzWzBdIDogcm91dGVzLmZpbmQoKHIpID0+IHIuaW5kZXggfHwgIXIucGF0aCB8fCByLnBhdGggPT09IFwiL1wiKSB8fCB7XG4gICAgaWQ6IGBfX3NoaW0tZXJyb3Itcm91dGVfX2BcbiAgfTtcbiAgcmV0dXJuIHtcbiAgICBtYXRjaGVzOiBbXG4gICAgICB7XG4gICAgICAgIHBhcmFtczoge30sXG4gICAgICAgIHBhdGhuYW1lOiBcIlwiLFxuICAgICAgICBwYXRobmFtZUJhc2U6IFwiXCIsXG4gICAgICAgIHJvdXRlXG4gICAgICB9XG4gICAgXSxcbiAgICByb3V0ZVxuICB9O1xufVxuZnVuY3Rpb24gZ2V0SW50ZXJuYWxSb3V0ZXJFcnJvcihzdGF0dXMsIHtcbiAgcGF0aG5hbWUsXG4gIHJvdXRlSWQsXG4gIG1ldGhvZCxcbiAgdHlwZSxcbiAgbWVzc2FnZVxufSA9IHt9KSB7XG4gIGxldCBzdGF0dXNUZXh0ID0gXCJVbmtub3duIFNlcnZlciBFcnJvclwiO1xuICBsZXQgZXJyb3JNZXNzYWdlID0gXCJVbmtub3duIEByZW1peC1ydW4vcm91dGVyIGVycm9yXCI7XG4gIGlmIChzdGF0dXMgPT09IDQwMCkge1xuICAgIHN0YXR1c1RleHQgPSBcIkJhZCBSZXF1ZXN0XCI7XG4gICAgaWYgKG1ldGhvZCAmJiBwYXRobmFtZSAmJiByb3V0ZUlkKSB7XG4gICAgICBlcnJvck1lc3NhZ2UgPSBgWW91IG1hZGUgYSAke21ldGhvZH0gcmVxdWVzdCB0byBcIiR7cGF0aG5hbWV9XCIgYnV0IGRpZCBub3QgcHJvdmlkZSBhIFxcYGxvYWRlclxcYCBmb3Igcm91dGUgXCIke3JvdXRlSWR9XCIsIHNvIHRoZXJlIGlzIG5vIHdheSB0byBoYW5kbGUgdGhlIHJlcXVlc3QuYDtcbiAgICB9IGVsc2UgaWYgKHR5cGUgPT09IFwiaW52YWxpZC1ib2R5XCIpIHtcbiAgICAgIGVycm9yTWVzc2FnZSA9IFwiVW5hYmxlIHRvIGVuY29kZSBzdWJtaXNzaW9uIGJvZHlcIjtcbiAgICB9XG4gIH0gZWxzZSBpZiAoc3RhdHVzID09PSA0MDMpIHtcbiAgICBzdGF0dXNUZXh0ID0gXCJGb3JiaWRkZW5cIjtcbiAgICBlcnJvck1lc3NhZ2UgPSBgUm91dGUgXCIke3JvdXRlSWR9XCIgZG9lcyBub3QgbWF0Y2ggVVJMIFwiJHtwYXRobmFtZX1cImA7XG4gIH0gZWxzZSBpZiAoc3RhdHVzID09PSA0MDQpIHtcbiAgICBzdGF0dXNUZXh0ID0gXCJOb3QgRm91bmRcIjtcbiAgICBlcnJvck1lc3NhZ2UgPSBgTm8gcm91dGUgbWF0Y2hlcyBVUkwgXCIke3BhdGhuYW1lfVwiYDtcbiAgfSBlbHNlIGlmIChzdGF0dXMgPT09IDQwNSkge1xuICAgIHN0YXR1c1RleHQgPSBcIk1ldGhvZCBOb3QgQWxsb3dlZFwiO1xuICAgIGlmIChtZXRob2QgJiYgcGF0aG5hbWUgJiYgcm91dGVJZCkge1xuICAgICAgZXJyb3JNZXNzYWdlID0gYFlvdSBtYWRlIGEgJHttZXRob2QudG9VcHBlckNhc2UoKX0gcmVxdWVzdCB0byBcIiR7cGF0aG5hbWV9XCIgYnV0IGRpZCBub3QgcHJvdmlkZSBhbiBcXGBhY3Rpb25cXGAgZm9yIHJvdXRlIFwiJHtyb3V0ZUlkfVwiLCBzbyB0aGVyZSBpcyBubyB3YXkgdG8gaGFuZGxlIHRoZSByZXF1ZXN0LmA7XG4gICAgfSBlbHNlIGlmIChtZXRob2QpIHtcbiAgICAgIGVycm9yTWVzc2FnZSA9IGBJbnZhbGlkIHJlcXVlc3QgbWV0aG9kIFwiJHttZXRob2QudG9VcHBlckNhc2UoKX1cImA7XG4gICAgfVxuICB9XG4gIHJldHVybiBuZXcgRXJyb3JSZXNwb25zZUltcGwoXG4gICAgc3RhdHVzIHx8IDUwMCxcbiAgICBzdGF0dXNUZXh0LFxuICAgIG5ldyBFcnJvcihlcnJvck1lc3NhZ2UpLFxuICAgIHRydWVcbiAgKTtcbn1cbmZ1bmN0aW9uIGZpbmRSZWRpcmVjdChyZXN1bHRzKSB7XG4gIGxldCBlbnRyaWVzID0gT2JqZWN0LmVudHJpZXMocmVzdWx0cyk7XG4gIGZvciAobGV0IGkgPSBlbnRyaWVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgbGV0IFtrZXksIHJlc3VsdF0gPSBlbnRyaWVzW2ldO1xuICAgIGlmIChpc1JlZGlyZWN0UmVzdWx0KHJlc3VsdCkpIHtcbiAgICAgIHJldHVybiB7IGtleSwgcmVzdWx0IH07XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBzdHJpcEhhc2hGcm9tUGF0aChwYXRoKSB7XG4gIGxldCBwYXJzZWRQYXRoID0gdHlwZW9mIHBhdGggPT09IFwic3RyaW5nXCIgPyBwYXJzZVBhdGgocGF0aCkgOiBwYXRoO1xuICByZXR1cm4gY3JlYXRlUGF0aCh7IC4uLnBhcnNlZFBhdGgsIGhhc2g6IFwiXCIgfSk7XG59XG5mdW5jdGlvbiBpc0hhc2hDaGFuZ2VPbmx5KGEsIGIpIHtcbiAgaWYgKGEucGF0aG5hbWUgIT09IGIucGF0aG5hbWUgfHwgYS5zZWFyY2ggIT09IGIuc2VhcmNoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmIChhLmhhc2ggPT09IFwiXCIpIHtcbiAgICByZXR1cm4gYi5oYXNoICE9PSBcIlwiO1xuICB9IGVsc2UgaWYgKGEuaGFzaCA9PT0gYi5oYXNoKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0gZWxzZSBpZiAoYi5oYXNoICE9PSBcIlwiKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gaXNEYXRhU3RyYXRlZ3lSZXN1bHQocmVzdWx0KSB7XG4gIHJldHVybiByZXN1bHQgIT0gbnVsbCAmJiB0eXBlb2YgcmVzdWx0ID09PSBcIm9iamVjdFwiICYmIFwidHlwZVwiIGluIHJlc3VsdCAmJiBcInJlc3VsdFwiIGluIHJlc3VsdCAmJiAocmVzdWx0LnR5cGUgPT09IFwiZGF0YVwiIC8qIGRhdGEgKi8gfHwgcmVzdWx0LnR5cGUgPT09IFwiZXJyb3JcIiAvKiBlcnJvciAqLyk7XG59XG5mdW5jdGlvbiBpc1JlZGlyZWN0RGF0YVN0cmF0ZWd5UmVzdWx0KHJlc3VsdCkge1xuICByZXR1cm4gaXNSZXNwb25zZShyZXN1bHQucmVzdWx0KSAmJiByZWRpcmVjdFN0YXR1c0NvZGVzLmhhcyhyZXN1bHQucmVzdWx0LnN0YXR1cyk7XG59XG5mdW5jdGlvbiBpc0Vycm9yUmVzdWx0KHJlc3VsdCkge1xuICByZXR1cm4gcmVzdWx0LnR5cGUgPT09IFwiZXJyb3JcIiAvKiBlcnJvciAqLztcbn1cbmZ1bmN0aW9uIGlzUmVkaXJlY3RSZXN1bHQocmVzdWx0KSB7XG4gIHJldHVybiAocmVzdWx0ICYmIHJlc3VsdC50eXBlKSA9PT0gXCJyZWRpcmVjdFwiIC8qIHJlZGlyZWN0ICovO1xufVxuZnVuY3Rpb24gaXNEYXRhV2l0aFJlc3BvbnNlSW5pdCh2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSBcIm9iamVjdFwiICYmIHZhbHVlICE9IG51bGwgJiYgXCJ0eXBlXCIgaW4gdmFsdWUgJiYgXCJkYXRhXCIgaW4gdmFsdWUgJiYgXCJpbml0XCIgaW4gdmFsdWUgJiYgdmFsdWUudHlwZSA9PT0gXCJEYXRhV2l0aFJlc3BvbnNlSW5pdFwiO1xufVxuZnVuY3Rpb24gaXNSZXNwb25zZSh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgIT0gbnVsbCAmJiB0eXBlb2YgdmFsdWUuc3RhdHVzID09PSBcIm51bWJlclwiICYmIHR5cGVvZiB2YWx1ZS5zdGF0dXNUZXh0ID09PSBcInN0cmluZ1wiICYmIHR5cGVvZiB2YWx1ZS5oZWFkZXJzID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiB2YWx1ZS5ib2R5ICE9PSBcInVuZGVmaW5lZFwiO1xufVxuZnVuY3Rpb24gaXNSZWRpcmVjdFN0YXR1c0NvZGUoc3RhdHVzQ29kZSkge1xuICByZXR1cm4gcmVkaXJlY3RTdGF0dXNDb2Rlcy5oYXMoc3RhdHVzQ29kZSk7XG59XG5mdW5jdGlvbiBpc1JlZGlyZWN0UmVzcG9uc2UocmVzdWx0KSB7XG4gIHJldHVybiBpc1Jlc3BvbnNlKHJlc3VsdCkgJiYgaXNSZWRpcmVjdFN0YXR1c0NvZGUocmVzdWx0LnN0YXR1cykgJiYgcmVzdWx0LmhlYWRlcnMuaGFzKFwiTG9jYXRpb25cIik7XG59XG5mdW5jdGlvbiBpc1ZhbGlkTWV0aG9kKG1ldGhvZCkge1xuICByZXR1cm4gdmFsaWRSZXF1ZXN0TWV0aG9kcy5oYXMobWV0aG9kLnRvVXBwZXJDYXNlKCkpO1xufVxuZnVuY3Rpb24gaXNNdXRhdGlvbk1ldGhvZChtZXRob2QpIHtcbiAgcmV0dXJuIHZhbGlkTXV0YXRpb25NZXRob2RzLmhhcyhtZXRob2QudG9VcHBlckNhc2UoKSk7XG59XG5mdW5jdGlvbiBoYXNOYWtlZEluZGV4UXVlcnkoc2VhcmNoKSB7XG4gIHJldHVybiBuZXcgVVJMU2VhcmNoUGFyYW1zKHNlYXJjaCkuZ2V0QWxsKFwiaW5kZXhcIikuc29tZSgodikgPT4gdiA9PT0gXCJcIik7XG59XG5mdW5jdGlvbiBnZXRUYXJnZXRNYXRjaChtYXRjaGVzLCBsb2NhdGlvbikge1xuICBsZXQgc2VhcmNoID0gdHlwZW9mIGxvY2F0aW9uID09PSBcInN0cmluZ1wiID8gcGFyc2VQYXRoKGxvY2F0aW9uKS5zZWFyY2ggOiBsb2NhdGlvbi5zZWFyY2g7XG4gIGlmIChtYXRjaGVzW21hdGNoZXMubGVuZ3RoIC0gMV0ucm91dGUuaW5kZXggJiYgaGFzTmFrZWRJbmRleFF1ZXJ5KHNlYXJjaCB8fCBcIlwiKSkge1xuICAgIHJldHVybiBtYXRjaGVzW21hdGNoZXMubGVuZ3RoIC0gMV07XG4gIH1cbiAgbGV0IHBhdGhNYXRjaGVzID0gZ2V0UGF0aENvbnRyaWJ1dGluZ01hdGNoZXMobWF0Y2hlcyk7XG4gIHJldHVybiBwYXRoTWF0Y2hlc1twYXRoTWF0Y2hlcy5sZW5ndGggLSAxXTtcbn1cbmZ1bmN0aW9uIGdldFN1Ym1pc3Npb25Gcm9tTmF2aWdhdGlvbihuYXZpZ2F0aW9uKSB7XG4gIGxldCB7IGZvcm1NZXRob2QsIGZvcm1BY3Rpb24sIGZvcm1FbmNUeXBlLCB0ZXh0LCBmb3JtRGF0YSwganNvbiB9ID0gbmF2aWdhdGlvbjtcbiAgaWYgKCFmb3JtTWV0aG9kIHx8ICFmb3JtQWN0aW9uIHx8ICFmb3JtRW5jVHlwZSkge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAodGV4dCAhPSBudWxsKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGZvcm1NZXRob2QsXG4gICAgICBmb3JtQWN0aW9uLFxuICAgICAgZm9ybUVuY1R5cGUsXG4gICAgICBmb3JtRGF0YTogdm9pZCAwLFxuICAgICAganNvbjogdm9pZCAwLFxuICAgICAgdGV4dFxuICAgIH07XG4gIH0gZWxzZSBpZiAoZm9ybURhdGEgIT0gbnVsbCkge1xuICAgIHJldHVybiB7XG4gICAgICBmb3JtTWV0aG9kLFxuICAgICAgZm9ybUFjdGlvbixcbiAgICAgIGZvcm1FbmNUeXBlLFxuICAgICAgZm9ybURhdGEsXG4gICAgICBqc29uOiB2b2lkIDAsXG4gICAgICB0ZXh0OiB2b2lkIDBcbiAgICB9O1xuICB9IGVsc2UgaWYgKGpzb24gIT09IHZvaWQgMCkge1xuICAgIHJldHVybiB7XG4gICAgICBmb3JtTWV0aG9kLFxuICAgICAgZm9ybUFjdGlvbixcbiAgICAgIGZvcm1FbmNUeXBlLFxuICAgICAgZm9ybURhdGE6IHZvaWQgMCxcbiAgICAgIGpzb24sXG4gICAgICB0ZXh0OiB2b2lkIDBcbiAgICB9O1xuICB9XG59XG5mdW5jdGlvbiBnZXRMb2FkaW5nTmF2aWdhdGlvbihsb2NhdGlvbiwgc3VibWlzc2lvbikge1xuICBpZiAoc3VibWlzc2lvbikge1xuICAgIGxldCBuYXZpZ2F0aW9uID0ge1xuICAgICAgc3RhdGU6IFwibG9hZGluZ1wiLFxuICAgICAgbG9jYXRpb24sXG4gICAgICBmb3JtTWV0aG9kOiBzdWJtaXNzaW9uLmZvcm1NZXRob2QsXG4gICAgICBmb3JtQWN0aW9uOiBzdWJtaXNzaW9uLmZvcm1BY3Rpb24sXG4gICAgICBmb3JtRW5jVHlwZTogc3VibWlzc2lvbi5mb3JtRW5jVHlwZSxcbiAgICAgIGZvcm1EYXRhOiBzdWJtaXNzaW9uLmZvcm1EYXRhLFxuICAgICAganNvbjogc3VibWlzc2lvbi5qc29uLFxuICAgICAgdGV4dDogc3VibWlzc2lvbi50ZXh0XG4gICAgfTtcbiAgICByZXR1cm4gbmF2aWdhdGlvbjtcbiAgfSBlbHNlIHtcbiAgICBsZXQgbmF2aWdhdGlvbiA9IHtcbiAgICAgIHN0YXRlOiBcImxvYWRpbmdcIixcbiAgICAgIGxvY2F0aW9uLFxuICAgICAgZm9ybU1ldGhvZDogdm9pZCAwLFxuICAgICAgZm9ybUFjdGlvbjogdm9pZCAwLFxuICAgICAgZm9ybUVuY1R5cGU6IHZvaWQgMCxcbiAgICAgIGZvcm1EYXRhOiB2b2lkIDAsXG4gICAgICBqc29uOiB2b2lkIDAsXG4gICAgICB0ZXh0OiB2b2lkIDBcbiAgICB9O1xuICAgIHJldHVybiBuYXZpZ2F0aW9uO1xuICB9XG59XG5mdW5jdGlvbiBnZXRTdWJtaXR0aW5nTmF2aWdhdGlvbihsb2NhdGlvbiwgc3VibWlzc2lvbikge1xuICBsZXQgbmF2aWdhdGlvbiA9IHtcbiAgICBzdGF0ZTogXCJzdWJtaXR0aW5nXCIsXG4gICAgbG9jYXRpb24sXG4gICAgZm9ybU1ldGhvZDogc3VibWlzc2lvbi5mb3JtTWV0aG9kLFxuICAgIGZvcm1BY3Rpb246IHN1Ym1pc3Npb24uZm9ybUFjdGlvbixcbiAgICBmb3JtRW5jVHlwZTogc3VibWlzc2lvbi5mb3JtRW5jVHlwZSxcbiAgICBmb3JtRGF0YTogc3VibWlzc2lvbi5mb3JtRGF0YSxcbiAgICBqc29uOiBzdWJtaXNzaW9uLmpzb24sXG4gICAgdGV4dDogc3VibWlzc2lvbi50ZXh0XG4gIH07XG4gIHJldHVybiBuYXZpZ2F0aW9uO1xufVxuZnVuY3Rpb24gZ2V0TG9hZGluZ0ZldGNoZXIoc3VibWlzc2lvbiwgZGF0YTIpIHtcbiAgaWYgKHN1Ym1pc3Npb24pIHtcbiAgICBsZXQgZmV0Y2hlciA9IHtcbiAgICAgIHN0YXRlOiBcImxvYWRpbmdcIixcbiAgICAgIGZvcm1NZXRob2Q6IHN1Ym1pc3Npb24uZm9ybU1ldGhvZCxcbiAgICAgIGZvcm1BY3Rpb246IHN1Ym1pc3Npb24uZm9ybUFjdGlvbixcbiAgICAgIGZvcm1FbmNUeXBlOiBzdWJtaXNzaW9uLmZvcm1FbmNUeXBlLFxuICAgICAgZm9ybURhdGE6IHN1Ym1pc3Npb24uZm9ybURhdGEsXG4gICAgICBqc29uOiBzdWJtaXNzaW9uLmpzb24sXG4gICAgICB0ZXh0OiBzdWJtaXNzaW9uLnRleHQsXG4gICAgICBkYXRhOiBkYXRhMlxuICAgIH07XG4gICAgcmV0dXJuIGZldGNoZXI7XG4gIH0gZWxzZSB7XG4gICAgbGV0IGZldGNoZXIgPSB7XG4gICAgICBzdGF0ZTogXCJsb2FkaW5nXCIsXG4gICAgICBmb3JtTWV0aG9kOiB2b2lkIDAsXG4gICAgICBmb3JtQWN0aW9uOiB2b2lkIDAsXG4gICAgICBmb3JtRW5jVHlwZTogdm9pZCAwLFxuICAgICAgZm9ybURhdGE6IHZvaWQgMCxcbiAgICAgIGpzb246IHZvaWQgMCxcbiAgICAgIHRleHQ6IHZvaWQgMCxcbiAgICAgIGRhdGE6IGRhdGEyXG4gICAgfTtcbiAgICByZXR1cm4gZmV0Y2hlcjtcbiAgfVxufVxuZnVuY3Rpb24gZ2V0U3VibWl0dGluZ0ZldGNoZXIoc3VibWlzc2lvbiwgZXhpc3RpbmdGZXRjaGVyKSB7XG4gIGxldCBmZXRjaGVyID0ge1xuICAgIHN0YXRlOiBcInN1Ym1pdHRpbmdcIixcbiAgICBmb3JtTWV0aG9kOiBzdWJtaXNzaW9uLmZvcm1NZXRob2QsXG4gICAgZm9ybUFjdGlvbjogc3VibWlzc2lvbi5mb3JtQWN0aW9uLFxuICAgIGZvcm1FbmNUeXBlOiBzdWJtaXNzaW9uLmZvcm1FbmNUeXBlLFxuICAgIGZvcm1EYXRhOiBzdWJtaXNzaW9uLmZvcm1EYXRhLFxuICAgIGpzb246IHN1Ym1pc3Npb24uanNvbixcbiAgICB0ZXh0OiBzdWJtaXNzaW9uLnRleHQsXG4gICAgZGF0YTogZXhpc3RpbmdGZXRjaGVyID8gZXhpc3RpbmdGZXRjaGVyLmRhdGEgOiB2b2lkIDBcbiAgfTtcbiAgcmV0dXJuIGZldGNoZXI7XG59XG5mdW5jdGlvbiBnZXREb25lRmV0Y2hlcihkYXRhMikge1xuICBsZXQgZmV0Y2hlciA9IHtcbiAgICBzdGF0ZTogXCJpZGxlXCIsXG4gICAgZm9ybU1ldGhvZDogdm9pZCAwLFxuICAgIGZvcm1BY3Rpb246IHZvaWQgMCxcbiAgICBmb3JtRW5jVHlwZTogdm9pZCAwLFxuICAgIGZvcm1EYXRhOiB2b2lkIDAsXG4gICAganNvbjogdm9pZCAwLFxuICAgIHRleHQ6IHZvaWQgMCxcbiAgICBkYXRhOiBkYXRhMlxuICB9O1xuICByZXR1cm4gZmV0Y2hlcjtcbn1cbmZ1bmN0aW9uIHJlc3RvcmVBcHBsaWVkVHJhbnNpdGlvbnMoX3dpbmRvdywgdHJhbnNpdGlvbnMpIHtcbiAgdHJ5IHtcbiAgICBsZXQgc2Vzc2lvblBvc2l0aW9ucyA9IF93aW5kb3cuc2Vzc2lvblN0b3JhZ2UuZ2V0SXRlbShcbiAgICAgIFRSQU5TSVRJT05TX1NUT1JBR0VfS0VZXG4gICAgKTtcbiAgICBpZiAoc2Vzc2lvblBvc2l0aW9ucykge1xuICAgICAgbGV0IGpzb24gPSBKU09OLnBhcnNlKHNlc3Npb25Qb3NpdGlvbnMpO1xuICAgICAgZm9yIChsZXQgW2ssIHZdIG9mIE9iamVjdC5lbnRyaWVzKGpzb24gfHwge30pKSB7XG4gICAgICAgIGlmICh2ICYmIEFycmF5LmlzQXJyYXkodikpIHtcbiAgICAgICAgICB0cmFuc2l0aW9ucy5zZXQoaywgbmV3IFNldCh2IHx8IFtdKSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0gY2F0Y2ggKGUpIHtcbiAgfVxufVxuZnVuY3Rpb24gcGVyc2lzdEFwcGxpZWRUcmFuc2l0aW9ucyhfd2luZG93LCB0cmFuc2l0aW9ucykge1xuICBpZiAodHJhbnNpdGlvbnMuc2l6ZSA+IDApIHtcbiAgICBsZXQganNvbiA9IHt9O1xuICAgIGZvciAobGV0IFtrLCB2XSBvZiB0cmFuc2l0aW9ucykge1xuICAgICAganNvbltrXSA9IFsuLi52XTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIF93aW5kb3cuc2Vzc2lvblN0b3JhZ2Uuc2V0SXRlbShcbiAgICAgICAgVFJBTlNJVElPTlNfU1RPUkFHRV9LRVksXG4gICAgICAgIEpTT04uc3RyaW5naWZ5KGpzb24pXG4gICAgICApO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICB3YXJuaW5nKFxuICAgICAgICBmYWxzZSxcbiAgICAgICAgYEZhaWxlZCB0byBzYXZlIGFwcGxpZWQgdmlldyB0cmFuc2l0aW9ucyBpbiBzZXNzaW9uU3RvcmFnZSAoJHtlcnJvcn0pLmBcbiAgICAgICk7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBjcmVhdGVEZWZlcnJlZCgpIHtcbiAgbGV0IHJlc29sdmU7XG4gIGxldCByZWplY3Q7XG4gIGxldCBwcm9taXNlID0gbmV3IFByb21pc2UoKHJlcywgcmVqKSA9PiB7XG4gICAgcmVzb2x2ZSA9IGFzeW5jICh2YWwpID0+IHtcbiAgICAgIHJlcyh2YWwpO1xuICAgICAgdHJ5IHtcbiAgICAgICAgYXdhaXQgcHJvbWlzZTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIH1cbiAgICB9O1xuICAgIHJlamVjdCA9IGFzeW5jIChlcnJvcikgPT4ge1xuICAgICAgcmVqKGVycm9yKTtcbiAgICAgIHRyeSB7XG4gICAgICAgIGF3YWl0IHByb21pc2U7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICB9XG4gICAgfTtcbiAgfSk7XG4gIHJldHVybiB7XG4gICAgcHJvbWlzZSxcbiAgICAvL0B0cy1pZ25vcmVcbiAgICByZXNvbHZlLFxuICAgIC8vQHRzLWlnbm9yZVxuICAgIHJlamVjdFxuICB9O1xufVxuXG4vLyBsaWIvY29tcG9uZW50cy50c3hcbnZhciBSZWFjdDMgPSBfX3RvRVNNKHJlcXVpcmUoXCJyZWFjdFwiKSk7XG5cbi8vIGxpYi9jb250ZXh0LnRzXG52YXIgUmVhY3QgPSBfX3RvRVNNKHJlcXVpcmUoXCJyZWFjdFwiKSk7XG52YXIgRGF0YVJvdXRlckNvbnRleHQgPSBSZWFjdC5jcmVhdGVDb250ZXh0KG51bGwpO1xuRGF0YVJvdXRlckNvbnRleHQuZGlzcGxheU5hbWUgPSBcIkRhdGFSb3V0ZXJcIjtcbnZhciBEYXRhUm91dGVyU3RhdGVDb250ZXh0ID0gUmVhY3QuY3JlYXRlQ29udGV4dChudWxsKTtcbkRhdGFSb3V0ZXJTdGF0ZUNvbnRleHQuZGlzcGxheU5hbWUgPSBcIkRhdGFSb3V0ZXJTdGF0ZVwiO1xudmFyIFZpZXdUcmFuc2l0aW9uQ29udGV4dCA9IFJlYWN0LmNyZWF0ZUNvbnRleHQoe1xuICBpc1RyYW5zaXRpb25pbmc6IGZhbHNlXG59KTtcblZpZXdUcmFuc2l0aW9uQ29udGV4dC5kaXNwbGF5TmFtZSA9IFwiVmlld1RyYW5zaXRpb25cIjtcbnZhciBGZXRjaGVyc0NvbnRleHQgPSBSZWFjdC5jcmVhdGVDb250ZXh0KFxuICAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpXG4pO1xuRmV0Y2hlcnNDb250ZXh0LmRpc3BsYXlOYW1lID0gXCJGZXRjaGVyc1wiO1xudmFyIEF3YWl0Q29udGV4dCA9IFJlYWN0LmNyZWF0ZUNvbnRleHQobnVsbCk7XG5Bd2FpdENvbnRleHQuZGlzcGxheU5hbWUgPSBcIkF3YWl0XCI7XG52YXIgTmF2aWdhdGlvbkNvbnRleHQgPSBSZWFjdC5jcmVhdGVDb250ZXh0KFxuICBudWxsXG4pO1xuTmF2aWdhdGlvbkNvbnRleHQuZGlzcGxheU5hbWUgPSBcIk5hdmlnYXRpb25cIjtcbnZhciBMb2NhdGlvbkNvbnRleHQgPSBSZWFjdC5jcmVhdGVDb250ZXh0KFxuICBudWxsXG4pO1xuTG9jYXRpb25Db250ZXh0LmRpc3BsYXlOYW1lID0gXCJMb2NhdGlvblwiO1xudmFyIFJvdXRlQ29udGV4dCA9IFJlYWN0LmNyZWF0ZUNvbnRleHQoe1xuICBvdXRsZXQ6IG51bGwsXG4gIG1hdGNoZXM6IFtdLFxuICBpc0RhdGFSb3V0ZTogZmFsc2Vcbn0pO1xuUm91dGVDb250ZXh0LmRpc3BsYXlOYW1lID0gXCJSb3V0ZVwiO1xudmFyIFJvdXRlRXJyb3JDb250ZXh0ID0gUmVhY3QuY3JlYXRlQ29udGV4dChudWxsKTtcblJvdXRlRXJyb3JDb250ZXh0LmRpc3BsYXlOYW1lID0gXCJSb3V0ZUVycm9yXCI7XG5cbi8vIGxpYi9ob29rcy50c3hcbnZhciBSZWFjdDIgPSBfX3RvRVNNKHJlcXVpcmUoXCJyZWFjdFwiKSk7XG52YXIgRU5BQkxFX0RFVl9XQVJOSU5HUyA9IHRydWU7XG5mdW5jdGlvbiB1c2VIcmVmKHRvLCB7IHJlbGF0aXZlIH0gPSB7fSkge1xuICBpbnZhcmlhbnQoXG4gICAgdXNlSW5Sb3V0ZXJDb250ZXh0KCksXG4gICAgLy8gVE9ETzogVGhpcyBlcnJvciBpcyBwcm9iYWJseSBiZWNhdXNlIHRoZXkgc29tZWhvdyBoYXZlIDIgdmVyc2lvbnMgb2YgdGhlXG4gICAgLy8gcm91dGVyIGxvYWRlZC4gV2UgY2FuIGhlbHAgdGhlbSB1bmRlcnN0YW5kIGhvdyB0byBhdm9pZCB0aGF0LlxuICAgIGB1c2VIcmVmKCkgbWF5IGJlIHVzZWQgb25seSBpbiB0aGUgY29udGV4dCBvZiBhIDxSb3V0ZXI+IGNvbXBvbmVudC5gXG4gICk7XG4gIGxldCB7IGJhc2VuYW1lLCBuYXZpZ2F0b3I6IG5hdmlnYXRvcjIgfSA9IFJlYWN0Mi51c2VDb250ZXh0KE5hdmlnYXRpb25Db250ZXh0KTtcbiAgbGV0IHsgaGFzaCwgcGF0aG5hbWUsIHNlYXJjaCB9ID0gdXNlUmVzb2x2ZWRQYXRoKHRvLCB7IHJlbGF0aXZlIH0pO1xuICBsZXQgam9pbmVkUGF0aG5hbWUgPSBwYXRobmFtZTtcbiAgaWYgKGJhc2VuYW1lICE9PSBcIi9cIikge1xuICAgIGpvaW5lZFBhdGhuYW1lID0gcGF0aG5hbWUgPT09IFwiL1wiID8gYmFzZW5hbWUgOiBqb2luUGF0aHMoW2Jhc2VuYW1lLCBwYXRobmFtZV0pO1xuICB9XG4gIHJldHVybiBuYXZpZ2F0b3IyLmNyZWF0ZUhyZWYoeyBwYXRobmFtZTogam9pbmVkUGF0aG5hbWUsIHNlYXJjaCwgaGFzaCB9KTtcbn1cbmZ1bmN0aW9uIHVzZUluUm91dGVyQ29udGV4dCgpIHtcbiAgcmV0dXJuIFJlYWN0Mi51c2VDb250ZXh0KExvY2F0aW9uQ29udGV4dCkgIT0gbnVsbDtcbn1cbmZ1bmN0aW9uIHVzZUxvY2F0aW9uKCkge1xuICBpbnZhcmlhbnQoXG4gICAgdXNlSW5Sb3V0ZXJDb250ZXh0KCksXG4gICAgLy8gVE9ETzogVGhpcyBlcnJvciBpcyBwcm9iYWJseSBiZWNhdXNlIHRoZXkgc29tZWhvdyBoYXZlIDIgdmVyc2lvbnMgb2YgdGhlXG4gICAgLy8gcm91dGVyIGxvYWRlZC4gV2UgY2FuIGhlbHAgdGhlbSB1bmRlcnN0YW5kIGhvdyB0byBhdm9pZCB0aGF0LlxuICAgIGB1c2VMb2NhdGlvbigpIG1heSBiZSB1c2VkIG9ubHkgaW4gdGhlIGNvbnRleHQgb2YgYSA8Um91dGVyPiBjb21wb25lbnQuYFxuICApO1xuICByZXR1cm4gUmVhY3QyLnVzZUNvbnRleHQoTG9jYXRpb25Db250ZXh0KS5sb2NhdGlvbjtcbn1cbmZ1bmN0aW9uIHVzZU5hdmlnYXRpb25UeXBlKCkge1xuICByZXR1cm4gUmVhY3QyLnVzZUNvbnRleHQoTG9jYXRpb25Db250ZXh0KS5uYXZpZ2F0aW9uVHlwZTtcbn1cbmZ1bmN0aW9uIHVzZU1hdGNoKHBhdHRlcm4pIHtcbiAgaW52YXJpYW50KFxuICAgIHVzZUluUm91dGVyQ29udGV4dCgpLFxuICAgIC8vIFRPRE86IFRoaXMgZXJyb3IgaXMgcHJvYmFibHkgYmVjYXVzZSB0aGV5IHNvbWVob3cgaGF2ZSAyIHZlcnNpb25zIG9mIHRoZVxuICAgIC8vIHJvdXRlciBsb2FkZWQuIFdlIGNhbiBoZWxwIHRoZW0gdW5kZXJzdGFuZCBob3cgdG8gYXZvaWQgdGhhdC5cbiAgICBgdXNlTWF0Y2goKSBtYXkgYmUgdXNlZCBvbmx5IGluIHRoZSBjb250ZXh0IG9mIGEgPFJvdXRlcj4gY29tcG9uZW50LmBcbiAgKTtcbiAgbGV0IHsgcGF0aG5hbWUgfSA9IHVzZUxvY2F0aW9uKCk7XG4gIHJldHVybiBSZWFjdDIudXNlTWVtbyhcbiAgICAoKSA9PiBtYXRjaFBhdGgocGF0dGVybiwgZGVjb2RlUGF0aChwYXRobmFtZSkpLFxuICAgIFtwYXRobmFtZSwgcGF0dGVybl1cbiAgKTtcbn1cbnZhciBuYXZpZ2F0ZUVmZmVjdFdhcm5pbmcgPSBgWW91IHNob3VsZCBjYWxsIG5hdmlnYXRlKCkgaW4gYSBSZWFjdC51c2VFZmZlY3QoKSwgbm90IHdoZW4geW91ciBjb21wb25lbnQgaXMgZmlyc3QgcmVuZGVyZWQuYDtcbmZ1bmN0aW9uIHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QoY2IpIHtcbiAgbGV0IGlzU3RhdGljID0gUmVhY3QyLnVzZUNvbnRleHQoTmF2aWdhdGlvbkNvbnRleHQpLnN0YXRpYztcbiAgaWYgKCFpc1N0YXRpYykge1xuICAgIFJlYWN0Mi51c2VMYXlvdXRFZmZlY3QoY2IpO1xuICB9XG59XG5mdW5jdGlvbiB1c2VOYXZpZ2F0ZSgpIHtcbiAgbGV0IHsgaXNEYXRhUm91dGUgfSA9IFJlYWN0Mi51c2VDb250ZXh0KFJvdXRlQ29udGV4dCk7XG4gIHJldHVybiBpc0RhdGFSb3V0ZSA/IHVzZU5hdmlnYXRlU3RhYmxlKCkgOiB1c2VOYXZpZ2F0ZVVuc3RhYmxlKCk7XG59XG5mdW5jdGlvbiB1c2VOYXZpZ2F0ZVVuc3RhYmxlKCkge1xuICBpbnZhcmlhbnQoXG4gICAgdXNlSW5Sb3V0ZXJDb250ZXh0KCksXG4gICAgLy8gVE9ETzogVGhpcyBlcnJvciBpcyBwcm9iYWJseSBiZWNhdXNlIHRoZXkgc29tZWhvdyBoYXZlIDIgdmVyc2lvbnMgb2YgdGhlXG4gICAgLy8gcm91dGVyIGxvYWRlZC4gV2UgY2FuIGhlbHAgdGhlbSB1bmRlcnN0YW5kIGhvdyB0byBhdm9pZCB0aGF0LlxuICAgIGB1c2VOYXZpZ2F0ZSgpIG1heSBiZSB1c2VkIG9ubHkgaW4gdGhlIGNvbnRleHQgb2YgYSA8Um91dGVyPiBjb21wb25lbnQuYFxuICApO1xuICBsZXQgZGF0YVJvdXRlckNvbnRleHQgPSBSZWFjdDIudXNlQ29udGV4dChEYXRhUm91dGVyQ29udGV4dCk7XG4gIGxldCB7IGJhc2VuYW1lLCBuYXZpZ2F0b3I6IG5hdmlnYXRvcjIgfSA9IFJlYWN0Mi51c2VDb250ZXh0KE5hdmlnYXRpb25Db250ZXh0KTtcbiAgbGV0IHsgbWF0Y2hlcyB9ID0gUmVhY3QyLnVzZUNvbnRleHQoUm91dGVDb250ZXh0KTtcbiAgbGV0IHsgcGF0aG5hbWU6IGxvY2F0aW9uUGF0aG5hbWUgfSA9IHVzZUxvY2F0aW9uKCk7XG4gIGxldCByb3V0ZVBhdGhuYW1lc0pzb24gPSBKU09OLnN0cmluZ2lmeShnZXRSZXNvbHZlVG9NYXRjaGVzKG1hdGNoZXMpKTtcbiAgbGV0IGFjdGl2ZVJlZiA9IFJlYWN0Mi51c2VSZWYoZmFsc2UpO1xuICB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0KCgpID0+IHtcbiAgICBhY3RpdmVSZWYuY3VycmVudCA9IHRydWU7XG4gIH0pO1xuICBsZXQgbmF2aWdhdGUgPSBSZWFjdDIudXNlQ2FsbGJhY2soXG4gICAgKHRvLCBvcHRpb25zID0ge30pID0+IHtcbiAgICAgIHdhcm5pbmcoYWN0aXZlUmVmLmN1cnJlbnQsIG5hdmlnYXRlRWZmZWN0V2FybmluZyk7XG4gICAgICBpZiAoIWFjdGl2ZVJlZi5jdXJyZW50KSByZXR1cm47XG4gICAgICBpZiAodHlwZW9mIHRvID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgIG5hdmlnYXRvcjIuZ28odG8pO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBsZXQgcGF0aCA9IHJlc29sdmVUbyhcbiAgICAgICAgdG8sXG4gICAgICAgIEpTT04ucGFyc2Uocm91dGVQYXRobmFtZXNKc29uKSxcbiAgICAgICAgbG9jYXRpb25QYXRobmFtZSxcbiAgICAgICAgb3B0aW9ucy5yZWxhdGl2ZSA9PT0gXCJwYXRoXCJcbiAgICAgICk7XG4gICAgICBpZiAoZGF0YVJvdXRlckNvbnRleHQgPT0gbnVsbCAmJiBiYXNlbmFtZSAhPT0gXCIvXCIpIHtcbiAgICAgICAgcGF0aC5wYXRobmFtZSA9IHBhdGgucGF0aG5hbWUgPT09IFwiL1wiID8gYmFzZW5hbWUgOiBqb2luUGF0aHMoW2Jhc2VuYW1lLCBwYXRoLnBhdGhuYW1lXSk7XG4gICAgICB9XG4gICAgICAoISFvcHRpb25zLnJlcGxhY2UgPyBuYXZpZ2F0b3IyLnJlcGxhY2UgOiBuYXZpZ2F0b3IyLnB1c2gpKFxuICAgICAgICBwYXRoLFxuICAgICAgICBvcHRpb25zLnN0YXRlLFxuICAgICAgICBvcHRpb25zXG4gICAgICApO1xuICAgIH0sXG4gICAgW1xuICAgICAgYmFzZW5hbWUsXG4gICAgICBuYXZpZ2F0b3IyLFxuICAgICAgcm91dGVQYXRobmFtZXNKc29uLFxuICAgICAgbG9jYXRpb25QYXRobmFtZSxcbiAgICAgIGRhdGFSb3V0ZXJDb250ZXh0XG4gICAgXVxuICApO1xuICByZXR1cm4gbmF2aWdhdGU7XG59XG52YXIgT3V0bGV0Q29udGV4dCA9IFJlYWN0Mi5jcmVhdGVDb250ZXh0KG51bGwpO1xuZnVuY3Rpb24gdXNlT3V0bGV0Q29udGV4dCgpIHtcbiAgcmV0dXJuIFJlYWN0Mi51c2VDb250ZXh0KE91dGxldENvbnRleHQpO1xufVxuZnVuY3Rpb24gdXNlT3V0bGV0KGNvbnRleHQpIHtcbiAgbGV0IG91dGxldCA9IFJlYWN0Mi51c2VDb250ZXh0KFJvdXRlQ29udGV4dCkub3V0bGV0O1xuICBpZiAob3V0bGV0KSB7XG4gICAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBSZWFjdDIuY3JlYXRlRWxlbWVudChPdXRsZXRDb250ZXh0LlByb3ZpZGVyLCB7IHZhbHVlOiBjb250ZXh0IH0sIG91dGxldCk7XG4gIH1cbiAgcmV0dXJuIG91dGxldDtcbn1cbmZ1bmN0aW9uIHVzZVBhcmFtcygpIHtcbiAgbGV0IHsgbWF0Y2hlcyB9ID0gUmVhY3QyLnVzZUNvbnRleHQoUm91dGVDb250ZXh0KTtcbiAgbGV0IHJvdXRlTWF0Y2ggPSBtYXRjaGVzW21hdGNoZXMubGVuZ3RoIC0gMV07XG4gIHJldHVybiByb3V0ZU1hdGNoID8gcm91dGVNYXRjaC5wYXJhbXMgOiB7fTtcbn1cbmZ1bmN0aW9uIHVzZVJlc29sdmVkUGF0aCh0bywgeyByZWxhdGl2ZSB9ID0ge30pIHtcbiAgbGV0IHsgbWF0Y2hlcyB9ID0gUmVhY3QyLnVzZUNvbnRleHQoUm91dGVDb250ZXh0KTtcbiAgbGV0IHsgcGF0aG5hbWU6IGxvY2F0aW9uUGF0aG5hbWUgfSA9IHVzZUxvY2F0aW9uKCk7XG4gIGxldCByb3V0ZVBhdGhuYW1lc0pzb24gPSBKU09OLnN0cmluZ2lmeShnZXRSZXNvbHZlVG9NYXRjaGVzKG1hdGNoZXMpKTtcbiAgcmV0dXJuIFJlYWN0Mi51c2VNZW1vKFxuICAgICgpID0+IHJlc29sdmVUbyhcbiAgICAgIHRvLFxuICAgICAgSlNPTi5wYXJzZShyb3V0ZVBhdGhuYW1lc0pzb24pLFxuICAgICAgbG9jYXRpb25QYXRobmFtZSxcbiAgICAgIHJlbGF0aXZlID09PSBcInBhdGhcIlxuICAgICksXG4gICAgW3RvLCByb3V0ZVBhdGhuYW1lc0pzb24sIGxvY2F0aW9uUGF0aG5hbWUsIHJlbGF0aXZlXVxuICApO1xufVxuZnVuY3Rpb24gdXNlUm91dGVzKHJvdXRlcywgbG9jYXRpb25BcmcpIHtcbiAgcmV0dXJuIHVzZVJvdXRlc0ltcGwocm91dGVzLCBsb2NhdGlvbkFyZyk7XG59XG5mdW5jdGlvbiB1c2VSb3V0ZXNJbXBsKHJvdXRlcywgbG9jYXRpb25BcmcsIGRhdGFSb3V0ZXJTdGF0ZSwgZnV0dXJlKSB7XG4gIGludmFyaWFudChcbiAgICB1c2VJblJvdXRlckNvbnRleHQoKSxcbiAgICAvLyBUT0RPOiBUaGlzIGVycm9yIGlzIHByb2JhYmx5IGJlY2F1c2UgdGhleSBzb21laG93IGhhdmUgMiB2ZXJzaW9ucyBvZiB0aGVcbiAgICAvLyByb3V0ZXIgbG9hZGVkLiBXZSBjYW4gaGVscCB0aGVtIHVuZGVyc3RhbmQgaG93IHRvIGF2b2lkIHRoYXQuXG4gICAgYHVzZVJvdXRlcygpIG1heSBiZSB1c2VkIG9ubHkgaW4gdGhlIGNvbnRleHQgb2YgYSA8Um91dGVyPiBjb21wb25lbnQuYFxuICApO1xuICBsZXQgeyBuYXZpZ2F0b3I6IG5hdmlnYXRvcjIgfSA9IFJlYWN0Mi51c2VDb250ZXh0KE5hdmlnYXRpb25Db250ZXh0KTtcbiAgbGV0IHsgbWF0Y2hlczogcGFyZW50TWF0Y2hlcyB9ID0gUmVhY3QyLnVzZUNvbnRleHQoUm91dGVDb250ZXh0KTtcbiAgbGV0IHJvdXRlTWF0Y2ggPSBwYXJlbnRNYXRjaGVzW3BhcmVudE1hdGNoZXMubGVuZ3RoIC0gMV07XG4gIGxldCBwYXJlbnRQYXJhbXMgPSByb3V0ZU1hdGNoID8gcm91dGVNYXRjaC5wYXJhbXMgOiB7fTtcbiAgbGV0IHBhcmVudFBhdGhuYW1lID0gcm91dGVNYXRjaCA/IHJvdXRlTWF0Y2gucGF0aG5hbWUgOiBcIi9cIjtcbiAgbGV0IHBhcmVudFBhdGhuYW1lQmFzZSA9IHJvdXRlTWF0Y2ggPyByb3V0ZU1hdGNoLnBhdGhuYW1lQmFzZSA6IFwiL1wiO1xuICBsZXQgcGFyZW50Um91dGUgPSByb3V0ZU1hdGNoICYmIHJvdXRlTWF0Y2gucm91dGU7XG4gIGlmIChFTkFCTEVfREVWX1dBUk5JTkdTKSB7XG4gICAgbGV0IHBhcmVudFBhdGggPSBwYXJlbnRSb3V0ZSAmJiBwYXJlbnRSb3V0ZS5wYXRoIHx8IFwiXCI7XG4gICAgd2FybmluZ09uY2UoXG4gICAgICBwYXJlbnRQYXRobmFtZSxcbiAgICAgICFwYXJlbnRSb3V0ZSB8fCBwYXJlbnRQYXRoLmVuZHNXaXRoKFwiKlwiKSB8fCBwYXJlbnRQYXRoLmVuZHNXaXRoKFwiKj9cIiksXG4gICAgICBgWW91IHJlbmRlcmVkIGRlc2NlbmRhbnQgPFJvdXRlcz4gKG9yIGNhbGxlZCBcXGB1c2VSb3V0ZXMoKVxcYCkgYXQgXCIke3BhcmVudFBhdGhuYW1lfVwiICh1bmRlciA8Um91dGUgcGF0aD1cIiR7cGFyZW50UGF0aH1cIj4pIGJ1dCB0aGUgcGFyZW50IHJvdXRlIHBhdGggaGFzIG5vIHRyYWlsaW5nIFwiKlwiLiBUaGlzIG1lYW5zIGlmIHlvdSBuYXZpZ2F0ZSBkZWVwZXIsIHRoZSBwYXJlbnQgd29uJ3QgbWF0Y2ggYW55bW9yZSBhbmQgdGhlcmVmb3JlIHRoZSBjaGlsZCByb3V0ZXMgd2lsbCBuZXZlciByZW5kZXIuXG5cblBsZWFzZSBjaGFuZ2UgdGhlIHBhcmVudCA8Um91dGUgcGF0aD1cIiR7cGFyZW50UGF0aH1cIj4gdG8gPFJvdXRlIHBhdGg9XCIke3BhcmVudFBhdGggPT09IFwiL1wiID8gXCIqXCIgOiBgJHtwYXJlbnRQYXRofS8qYH1cIj4uYFxuICAgICk7XG4gIH1cbiAgbGV0IGxvY2F0aW9uRnJvbUNvbnRleHQgPSB1c2VMb2NhdGlvbigpO1xuICBsZXQgbG9jYXRpb247XG4gIGlmIChsb2NhdGlvbkFyZykge1xuICAgIGxldCBwYXJzZWRMb2NhdGlvbkFyZyA9IHR5cGVvZiBsb2NhdGlvbkFyZyA9PT0gXCJzdHJpbmdcIiA/IHBhcnNlUGF0aChsb2NhdGlvbkFyZykgOiBsb2NhdGlvbkFyZztcbiAgICBpbnZhcmlhbnQoXG4gICAgICBwYXJlbnRQYXRobmFtZUJhc2UgPT09IFwiL1wiIHx8IHBhcnNlZExvY2F0aW9uQXJnLnBhdGhuYW1lPy5zdGFydHNXaXRoKHBhcmVudFBhdGhuYW1lQmFzZSksXG4gICAgICBgV2hlbiBvdmVycmlkaW5nIHRoZSBsb2NhdGlvbiB1c2luZyBcXGA8Um91dGVzIGxvY2F0aW9uPlxcYCBvciBcXGB1c2VSb3V0ZXMocm91dGVzLCBsb2NhdGlvbilcXGAsIHRoZSBsb2NhdGlvbiBwYXRobmFtZSBtdXN0IGJlZ2luIHdpdGggdGhlIHBvcnRpb24gb2YgdGhlIFVSTCBwYXRobmFtZSB0aGF0IHdhcyBtYXRjaGVkIGJ5IGFsbCBwYXJlbnQgcm91dGVzLiBUaGUgY3VycmVudCBwYXRobmFtZSBiYXNlIGlzIFwiJHtwYXJlbnRQYXRobmFtZUJhc2V9XCIgYnV0IHBhdGhuYW1lIFwiJHtwYXJzZWRMb2NhdGlvbkFyZy5wYXRobmFtZX1cIiB3YXMgZ2l2ZW4gaW4gdGhlIFxcYGxvY2F0aW9uXFxgIHByb3AuYFxuICAgICk7XG4gICAgbG9jYXRpb24gPSBwYXJzZWRMb2NhdGlvbkFyZztcbiAgfSBlbHNlIHtcbiAgICBsb2NhdGlvbiA9IGxvY2F0aW9uRnJvbUNvbnRleHQ7XG4gIH1cbiAgbGV0IHBhdGhuYW1lID0gbG9jYXRpb24ucGF0aG5hbWUgfHwgXCIvXCI7XG4gIGxldCByZW1haW5pbmdQYXRobmFtZSA9IHBhdGhuYW1lO1xuICBpZiAocGFyZW50UGF0aG5hbWVCYXNlICE9PSBcIi9cIikge1xuICAgIGxldCBwYXJlbnRTZWdtZW50cyA9IHBhcmVudFBhdGhuYW1lQmFzZS5yZXBsYWNlKC9eXFwvLywgXCJcIikuc3BsaXQoXCIvXCIpO1xuICAgIGxldCBzZWdtZW50cyA9IHBhdGhuYW1lLnJlcGxhY2UoL15cXC8vLCBcIlwiKS5zcGxpdChcIi9cIik7XG4gICAgcmVtYWluaW5nUGF0aG5hbWUgPSBcIi9cIiArIHNlZ21lbnRzLnNsaWNlKHBhcmVudFNlZ21lbnRzLmxlbmd0aCkuam9pbihcIi9cIik7XG4gIH1cbiAgbGV0IG1hdGNoZXMgPSBtYXRjaFJvdXRlcyhyb3V0ZXMsIHsgcGF0aG5hbWU6IHJlbWFpbmluZ1BhdGhuYW1lIH0pO1xuICBpZiAoRU5BQkxFX0RFVl9XQVJOSU5HUykge1xuICAgIHdhcm5pbmcoXG4gICAgICBwYXJlbnRSb3V0ZSB8fCBtYXRjaGVzICE9IG51bGwsXG4gICAgICBgTm8gcm91dGVzIG1hdGNoZWQgbG9jYXRpb24gXCIke2xvY2F0aW9uLnBhdGhuYW1lfSR7bG9jYXRpb24uc2VhcmNofSR7bG9jYXRpb24uaGFzaH1cIiBgXG4gICAgKTtcbiAgICB3YXJuaW5nKFxuICAgICAgbWF0Y2hlcyA9PSBudWxsIHx8IG1hdGNoZXNbbWF0Y2hlcy5sZW5ndGggLSAxXS5yb3V0ZS5lbGVtZW50ICE9PSB2b2lkIDAgfHwgbWF0Y2hlc1ttYXRjaGVzLmxlbmd0aCAtIDFdLnJvdXRlLkNvbXBvbmVudCAhPT0gdm9pZCAwIHx8IG1hdGNoZXNbbWF0Y2hlcy5sZW5ndGggLSAxXS5yb3V0ZS5sYXp5ICE9PSB2b2lkIDAsXG4gICAgICBgTWF0Y2hlZCBsZWFmIHJvdXRlIGF0IGxvY2F0aW9uIFwiJHtsb2NhdGlvbi5wYXRobmFtZX0ke2xvY2F0aW9uLnNlYXJjaH0ke2xvY2F0aW9uLmhhc2h9XCIgZG9lcyBub3QgaGF2ZSBhbiBlbGVtZW50IG9yIENvbXBvbmVudC4gVGhpcyBtZWFucyBpdCB3aWxsIHJlbmRlciBhbiA8T3V0bGV0IC8+IHdpdGggYSBudWxsIHZhbHVlIGJ5IGRlZmF1bHQgcmVzdWx0aW5nIGluIGFuIFwiZW1wdHlcIiBwYWdlLmBcbiAgICApO1xuICB9XG4gIGxldCByZW5kZXJlZE1hdGNoZXMgPSBfcmVuZGVyTWF0Y2hlcyhcbiAgICBtYXRjaGVzICYmIG1hdGNoZXMubWFwKFxuICAgICAgKG1hdGNoKSA9PiBPYmplY3QuYXNzaWduKHt9LCBtYXRjaCwge1xuICAgICAgICBwYXJhbXM6IE9iamVjdC5hc3NpZ24oe30sIHBhcmVudFBhcmFtcywgbWF0Y2gucGFyYW1zKSxcbiAgICAgICAgcGF0aG5hbWU6IGpvaW5QYXRocyhbXG4gICAgICAgICAgcGFyZW50UGF0aG5hbWVCYXNlLFxuICAgICAgICAgIC8vIFJlLWVuY29kZSBwYXRobmFtZXMgdGhhdCB3ZXJlIGRlY29kZWQgaW5zaWRlIG1hdGNoUm91dGVzXG4gICAgICAgICAgbmF2aWdhdG9yMi5lbmNvZGVMb2NhdGlvbiA/IG5hdmlnYXRvcjIuZW5jb2RlTG9jYXRpb24obWF0Y2gucGF0aG5hbWUpLnBhdGhuYW1lIDogbWF0Y2gucGF0aG5hbWVcbiAgICAgICAgXSksXG4gICAgICAgIHBhdGhuYW1lQmFzZTogbWF0Y2gucGF0aG5hbWVCYXNlID09PSBcIi9cIiA/IHBhcmVudFBhdGhuYW1lQmFzZSA6IGpvaW5QYXRocyhbXG4gICAgICAgICAgcGFyZW50UGF0aG5hbWVCYXNlLFxuICAgICAgICAgIC8vIFJlLWVuY29kZSBwYXRobmFtZXMgdGhhdCB3ZXJlIGRlY29kZWQgaW5zaWRlIG1hdGNoUm91dGVzXG4gICAgICAgICAgbmF2aWdhdG9yMi5lbmNvZGVMb2NhdGlvbiA/IG5hdmlnYXRvcjIuZW5jb2RlTG9jYXRpb24obWF0Y2gucGF0aG5hbWVCYXNlKS5wYXRobmFtZSA6IG1hdGNoLnBhdGhuYW1lQmFzZVxuICAgICAgICBdKVxuICAgICAgfSlcbiAgICApLFxuICAgIHBhcmVudE1hdGNoZXMsXG4gICAgZGF0YVJvdXRlclN0YXRlLFxuICAgIGZ1dHVyZVxuICApO1xuICBpZiAobG9jYXRpb25BcmcgJiYgcmVuZGVyZWRNYXRjaGVzKSB7XG4gICAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBSZWFjdDIuY3JlYXRlRWxlbWVudChcbiAgICAgIExvY2F0aW9uQ29udGV4dC5Qcm92aWRlcixcbiAgICAgIHtcbiAgICAgICAgdmFsdWU6IHtcbiAgICAgICAgICBsb2NhdGlvbjoge1xuICAgICAgICAgICAgcGF0aG5hbWU6IFwiL1wiLFxuICAgICAgICAgICAgc2VhcmNoOiBcIlwiLFxuICAgICAgICAgICAgaGFzaDogXCJcIixcbiAgICAgICAgICAgIHN0YXRlOiBudWxsLFxuICAgICAgICAgICAga2V5OiBcImRlZmF1bHRcIixcbiAgICAgICAgICAgIC4uLmxvY2F0aW9uXG4gICAgICAgICAgfSxcbiAgICAgICAgICBuYXZpZ2F0aW9uVHlwZTogXCJQT1BcIiAvKiBQb3AgKi9cbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHJlbmRlcmVkTWF0Y2hlc1xuICAgICk7XG4gIH1cbiAgcmV0dXJuIHJlbmRlcmVkTWF0Y2hlcztcbn1cbmZ1bmN0aW9uIERlZmF1bHRFcnJvckNvbXBvbmVudCgpIHtcbiAgbGV0IGVycm9yID0gdXNlUm91dGVFcnJvcigpO1xuICBsZXQgbWVzc2FnZSA9IGlzUm91dGVFcnJvclJlc3BvbnNlKGVycm9yKSA/IGAke2Vycm9yLnN0YXR1c30gJHtlcnJvci5zdGF0dXNUZXh0fWAgOiBlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IubWVzc2FnZSA6IEpTT04uc3RyaW5naWZ5KGVycm9yKTtcbiAgbGV0IHN0YWNrID0gZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLnN0YWNrIDogbnVsbDtcbiAgbGV0IGxpZ2h0Z3JleSA9IFwicmdiYSgyMDAsMjAwLDIwMCwgMC41KVwiO1xuICBsZXQgcHJlU3R5bGVzID0geyBwYWRkaW5nOiBcIjAuNXJlbVwiLCBiYWNrZ3JvdW5kQ29sb3I6IGxpZ2h0Z3JleSB9O1xuICBsZXQgY29kZVN0eWxlcyA9IHsgcGFkZGluZzogXCIycHggNHB4XCIsIGJhY2tncm91bmRDb2xvcjogbGlnaHRncmV5IH07XG4gIGxldCBkZXZJbmZvID0gbnVsbDtcbiAgaWYgKEVOQUJMRV9ERVZfV0FSTklOR1MpIHtcbiAgICBjb25zb2xlLmVycm9yKFxuICAgICAgXCJFcnJvciBoYW5kbGVkIGJ5IFJlYWN0IFJvdXRlciBkZWZhdWx0IEVycm9yQm91bmRhcnk6XCIsXG4gICAgICBlcnJvclxuICAgICk7XG4gICAgZGV2SW5mbyA9IC8qIEBfX1BVUkVfXyAqLyBSZWFjdDIuY3JlYXRlRWxlbWVudChSZWFjdDIuRnJhZ21lbnQsIG51bGwsIC8qIEBfX1BVUkVfXyAqLyBSZWFjdDIuY3JlYXRlRWxlbWVudChcInBcIiwgbnVsbCwgXCJcXHV7MUY0QkZ9IEhleSBkZXZlbG9wZXIgXFx1ezFGNDRCfVwiKSwgLyogQF9fUFVSRV9fICovIFJlYWN0Mi5jcmVhdGVFbGVtZW50KFwicFwiLCBudWxsLCBcIllvdSBjYW4gcHJvdmlkZSBhIHdheSBiZXR0ZXIgVVggdGhhbiB0aGlzIHdoZW4geW91ciBhcHAgdGhyb3dzIGVycm9ycyBieSBwcm92aWRpbmcgeW91ciBvd24gXCIsIC8qIEBfX1BVUkVfXyAqLyBSZWFjdDIuY3JlYXRlRWxlbWVudChcImNvZGVcIiwgeyBzdHlsZTogY29kZVN0eWxlcyB9LCBcIkVycm9yQm91bmRhcnlcIiksIFwiIG9yXCIsIFwiIFwiLCAvKiBAX19QVVJFX18gKi8gUmVhY3QyLmNyZWF0ZUVsZW1lbnQoXCJjb2RlXCIsIHsgc3R5bGU6IGNvZGVTdHlsZXMgfSwgXCJlcnJvckVsZW1lbnRcIiksIFwiIHByb3Agb24geW91ciByb3V0ZS5cIikpO1xuICB9XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8gUmVhY3QyLmNyZWF0ZUVsZW1lbnQoUmVhY3QyLkZyYWdtZW50LCBudWxsLCAvKiBAX19QVVJFX18gKi8gUmVhY3QyLmNyZWF0ZUVsZW1lbnQoXCJoMlwiLCBudWxsLCBcIlVuZXhwZWN0ZWQgQXBwbGljYXRpb24gRXJyb3IhXCIpLCAvKiBAX19QVVJFX18gKi8gUmVhY3QyLmNyZWF0ZUVsZW1lbnQoXCJoM1wiLCB7IHN0eWxlOiB7IGZvbnRTdHlsZTogXCJpdGFsaWNcIiB9IH0sIG1lc3NhZ2UpLCBzdGFjayA/IC8qIEBfX1BVUkVfXyAqLyBSZWFjdDIuY3JlYXRlRWxlbWVudChcInByZVwiLCB7IHN0eWxlOiBwcmVTdHlsZXMgfSwgc3RhY2spIDogbnVsbCwgZGV2SW5mbyk7XG59XG52YXIgZGVmYXVsdEVycm9yRWxlbWVudCA9IC8qIEBfX1BVUkVfXyAqLyBSZWFjdDIuY3JlYXRlRWxlbWVudChEZWZhdWx0RXJyb3JDb21wb25lbnQsIG51bGwpO1xudmFyIFJlbmRlckVycm9yQm91bmRhcnkgPSBjbGFzcyBleHRlbmRzIFJlYWN0Mi5Db21wb25lbnQge1xuICBjb25zdHJ1Y3Rvcihwcm9wcykge1xuICAgIHN1cGVyKHByb3BzKTtcbiAgICB0aGlzLnN0YXRlID0ge1xuICAgICAgbG9jYXRpb246IHByb3BzLmxvY2F0aW9uLFxuICAgICAgcmV2YWxpZGF0aW9uOiBwcm9wcy5yZXZhbGlkYXRpb24sXG4gICAgICBlcnJvcjogcHJvcHMuZXJyb3JcbiAgICB9O1xuICB9XG4gIHN0YXRpYyBnZXREZXJpdmVkU3RhdGVGcm9tRXJyb3IoZXJyb3IpIHtcbiAgICByZXR1cm4geyBlcnJvciB9O1xuICB9XG4gIHN0YXRpYyBnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMocHJvcHMsIHN0YXRlKSB7XG4gICAgaWYgKHN0YXRlLmxvY2F0aW9uICE9PSBwcm9wcy5sb2NhdGlvbiB8fCBzdGF0ZS5yZXZhbGlkYXRpb24gIT09IFwiaWRsZVwiICYmIHByb3BzLnJldmFsaWRhdGlvbiA9PT0gXCJpZGxlXCIpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGVycm9yOiBwcm9wcy5lcnJvcixcbiAgICAgICAgbG9jYXRpb246IHByb3BzLmxvY2F0aW9uLFxuICAgICAgICByZXZhbGlkYXRpb246IHByb3BzLnJldmFsaWRhdGlvblxuICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIGVycm9yOiBwcm9wcy5lcnJvciAhPT0gdm9pZCAwID8gcHJvcHMuZXJyb3IgOiBzdGF0ZS5lcnJvcixcbiAgICAgIGxvY2F0aW9uOiBzdGF0ZS5sb2NhdGlvbixcbiAgICAgIHJldmFsaWRhdGlvbjogcHJvcHMucmV2YWxpZGF0aW9uIHx8IHN0YXRlLnJldmFsaWRhdGlvblxuICAgIH07XG4gIH1cbiAgY29tcG9uZW50RGlkQ2F0Y2goZXJyb3IsIGVycm9ySW5mbykge1xuICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICBcIlJlYWN0IFJvdXRlciBjYXVnaHQgdGhlIGZvbGxvd2luZyBlcnJvciBkdXJpbmcgcmVuZGVyXCIsXG4gICAgICBlcnJvcixcbiAgICAgIGVycm9ySW5mb1xuICAgICk7XG4gIH1cbiAgcmVuZGVyKCkge1xuICAgIHJldHVybiB0aGlzLnN0YXRlLmVycm9yICE9PSB2b2lkIDAgPyAvKiBAX19QVVJFX18gKi8gUmVhY3QyLmNyZWF0ZUVsZW1lbnQoUm91dGVDb250ZXh0LlByb3ZpZGVyLCB7IHZhbHVlOiB0aGlzLnByb3BzLnJvdXRlQ29udGV4dCB9LCAvKiBAX19QVVJFX18gKi8gUmVhY3QyLmNyZWF0ZUVsZW1lbnQoXG4gICAgICBSb3V0ZUVycm9yQ29udGV4dC5Qcm92aWRlcixcbiAgICAgIHtcbiAgICAgICAgdmFsdWU6IHRoaXMuc3RhdGUuZXJyb3IsXG4gICAgICAgIGNoaWxkcmVuOiB0aGlzLnByb3BzLmNvbXBvbmVudFxuICAgICAgfVxuICAgICkpIDogdGhpcy5wcm9wcy5jaGlsZHJlbjtcbiAgfVxufTtcbmZ1bmN0aW9uIFJlbmRlcmVkUm91dGUoeyByb3V0ZUNvbnRleHQsIG1hdGNoLCBjaGlsZHJlbiB9KSB7XG4gIGxldCBkYXRhUm91dGVyQ29udGV4dCA9IFJlYWN0Mi51c2VDb250ZXh0KERhdGFSb3V0ZXJDb250ZXh0KTtcbiAgaWYgKGRhdGFSb3V0ZXJDb250ZXh0ICYmIGRhdGFSb3V0ZXJDb250ZXh0LnN0YXRpYyAmJiBkYXRhUm91dGVyQ29udGV4dC5zdGF0aWNDb250ZXh0ICYmIChtYXRjaC5yb3V0ZS5lcnJvckVsZW1lbnQgfHwgbWF0Y2gucm91dGUuRXJyb3JCb3VuZGFyeSkpIHtcbiAgICBkYXRhUm91dGVyQ29udGV4dC5zdGF0aWNDb250ZXh0Ll9kZWVwZXN0UmVuZGVyZWRCb3VuZGFyeUlkID0gbWF0Y2gucm91dGUuaWQ7XG4gIH1cbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBSZWFjdDIuY3JlYXRlRWxlbWVudChSb3V0ZUNvbnRleHQuUHJvdmlkZXIsIHsgdmFsdWU6IHJvdXRlQ29udGV4dCB9LCBjaGlsZHJlbik7XG59XG5mdW5jdGlvbiBfcmVuZGVyTWF0Y2hlcyhtYXRjaGVzLCBwYXJlbnRNYXRjaGVzID0gW10sIGRhdGFSb3V0ZXJTdGF0ZSA9IG51bGwsIGZ1dHVyZSA9IG51bGwpIHtcbiAgaWYgKG1hdGNoZXMgPT0gbnVsbCkge1xuICAgIGlmICghZGF0YVJvdXRlclN0YXRlKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgaWYgKGRhdGFSb3V0ZXJTdGF0ZS5lcnJvcnMpIHtcbiAgICAgIG1hdGNoZXMgPSBkYXRhUm91dGVyU3RhdGUubWF0Y2hlcztcbiAgICB9IGVsc2UgaWYgKHBhcmVudE1hdGNoZXMubGVuZ3RoID09PSAwICYmICFkYXRhUm91dGVyU3RhdGUuaW5pdGlhbGl6ZWQgJiYgZGF0YVJvdXRlclN0YXRlLm1hdGNoZXMubGVuZ3RoID4gMCkge1xuICAgICAgbWF0Y2hlcyA9IGRhdGFSb3V0ZXJTdGF0ZS5tYXRjaGVzO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH1cbiAgbGV0IHJlbmRlcmVkTWF0Y2hlcyA9IG1hdGNoZXM7XG4gIGxldCBlcnJvcnMgPSBkYXRhUm91dGVyU3RhdGU/LmVycm9ycztcbiAgaWYgKGVycm9ycyAhPSBudWxsKSB7XG4gICAgbGV0IGVycm9ySW5kZXggPSByZW5kZXJlZE1hdGNoZXMuZmluZEluZGV4KFxuICAgICAgKG0pID0+IG0ucm91dGUuaWQgJiYgZXJyb3JzPy5bbS5yb3V0ZS5pZF0gIT09IHZvaWQgMFxuICAgICk7XG4gICAgaW52YXJpYW50KFxuICAgICAgZXJyb3JJbmRleCA+PSAwLFxuICAgICAgYENvdWxkIG5vdCBmaW5kIGEgbWF0Y2hpbmcgcm91dGUgZm9yIGVycm9ycyBvbiByb3V0ZSBJRHM6ICR7T2JqZWN0LmtleXMoXG4gICAgICAgIGVycm9yc1xuICAgICAgKS5qb2luKFwiLFwiKX1gXG4gICAgKTtcbiAgICByZW5kZXJlZE1hdGNoZXMgPSByZW5kZXJlZE1hdGNoZXMuc2xpY2UoXG4gICAgICAwLFxuICAgICAgTWF0aC5taW4ocmVuZGVyZWRNYXRjaGVzLmxlbmd0aCwgZXJyb3JJbmRleCArIDEpXG4gICAgKTtcbiAgfVxuICBsZXQgcmVuZGVyRmFsbGJhY2sgPSBmYWxzZTtcbiAgbGV0IGZhbGxiYWNrSW5kZXggPSAtMTtcbiAgaWYgKGRhdGFSb3V0ZXJTdGF0ZSkge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcmVuZGVyZWRNYXRjaGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBsZXQgbWF0Y2ggPSByZW5kZXJlZE1hdGNoZXNbaV07XG4gICAgICBpZiAobWF0Y2gucm91dGUuSHlkcmF0ZUZhbGxiYWNrIHx8IG1hdGNoLnJvdXRlLmh5ZHJhdGVGYWxsYmFja0VsZW1lbnQpIHtcbiAgICAgICAgZmFsbGJhY2tJbmRleCA9IGk7XG4gICAgICB9XG4gICAgICBpZiAobWF0Y2gucm91dGUuaWQpIHtcbiAgICAgICAgbGV0IHsgbG9hZGVyRGF0YSwgZXJyb3JzOiBlcnJvcnMyIH0gPSBkYXRhUm91dGVyU3RhdGU7XG4gICAgICAgIGxldCBuZWVkc1RvUnVuTG9hZGVyID0gbWF0Y2gucm91dGUubG9hZGVyICYmICFsb2FkZXJEYXRhLmhhc093blByb3BlcnR5KG1hdGNoLnJvdXRlLmlkKSAmJiAoIWVycm9yczIgfHwgZXJyb3JzMlttYXRjaC5yb3V0ZS5pZF0gPT09IHZvaWQgMCk7XG4gICAgICAgIGlmIChtYXRjaC5yb3V0ZS5sYXp5IHx8IG5lZWRzVG9SdW5Mb2FkZXIpIHtcbiAgICAgICAgICByZW5kZXJGYWxsYmFjayA9IHRydWU7XG4gICAgICAgICAgaWYgKGZhbGxiYWNrSW5kZXggPj0gMCkge1xuICAgICAgICAgICAgcmVuZGVyZWRNYXRjaGVzID0gcmVuZGVyZWRNYXRjaGVzLnNsaWNlKDAsIGZhbGxiYWNrSW5kZXggKyAxKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVuZGVyZWRNYXRjaGVzID0gW3JlbmRlcmVkTWF0Y2hlc1swXV07XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiByZW5kZXJlZE1hdGNoZXMucmVkdWNlUmlnaHQoKG91dGxldCwgbWF0Y2gsIGluZGV4KSA9PiB7XG4gICAgbGV0IGVycm9yO1xuICAgIGxldCBzaG91bGRSZW5kZXJIeWRyYXRlRmFsbGJhY2sgPSBmYWxzZTtcbiAgICBsZXQgZXJyb3JFbGVtZW50ID0gbnVsbDtcbiAgICBsZXQgaHlkcmF0ZUZhbGxiYWNrRWxlbWVudCA9IG51bGw7XG4gICAgaWYgKGRhdGFSb3V0ZXJTdGF0ZSkge1xuICAgICAgZXJyb3IgPSBlcnJvcnMgJiYgbWF0Y2gucm91dGUuaWQgPyBlcnJvcnNbbWF0Y2gucm91dGUuaWRdIDogdm9pZCAwO1xuICAgICAgZXJyb3JFbGVtZW50ID0gbWF0Y2gucm91dGUuZXJyb3JFbGVtZW50IHx8IGRlZmF1bHRFcnJvckVsZW1lbnQ7XG4gICAgICBpZiAocmVuZGVyRmFsbGJhY2spIHtcbiAgICAgICAgaWYgKGZhbGxiYWNrSW5kZXggPCAwICYmIGluZGV4ID09PSAwKSB7XG4gICAgICAgICAgd2FybmluZ09uY2UoXG4gICAgICAgICAgICBcInJvdXRlLWZhbGxiYWNrXCIsXG4gICAgICAgICAgICBmYWxzZSxcbiAgICAgICAgICAgIFwiTm8gYEh5ZHJhdGVGYWxsYmFja2AgZWxlbWVudCBwcm92aWRlZCB0byByZW5kZXIgZHVyaW5nIGluaXRpYWwgaHlkcmF0aW9uXCJcbiAgICAgICAgICApO1xuICAgICAgICAgIHNob3VsZFJlbmRlckh5ZHJhdGVGYWxsYmFjayA9IHRydWU7XG4gICAgICAgICAgaHlkcmF0ZUZhbGxiYWNrRWxlbWVudCA9IG51bGw7XG4gICAgICAgIH0gZWxzZSBpZiAoZmFsbGJhY2tJbmRleCA9PT0gaW5kZXgpIHtcbiAgICAgICAgICBzaG91bGRSZW5kZXJIeWRyYXRlRmFsbGJhY2sgPSB0cnVlO1xuICAgICAgICAgIGh5ZHJhdGVGYWxsYmFja0VsZW1lbnQgPSBtYXRjaC5yb3V0ZS5oeWRyYXRlRmFsbGJhY2tFbGVtZW50IHx8IG51bGw7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgbGV0IG1hdGNoZXMyID0gcGFyZW50TWF0Y2hlcy5jb25jYXQocmVuZGVyZWRNYXRjaGVzLnNsaWNlKDAsIGluZGV4ICsgMSkpO1xuICAgIGxldCBnZXRDaGlsZHJlbiA9ICgpID0+IHtcbiAgICAgIGxldCBjaGlsZHJlbjtcbiAgICAgIGlmIChlcnJvcikge1xuICAgICAgICBjaGlsZHJlbiA9IGVycm9yRWxlbWVudDtcbiAgICAgIH0gZWxzZSBpZiAoc2hvdWxkUmVuZGVySHlkcmF0ZUZhbGxiYWNrKSB7XG4gICAgICAgIGNoaWxkcmVuID0gaHlkcmF0ZUZhbGxiYWNrRWxlbWVudDtcbiAgICAgIH0gZWxzZSBpZiAobWF0Y2gucm91dGUuQ29tcG9uZW50KSB7XG4gICAgICAgIGNoaWxkcmVuID0gLyogQF9fUFVSRV9fICovIFJlYWN0Mi5jcmVhdGVFbGVtZW50KG1hdGNoLnJvdXRlLkNvbXBvbmVudCwgbnVsbCk7XG4gICAgICB9IGVsc2UgaWYgKG1hdGNoLnJvdXRlLmVsZW1lbnQpIHtcbiAgICAgICAgY2hpbGRyZW4gPSBtYXRjaC5yb3V0ZS5lbGVtZW50O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2hpbGRyZW4gPSBvdXRsZXQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gLyogQF9fUFVSRV9fICovIFJlYWN0Mi5jcmVhdGVFbGVtZW50KFxuICAgICAgICBSZW5kZXJlZFJvdXRlLFxuICAgICAgICB7XG4gICAgICAgICAgbWF0Y2gsXG4gICAgICAgICAgcm91dGVDb250ZXh0OiB7XG4gICAgICAgICAgICBvdXRsZXQsXG4gICAgICAgICAgICBtYXRjaGVzOiBtYXRjaGVzMixcbiAgICAgICAgICAgIGlzRGF0YVJvdXRlOiBkYXRhUm91dGVyU3RhdGUgIT0gbnVsbFxuICAgICAgICAgIH0sXG4gICAgICAgICAgY2hpbGRyZW5cbiAgICAgICAgfVxuICAgICAgKTtcbiAgICB9O1xuICAgIHJldHVybiBkYXRhUm91dGVyU3RhdGUgJiYgKG1hdGNoLnJvdXRlLkVycm9yQm91bmRhcnkgfHwgbWF0Y2gucm91dGUuZXJyb3JFbGVtZW50IHx8IGluZGV4ID09PSAwKSA/IC8qIEBfX1BVUkVfXyAqLyBSZWFjdDIuY3JlYXRlRWxlbWVudChcbiAgICAgIFJlbmRlckVycm9yQm91bmRhcnksXG4gICAgICB7XG4gICAgICAgIGxvY2F0aW9uOiBkYXRhUm91dGVyU3RhdGUubG9jYXRpb24sXG4gICAgICAgIHJldmFsaWRhdGlvbjogZGF0YVJvdXRlclN0YXRlLnJldmFsaWRhdGlvbixcbiAgICAgICAgY29tcG9uZW50OiBlcnJvckVsZW1lbnQsXG4gICAgICAgIGVycm9yLFxuICAgICAgICBjaGlsZHJlbjogZ2V0Q2hpbGRyZW4oKSxcbiAgICAgICAgcm91dGVDb250ZXh0OiB7IG91dGxldDogbnVsbCwgbWF0Y2hlczogbWF0Y2hlczIsIGlzRGF0YVJvdXRlOiB0cnVlIH1cbiAgICAgIH1cbiAgICApIDogZ2V0Q2hpbGRyZW4oKTtcbiAgfSwgbnVsbCk7XG59XG5mdW5jdGlvbiBnZXREYXRhUm91dGVyQ29uc29sZUVycm9yKGhvb2tOYW1lKSB7XG4gIHJldHVybiBgJHtob29rTmFtZX0gbXVzdCBiZSB1c2VkIHdpdGhpbiBhIGRhdGEgcm91dGVyLiAgU2VlIGh0dHBzOi8vcmVhY3Ryb3V0ZXIuY29tL2VuL21haW4vcm91dGVycy9waWNraW5nLWEtcm91dGVyLmA7XG59XG5mdW5jdGlvbiB1c2VEYXRhUm91dGVyQ29udGV4dChob29rTmFtZSkge1xuICBsZXQgY3R4ID0gUmVhY3QyLnVzZUNvbnRleHQoRGF0YVJvdXRlckNvbnRleHQpO1xuICBpbnZhcmlhbnQoY3R4LCBnZXREYXRhUm91dGVyQ29uc29sZUVycm9yKGhvb2tOYW1lKSk7XG4gIHJldHVybiBjdHg7XG59XG5mdW5jdGlvbiB1c2VEYXRhUm91dGVyU3RhdGUoaG9va05hbWUpIHtcbiAgbGV0IHN0YXRlID0gUmVhY3QyLnVzZUNvbnRleHQoRGF0YVJvdXRlclN0YXRlQ29udGV4dCk7XG4gIGludmFyaWFudChzdGF0ZSwgZ2V0RGF0YVJvdXRlckNvbnNvbGVFcnJvcihob29rTmFtZSkpO1xuICByZXR1cm4gc3RhdGU7XG59XG5mdW5jdGlvbiB1c2VSb3V0ZUNvbnRleHQoaG9va05hbWUpIHtcbiAgbGV0IHJvdXRlID0gUmVhY3QyLnVzZUNvbnRleHQoUm91dGVDb250ZXh0KTtcbiAgaW52YXJpYW50KHJvdXRlLCBnZXREYXRhUm91dGVyQ29uc29sZUVycm9yKGhvb2tOYW1lKSk7XG4gIHJldHVybiByb3V0ZTtcbn1cbmZ1bmN0aW9uIHVzZUN1cnJlbnRSb3V0ZUlkKGhvb2tOYW1lKSB7XG4gIGxldCByb3V0ZSA9IHVzZVJvdXRlQ29udGV4dChob29rTmFtZSk7XG4gIGxldCB0aGlzUm91dGUgPSByb3V0ZS5tYXRjaGVzW3JvdXRlLm1hdGNoZXMubGVuZ3RoIC0gMV07XG4gIGludmFyaWFudChcbiAgICB0aGlzUm91dGUucm91dGUuaWQsXG4gICAgYCR7aG9va05hbWV9IGNhbiBvbmx5IGJlIHVzZWQgb24gcm91dGVzIHRoYXQgY29udGFpbiBhIHVuaXF1ZSBcImlkXCJgXG4gICk7XG4gIHJldHVybiB0aGlzUm91dGUucm91dGUuaWQ7XG59XG5mdW5jdGlvbiB1c2VSb3V0ZUlkKCkge1xuICByZXR1cm4gdXNlQ3VycmVudFJvdXRlSWQoXCJ1c2VSb3V0ZUlkXCIgLyogVXNlUm91dGVJZCAqLyk7XG59XG5mdW5jdGlvbiB1c2VOYXZpZ2F0aW9uKCkge1xuICBsZXQgc3RhdGUgPSB1c2VEYXRhUm91dGVyU3RhdGUoXCJ1c2VOYXZpZ2F0aW9uXCIgLyogVXNlTmF2aWdhdGlvbiAqLyk7XG4gIHJldHVybiBzdGF0ZS5uYXZpZ2F0aW9uO1xufVxuZnVuY3Rpb24gdXNlUmV2YWxpZGF0b3IoKSB7XG4gIGxldCBkYXRhUm91dGVyQ29udGV4dCA9IHVzZURhdGFSb3V0ZXJDb250ZXh0KFwidXNlUmV2YWxpZGF0b3JcIiAvKiBVc2VSZXZhbGlkYXRvciAqLyk7XG4gIGxldCBzdGF0ZSA9IHVzZURhdGFSb3V0ZXJTdGF0ZShcInVzZVJldmFsaWRhdG9yXCIgLyogVXNlUmV2YWxpZGF0b3IgKi8pO1xuICByZXR1cm4gUmVhY3QyLnVzZU1lbW8oXG4gICAgKCkgPT4gKHtcbiAgICAgIGFzeW5jIHJldmFsaWRhdGUoKSB7XG4gICAgICAgIGF3YWl0IGRhdGFSb3V0ZXJDb250ZXh0LnJvdXRlci5yZXZhbGlkYXRlKCk7XG4gICAgICB9LFxuICAgICAgc3RhdGU6IHN0YXRlLnJldmFsaWRhdGlvblxuICAgIH0pLFxuICAgIFtkYXRhUm91dGVyQ29udGV4dC5yb3V0ZXIsIHN0YXRlLnJldmFsaWRhdGlvbl1cbiAgKTtcbn1cbmZ1bmN0aW9uIHVzZU1hdGNoZXMoKSB7XG4gIGxldCB7IG1hdGNoZXMsIGxvYWRlckRhdGEgfSA9IHVzZURhdGFSb3V0ZXJTdGF0ZShcbiAgICBcInVzZU1hdGNoZXNcIiAvKiBVc2VNYXRjaGVzICovXG4gICk7XG4gIHJldHVybiBSZWFjdDIudXNlTWVtbyhcbiAgICAoKSA9PiBtYXRjaGVzLm1hcCgobSkgPT4gY29udmVydFJvdXRlTWF0Y2hUb1VpTWF0Y2gobSwgbG9hZGVyRGF0YSkpLFxuICAgIFttYXRjaGVzLCBsb2FkZXJEYXRhXVxuICApO1xufVxuZnVuY3Rpb24gdXNlTG9hZGVyRGF0YSgpIHtcbiAgbGV0IHN0YXRlID0gdXNlRGF0YVJvdXRlclN0YXRlKFwidXNlTG9hZGVyRGF0YVwiIC8qIFVzZUxvYWRlckRhdGEgKi8pO1xuICBsZXQgcm91dGVJZCA9IHVzZUN1cnJlbnRSb3V0ZUlkKFwidXNlTG9hZGVyRGF0YVwiIC8qIFVzZUxvYWRlckRhdGEgKi8pO1xuICByZXR1cm4gc3RhdGUubG9hZGVyRGF0YVtyb3V0ZUlkXTtcbn1cbmZ1bmN0aW9uIHVzZVJvdXRlTG9hZGVyRGF0YShyb3V0ZUlkKSB7XG4gIGxldCBzdGF0ZSA9IHVzZURhdGFSb3V0ZXJTdGF0ZShcInVzZVJvdXRlTG9hZGVyRGF0YVwiIC8qIFVzZVJvdXRlTG9hZGVyRGF0YSAqLyk7XG4gIHJldHVybiBzdGF0ZS5sb2FkZXJEYXRhW3JvdXRlSWRdO1xufVxuZnVuY3Rpb24gdXNlQWN0aW9uRGF0YSgpIHtcbiAgbGV0IHN0YXRlID0gdXNlRGF0YVJvdXRlclN0YXRlKFwidXNlQWN0aW9uRGF0YVwiIC8qIFVzZUFjdGlvbkRhdGEgKi8pO1xuICBsZXQgcm91dGVJZCA9IHVzZUN1cnJlbnRSb3V0ZUlkKFwidXNlTG9hZGVyRGF0YVwiIC8qIFVzZUxvYWRlckRhdGEgKi8pO1xuICByZXR1cm4gc3RhdGUuYWN0aW9uRGF0YSA/IHN0YXRlLmFjdGlvbkRhdGFbcm91dGVJZF0gOiB2b2lkIDA7XG59XG5mdW5jdGlvbiB1c2VSb3V0ZUVycm9yKCkge1xuICBsZXQgZXJyb3IgPSBSZWFjdDIudXNlQ29udGV4dChSb3V0ZUVycm9yQ29udGV4dCk7XG4gIGxldCBzdGF0ZSA9IHVzZURhdGFSb3V0ZXJTdGF0ZShcInVzZVJvdXRlRXJyb3JcIiAvKiBVc2VSb3V0ZUVycm9yICovKTtcbiAgbGV0IHJvdXRlSWQgPSB1c2VDdXJyZW50Um91dGVJZChcInVzZVJvdXRlRXJyb3JcIiAvKiBVc2VSb3V0ZUVycm9yICovKTtcbiAgaWYgKGVycm9yICE9PSB2b2lkIDApIHtcbiAgICByZXR1cm4gZXJyb3I7XG4gIH1cbiAgcmV0dXJuIHN0YXRlLmVycm9ycz8uW3JvdXRlSWRdO1xufVxuZnVuY3Rpb24gdXNlQXN5bmNWYWx1ZSgpIHtcbiAgbGV0IHZhbHVlID0gUmVhY3QyLnVzZUNvbnRleHQoQXdhaXRDb250ZXh0KTtcbiAgcmV0dXJuIHZhbHVlPy5fZGF0YTtcbn1cbmZ1bmN0aW9uIHVzZUFzeW5jRXJyb3IoKSB7XG4gIGxldCB2YWx1ZSA9IFJlYWN0Mi51c2VDb250ZXh0KEF3YWl0Q29udGV4dCk7XG4gIHJldHVybiB2YWx1ZT8uX2Vycm9yO1xufVxudmFyIGJsb2NrZXJJZCA9IDA7XG5mdW5jdGlvbiB1c2VCbG9ja2VyKHNob3VsZEJsb2NrKSB7XG4gIGxldCB7IHJvdXRlciwgYmFzZW5hbWUgfSA9IHVzZURhdGFSb3V0ZXJDb250ZXh0KFwidXNlQmxvY2tlclwiIC8qIFVzZUJsb2NrZXIgKi8pO1xuICBsZXQgc3RhdGUgPSB1c2VEYXRhUm91dGVyU3RhdGUoXCJ1c2VCbG9ja2VyXCIgLyogVXNlQmxvY2tlciAqLyk7XG4gIGxldCBbYmxvY2tlcktleSwgc2V0QmxvY2tlcktleV0gPSBSZWFjdDIudXNlU3RhdGUoXCJcIik7XG4gIGxldCBibG9ja2VyRnVuY3Rpb24gPSBSZWFjdDIudXNlQ2FsbGJhY2soXG4gICAgKGFyZykgPT4ge1xuICAgICAgaWYgKHR5cGVvZiBzaG91bGRCbG9jayAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIHJldHVybiAhIXNob3VsZEJsb2NrO1xuICAgICAgfVxuICAgICAgaWYgKGJhc2VuYW1lID09PSBcIi9cIikge1xuICAgICAgICByZXR1cm4gc2hvdWxkQmxvY2soYXJnKTtcbiAgICAgIH1cbiAgICAgIGxldCB7IGN1cnJlbnRMb2NhdGlvbiwgbmV4dExvY2F0aW9uLCBoaXN0b3J5QWN0aW9uIH0gPSBhcmc7XG4gICAgICByZXR1cm4gc2hvdWxkQmxvY2soe1xuICAgICAgICBjdXJyZW50TG9jYXRpb246IHtcbiAgICAgICAgICAuLi5jdXJyZW50TG9jYXRpb24sXG4gICAgICAgICAgcGF0aG5hbWU6IHN0cmlwQmFzZW5hbWUoY3VycmVudExvY2F0aW9uLnBhdGhuYW1lLCBiYXNlbmFtZSkgfHwgY3VycmVudExvY2F0aW9uLnBhdGhuYW1lXG4gICAgICAgIH0sXG4gICAgICAgIG5leHRMb2NhdGlvbjoge1xuICAgICAgICAgIC4uLm5leHRMb2NhdGlvbixcbiAgICAgICAgICBwYXRobmFtZTogc3RyaXBCYXNlbmFtZShuZXh0TG9jYXRpb24ucGF0aG5hbWUsIGJhc2VuYW1lKSB8fCBuZXh0TG9jYXRpb24ucGF0aG5hbWVcbiAgICAgICAgfSxcbiAgICAgICAgaGlzdG9yeUFjdGlvblxuICAgICAgfSk7XG4gICAgfSxcbiAgICBbYmFzZW5hbWUsIHNob3VsZEJsb2NrXVxuICApO1xuICBSZWFjdDIudXNlRWZmZWN0KCgpID0+IHtcbiAgICBsZXQga2V5ID0gU3RyaW5nKCsrYmxvY2tlcklkKTtcbiAgICBzZXRCbG9ja2VyS2V5KGtleSk7XG4gICAgcmV0dXJuICgpID0+IHJvdXRlci5kZWxldGVCbG9ja2VyKGtleSk7XG4gIH0sIFtyb3V0ZXJdKTtcbiAgUmVhY3QyLnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKGJsb2NrZXJLZXkgIT09IFwiXCIpIHtcbiAgICAgIHJvdXRlci5nZXRCbG9ja2VyKGJsb2NrZXJLZXksIGJsb2NrZXJGdW5jdGlvbik7XG4gICAgfVxuICB9LCBbcm91dGVyLCBibG9ja2VyS2V5LCBibG9ja2VyRnVuY3Rpb25dKTtcbiAgcmV0dXJuIGJsb2NrZXJLZXkgJiYgc3RhdGUuYmxvY2tlcnMuaGFzKGJsb2NrZXJLZXkpID8gc3RhdGUuYmxvY2tlcnMuZ2V0KGJsb2NrZXJLZXkpIDogSURMRV9CTE9DS0VSO1xufVxuZnVuY3Rpb24gdXNlTmF2aWdhdGVTdGFibGUoKSB7XG4gIGxldCB7IHJvdXRlciB9ID0gdXNlRGF0YVJvdXRlckNvbnRleHQoXCJ1c2VOYXZpZ2F0ZVwiIC8qIFVzZU5hdmlnYXRlU3RhYmxlICovKTtcbiAgbGV0IGlkID0gdXNlQ3VycmVudFJvdXRlSWQoXCJ1c2VOYXZpZ2F0ZVwiIC8qIFVzZU5hdmlnYXRlU3RhYmxlICovKTtcbiAgbGV0IGFjdGl2ZVJlZiA9IFJlYWN0Mi51c2VSZWYoZmFsc2UpO1xuICB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0KCgpID0+IHtcbiAgICBhY3RpdmVSZWYuY3VycmVudCA9IHRydWU7XG4gIH0pO1xuICBsZXQgbmF2aWdhdGUgPSBSZWFjdDIudXNlQ2FsbGJhY2soXG4gICAgYXN5bmMgKHRvLCBvcHRpb25zID0ge30pID0+IHtcbiAgICAgIHdhcm5pbmcoYWN0aXZlUmVmLmN1cnJlbnQsIG5hdmlnYXRlRWZmZWN0V2FybmluZyk7XG4gICAgICBpZiAoIWFjdGl2ZVJlZi5jdXJyZW50KSByZXR1cm47XG4gICAgICBpZiAodHlwZW9mIHRvID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgIHJvdXRlci5uYXZpZ2F0ZSh0byk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhd2FpdCByb3V0ZXIubmF2aWdhdGUodG8sIHsgZnJvbVJvdXRlSWQ6IGlkLCAuLi5vcHRpb25zIH0pO1xuICAgICAgfVxuICAgIH0sXG4gICAgW3JvdXRlciwgaWRdXG4gICk7XG4gIHJldHVybiBuYXZpZ2F0ZTtcbn1cbnZhciBhbHJlYWR5V2FybmVkID0ge307XG5mdW5jdGlvbiB3YXJuaW5nT25jZShrZXksIGNvbmQsIG1lc3NhZ2UpIHtcbiAgaWYgKCFjb25kICYmICFhbHJlYWR5V2FybmVkW2tleV0pIHtcbiAgICBhbHJlYWR5V2FybmVkW2tleV0gPSB0cnVlO1xuICAgIHdhcm5pbmcoZmFsc2UsIG1lc3NhZ2UpO1xuICB9XG59XG5cbi8vIGxpYi9zZXJ2ZXItcnVudGltZS93YXJuaW5ncy50c1xudmFyIGFscmVhZHlXYXJuZWQyID0ge307XG5mdW5jdGlvbiB3YXJuT25jZShjb25kaXRpb24sIG1lc3NhZ2UpIHtcbiAgaWYgKCFjb25kaXRpb24gJiYgIWFscmVhZHlXYXJuZWQyW21lc3NhZ2VdKSB7XG4gICAgYWxyZWFkeVdhcm5lZDJbbWVzc2FnZV0gPSB0cnVlO1xuICAgIGNvbnNvbGUud2FybihtZXNzYWdlKTtcbiAgfVxufVxuXG4vLyBsaWIvY29tcG9uZW50cy50c3hcbnZhciBFTkFCTEVfREVWX1dBUk5JTkdTMiA9IHRydWU7XG5mdW5jdGlvbiBtYXBSb3V0ZVByb3BlcnRpZXMocm91dGUpIHtcbiAgbGV0IHVwZGF0ZXMgPSB7XG4gICAgLy8gTm90ZTogdGhpcyBjaGVjayBhbHNvIG9jY3VycyBpbiBjcmVhdGVSb3V0ZXNGcm9tQ2hpbGRyZW4gc28gdXBkYXRlXG4gICAgLy8gdGhlcmUgaWYgeW91IGNoYW5nZSB0aGlzIC0tIHBsZWFzZSBhbmQgdGhhbmsgeW91IVxuICAgIGhhc0Vycm9yQm91bmRhcnk6IHJvdXRlLmhhc0Vycm9yQm91bmRhcnkgfHwgcm91dGUuRXJyb3JCb3VuZGFyeSAhPSBudWxsIHx8IHJvdXRlLmVycm9yRWxlbWVudCAhPSBudWxsXG4gIH07XG4gIGlmIChyb3V0ZS5Db21wb25lbnQpIHtcbiAgICBpZiAoRU5BQkxFX0RFVl9XQVJOSU5HUzIpIHtcbiAgICAgIGlmIChyb3V0ZS5lbGVtZW50KSB7XG4gICAgICAgIHdhcm5pbmcoXG4gICAgICAgICAgZmFsc2UsXG4gICAgICAgICAgXCJZb3Ugc2hvdWxkIG5vdCBpbmNsdWRlIGJvdGggYENvbXBvbmVudGAgYW5kIGBlbGVtZW50YCBvbiB5b3VyIHJvdXRlIC0gYENvbXBvbmVudGAgd2lsbCBiZSB1c2VkLlwiXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICAgIE9iamVjdC5hc3NpZ24odXBkYXRlcywge1xuICAgICAgZWxlbWVudDogUmVhY3QzLmNyZWF0ZUVsZW1lbnQocm91dGUuQ29tcG9uZW50KSxcbiAgICAgIENvbXBvbmVudDogdm9pZCAwXG4gICAgfSk7XG4gIH1cbiAgaWYgKHJvdXRlLkh5ZHJhdGVGYWxsYmFjaykge1xuICAgIGlmIChFTkFCTEVfREVWX1dBUk5JTkdTMikge1xuICAgICAgaWYgKHJvdXRlLmh5ZHJhdGVGYWxsYmFja0VsZW1lbnQpIHtcbiAgICAgICAgd2FybmluZyhcbiAgICAgICAgICBmYWxzZSxcbiAgICAgICAgICBcIllvdSBzaG91bGQgbm90IGluY2x1ZGUgYm90aCBgSHlkcmF0ZUZhbGxiYWNrYCBhbmQgYGh5ZHJhdGVGYWxsYmFja0VsZW1lbnRgIG9uIHlvdXIgcm91dGUgLSBgSHlkcmF0ZUZhbGxiYWNrYCB3aWxsIGJlIHVzZWQuXCJcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gICAgT2JqZWN0LmFzc2lnbih1cGRhdGVzLCB7XG4gICAgICBoeWRyYXRlRmFsbGJhY2tFbGVtZW50OiBSZWFjdDMuY3JlYXRlRWxlbWVudChyb3V0ZS5IeWRyYXRlRmFsbGJhY2spLFxuICAgICAgSHlkcmF0ZUZhbGxiYWNrOiB2b2lkIDBcbiAgICB9KTtcbiAgfVxuICBpZiAocm91dGUuRXJyb3JCb3VuZGFyeSkge1xuICAgIGlmIChFTkFCTEVfREVWX1dBUk5JTkdTMikge1xuICAgICAgaWYgKHJvdXRlLmVycm9yRWxlbWVudCkge1xuICAgICAgICB3YXJuaW5nKFxuICAgICAgICAgIGZhbHNlLFxuICAgICAgICAgIFwiWW91IHNob3VsZCBub3QgaW5jbHVkZSBib3RoIGBFcnJvckJvdW5kYXJ5YCBhbmQgYGVycm9yRWxlbWVudGAgb24geW91ciByb3V0ZSAtIGBFcnJvckJvdW5kYXJ5YCB3aWxsIGJlIHVzZWQuXCJcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gICAgT2JqZWN0LmFzc2lnbih1cGRhdGVzLCB7XG4gICAgICBlcnJvckVsZW1lbnQ6IFJlYWN0My5jcmVhdGVFbGVtZW50KHJvdXRlLkVycm9yQm91bmRhcnkpLFxuICAgICAgRXJyb3JCb3VuZGFyeTogdm9pZCAwXG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIHVwZGF0ZXM7XG59XG5mdW5jdGlvbiBjcmVhdGVNZW1vcnlSb3V0ZXIocm91dGVzLCBvcHRzKSB7XG4gIHJldHVybiBjcmVhdGVSb3V0ZXIoe1xuICAgIGJhc2VuYW1lOiBvcHRzPy5iYXNlbmFtZSxcbiAgICBmdXR1cmU6IG9wdHM/LmZ1dHVyZSxcbiAgICBoaXN0b3J5OiBjcmVhdGVNZW1vcnlIaXN0b3J5KHtcbiAgICAgIGluaXRpYWxFbnRyaWVzOiBvcHRzPy5pbml0aWFsRW50cmllcyxcbiAgICAgIGluaXRpYWxJbmRleDogb3B0cz8uaW5pdGlhbEluZGV4XG4gICAgfSksXG4gICAgaHlkcmF0aW9uRGF0YTogb3B0cz8uaHlkcmF0aW9uRGF0YSxcbiAgICByb3V0ZXMsXG4gICAgbWFwUm91dGVQcm9wZXJ0aWVzLFxuICAgIGRhdGFTdHJhdGVneTogb3B0cz8uZGF0YVN0cmF0ZWd5LFxuICAgIHBhdGNoUm91dGVzT25OYXZpZ2F0aW9uOiBvcHRzPy5wYXRjaFJvdXRlc09uTmF2aWdhdGlvblxuICB9KS5pbml0aWFsaXplKCk7XG59XG52YXIgRGVmZXJyZWQgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuc3RhdHVzID0gXCJwZW5kaW5nXCI7XG4gICAgdGhpcy5wcm9taXNlID0gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgdGhpcy5yZXNvbHZlID0gKHZhbHVlKSA9PiB7XG4gICAgICAgIGlmICh0aGlzLnN0YXR1cyA9PT0gXCJwZW5kaW5nXCIpIHtcbiAgICAgICAgICB0aGlzLnN0YXR1cyA9IFwicmVzb2x2ZWRcIjtcbiAgICAgICAgICByZXNvbHZlKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIHRoaXMucmVqZWN0ID0gKHJlYXNvbikgPT4ge1xuICAgICAgICBpZiAodGhpcy5zdGF0dXMgPT09IFwicGVuZGluZ1wiKSB7XG4gICAgICAgICAgdGhpcy5zdGF0dXMgPSBcInJlamVjdGVkXCI7XG4gICAgICAgICAgcmVqZWN0KHJlYXNvbik7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfSk7XG4gIH1cbn07XG5mdW5jdGlvbiBSb3V0ZXJQcm92aWRlcih7XG4gIHJvdXRlcixcbiAgZmx1c2hTeW5jOiByZWFjdERvbUZsdXNoU3luY0ltcGxcbn0pIHtcbiAgbGV0IFtzdGF0ZSwgc2V0U3RhdGVJbXBsXSA9IFJlYWN0My51c2VTdGF0ZShyb3V0ZXIuc3RhdGUpO1xuICBsZXQgW3BlbmRpbmdTdGF0ZSwgc2V0UGVuZGluZ1N0YXRlXSA9IFJlYWN0My51c2VTdGF0ZSgpO1xuICBsZXQgW3Z0Q29udGV4dCwgc2V0VnRDb250ZXh0XSA9IFJlYWN0My51c2VTdGF0ZSh7XG4gICAgaXNUcmFuc2l0aW9uaW5nOiBmYWxzZVxuICB9KTtcbiAgbGV0IFtyZW5kZXJEZmQsIHNldFJlbmRlckRmZF0gPSBSZWFjdDMudXNlU3RhdGUoKTtcbiAgbGV0IFt0cmFuc2l0aW9uLCBzZXRUcmFuc2l0aW9uXSA9IFJlYWN0My51c2VTdGF0ZSgpO1xuICBsZXQgW2ludGVycnVwdGlvbiwgc2V0SW50ZXJydXB0aW9uXSA9IFJlYWN0My51c2VTdGF0ZSgpO1xuICBsZXQgZmV0Y2hlckRhdGEgPSBSZWFjdDMudXNlUmVmKC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCkpO1xuICBsZXQgc2V0U3RhdGUgPSBSZWFjdDMudXNlQ2FsbGJhY2soXG4gICAgKG5ld1N0YXRlLCB7IGRlbGV0ZWRGZXRjaGVycywgZmx1c2hTeW5jLCB2aWV3VHJhbnNpdGlvbk9wdHMgfSkgPT4ge1xuICAgICAgZGVsZXRlZEZldGNoZXJzLmZvckVhY2goKGtleSkgPT4gZmV0Y2hlckRhdGEuY3VycmVudC5kZWxldGUoa2V5KSk7XG4gICAgICBuZXdTdGF0ZS5mZXRjaGVycy5mb3JFYWNoKChmZXRjaGVyLCBrZXkpID0+IHtcbiAgICAgICAgaWYgKGZldGNoZXIuZGF0YSAhPT0gdm9pZCAwKSB7XG4gICAgICAgICAgZmV0Y2hlckRhdGEuY3VycmVudC5zZXQoa2V5LCBmZXRjaGVyLmRhdGEpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHdhcm5PbmNlKFxuICAgICAgICBmbHVzaFN5bmMgPT09IGZhbHNlIHx8IHJlYWN0RG9tRmx1c2hTeW5jSW1wbCAhPSBudWxsLFxuICAgICAgICAnWW91IHByb3ZpZGVkIHRoZSBgZmx1c2hTeW5jYCBvcHRpb24gdG8gYSByb3V0ZXIgdXBkYXRlLCBidXQgeW91IGFyZSBub3QgdXNpbmcgdGhlIGA8Um91dGVyUHJvdmlkZXI+YCBmcm9tIGByZWFjdC1yb3V0ZXIvZG9tYCBzbyBgUmVhY3RET00uZmx1c2hTeW5jKClgIGlzIHVuYXZhaWxhYmxlLiAgUGxlYXNlIHVwZGF0ZSB5b3VyIGFwcCB0byBgaW1wb3J0IHsgUm91dGVyUHJvdmlkZXIgfSBmcm9tIFwicmVhY3Qtcm91dGVyL2RvbVwiYCBhbmQgZW5zdXJlIHlvdSBoYXZlIGByZWFjdC1kb21gIGluc3RhbGxlZCBhcyBhIGRlcGVuZGVuY3kgdG8gdXNlIHRoZSBgZmx1c2hTeW5jYCBvcHRpb24uJ1xuICAgICAgKTtcbiAgICAgIGxldCBpc1ZpZXdUcmFuc2l0aW9uQXZhaWxhYmxlID0gcm91dGVyLndpbmRvdyAhPSBudWxsICYmIHJvdXRlci53aW5kb3cuZG9jdW1lbnQgIT0gbnVsbCAmJiB0eXBlb2Ygcm91dGVyLndpbmRvdy5kb2N1bWVudC5zdGFydFZpZXdUcmFuc2l0aW9uID09PSBcImZ1bmN0aW9uXCI7XG4gICAgICB3YXJuT25jZShcbiAgICAgICAgdmlld1RyYW5zaXRpb25PcHRzID09IG51bGwgfHwgaXNWaWV3VHJhbnNpdGlvbkF2YWlsYWJsZSxcbiAgICAgICAgXCJZb3UgcHJvdmlkZWQgdGhlIGB2aWV3VHJhbnNpdGlvbmAgb3B0aW9uIHRvIGEgcm91dGVyIHVwZGF0ZSwgYnV0IHlvdSBkbyBub3QgYXBwZWFyIHRvIGJlIHJ1bm5pbmcgaW4gYSBET00gZW52aXJvbm1lbnQgYXMgYHdpbmRvdy5zdGFydFZpZXdUcmFuc2l0aW9uYCBpcyBub3QgYXZhaWxhYmxlLlwiXG4gICAgICApO1xuICAgICAgaWYgKCF2aWV3VHJhbnNpdGlvbk9wdHMgfHwgIWlzVmlld1RyYW5zaXRpb25BdmFpbGFibGUpIHtcbiAgICAgICAgaWYgKHJlYWN0RG9tRmx1c2hTeW5jSW1wbCAmJiBmbHVzaFN5bmMpIHtcbiAgICAgICAgICByZWFjdERvbUZsdXNoU3luY0ltcGwoKCkgPT4gc2V0U3RhdGVJbXBsKG5ld1N0YXRlKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgUmVhY3QzLnN0YXJ0VHJhbnNpdGlvbigoKSA9PiBzZXRTdGF0ZUltcGwobmV3U3RhdGUpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAocmVhY3REb21GbHVzaFN5bmNJbXBsICYmIGZsdXNoU3luYykge1xuICAgICAgICByZWFjdERvbUZsdXNoU3luY0ltcGwoKCkgPT4ge1xuICAgICAgICAgIGlmICh0cmFuc2l0aW9uKSB7XG4gICAgICAgICAgICByZW5kZXJEZmQgJiYgcmVuZGVyRGZkLnJlc29sdmUoKTtcbiAgICAgICAgICAgIHRyYW5zaXRpb24uc2tpcFRyYW5zaXRpb24oKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgc2V0VnRDb250ZXh0KHtcbiAgICAgICAgICAgIGlzVHJhbnNpdGlvbmluZzogdHJ1ZSxcbiAgICAgICAgICAgIGZsdXNoU3luYzogdHJ1ZSxcbiAgICAgICAgICAgIGN1cnJlbnRMb2NhdGlvbjogdmlld1RyYW5zaXRpb25PcHRzLmN1cnJlbnRMb2NhdGlvbixcbiAgICAgICAgICAgIG5leHRMb2NhdGlvbjogdmlld1RyYW5zaXRpb25PcHRzLm5leHRMb2NhdGlvblxuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgbGV0IHQgPSByb3V0ZXIud2luZG93LmRvY3VtZW50LnN0YXJ0Vmlld1RyYW5zaXRpb24oKCkgPT4ge1xuICAgICAgICAgIHJlYWN0RG9tRmx1c2hTeW5jSW1wbCgoKSA9PiBzZXRTdGF0ZUltcGwobmV3U3RhdGUpKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHQuZmluaXNoZWQuZmluYWxseSgoKSA9PiB7XG4gICAgICAgICAgcmVhY3REb21GbHVzaFN5bmNJbXBsKCgpID0+IHtcbiAgICAgICAgICAgIHNldFJlbmRlckRmZCh2b2lkIDApO1xuICAgICAgICAgICAgc2V0VHJhbnNpdGlvbih2b2lkIDApO1xuICAgICAgICAgICAgc2V0UGVuZGluZ1N0YXRlKHZvaWQgMCk7XG4gICAgICAgICAgICBzZXRWdENvbnRleHQoeyBpc1RyYW5zaXRpb25pbmc6IGZhbHNlIH0pO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgcmVhY3REb21GbHVzaFN5bmNJbXBsKCgpID0+IHNldFRyYW5zaXRpb24odCkpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAodHJhbnNpdGlvbikge1xuICAgICAgICByZW5kZXJEZmQgJiYgcmVuZGVyRGZkLnJlc29sdmUoKTtcbiAgICAgICAgdHJhbnNpdGlvbi5za2lwVHJhbnNpdGlvbigpO1xuICAgICAgICBzZXRJbnRlcnJ1cHRpb24oe1xuICAgICAgICAgIHN0YXRlOiBuZXdTdGF0ZSxcbiAgICAgICAgICBjdXJyZW50TG9jYXRpb246IHZpZXdUcmFuc2l0aW9uT3B0cy5jdXJyZW50TG9jYXRpb24sXG4gICAgICAgICAgbmV4dExvY2F0aW9uOiB2aWV3VHJhbnNpdGlvbk9wdHMubmV4dExvY2F0aW9uXG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2V0UGVuZGluZ1N0YXRlKG5ld1N0YXRlKTtcbiAgICAgICAgc2V0VnRDb250ZXh0KHtcbiAgICAgICAgICBpc1RyYW5zaXRpb25pbmc6IHRydWUsXG4gICAgICAgICAgZmx1c2hTeW5jOiBmYWxzZSxcbiAgICAgICAgICBjdXJyZW50TG9jYXRpb246IHZpZXdUcmFuc2l0aW9uT3B0cy5jdXJyZW50TG9jYXRpb24sXG4gICAgICAgICAgbmV4dExvY2F0aW9uOiB2aWV3VHJhbnNpdGlvbk9wdHMubmV4dExvY2F0aW9uXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0sXG4gICAgW3JvdXRlci53aW5kb3csIHJlYWN0RG9tRmx1c2hTeW5jSW1wbCwgdHJhbnNpdGlvbiwgcmVuZGVyRGZkXVxuICApO1xuICBSZWFjdDMudXNlTGF5b3V0RWZmZWN0KCgpID0+IHJvdXRlci5zdWJzY3JpYmUoc2V0U3RhdGUpLCBbcm91dGVyLCBzZXRTdGF0ZV0pO1xuICBSZWFjdDMudXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAodnRDb250ZXh0LmlzVHJhbnNpdGlvbmluZyAmJiAhdnRDb250ZXh0LmZsdXNoU3luYykge1xuICAgICAgc2V0UmVuZGVyRGZkKG5ldyBEZWZlcnJlZCgpKTtcbiAgICB9XG4gIH0sIFt2dENvbnRleHRdKTtcbiAgUmVhY3QzLnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKHJlbmRlckRmZCAmJiBwZW5kaW5nU3RhdGUgJiYgcm91dGVyLndpbmRvdykge1xuICAgICAgbGV0IG5ld1N0YXRlID0gcGVuZGluZ1N0YXRlO1xuICAgICAgbGV0IHJlbmRlclByb21pc2UgPSByZW5kZXJEZmQucHJvbWlzZTtcbiAgICAgIGxldCB0cmFuc2l0aW9uMiA9IHJvdXRlci53aW5kb3cuZG9jdW1lbnQuc3RhcnRWaWV3VHJhbnNpdGlvbihhc3luYyAoKSA9PiB7XG4gICAgICAgIFJlYWN0My5zdGFydFRyYW5zaXRpb24oKCkgPT4gc2V0U3RhdGVJbXBsKG5ld1N0YXRlKSk7XG4gICAgICAgIGF3YWl0IHJlbmRlclByb21pc2U7XG4gICAgICB9KTtcbiAgICAgIHRyYW5zaXRpb24yLmZpbmlzaGVkLmZpbmFsbHkoKCkgPT4ge1xuICAgICAgICBzZXRSZW5kZXJEZmQodm9pZCAwKTtcbiAgICAgICAgc2V0VHJhbnNpdGlvbih2b2lkIDApO1xuICAgICAgICBzZXRQZW5kaW5nU3RhdGUodm9pZCAwKTtcbiAgICAgICAgc2V0VnRDb250ZXh0KHsgaXNUcmFuc2l0aW9uaW5nOiBmYWxzZSB9KTtcbiAgICAgIH0pO1xuICAgICAgc2V0VHJhbnNpdGlvbih0cmFuc2l0aW9uMik7XG4gICAgfVxuICB9LCBbcGVuZGluZ1N0YXRlLCByZW5kZXJEZmQsIHJvdXRlci53aW5kb3ddKTtcbiAgUmVhY3QzLnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKHJlbmRlckRmZCAmJiBwZW5kaW5nU3RhdGUgJiYgc3RhdGUubG9jYXRpb24ua2V5ID09PSBwZW5kaW5nU3RhdGUubG9jYXRpb24ua2V5KSB7XG4gICAgICByZW5kZXJEZmQucmVzb2x2ZSgpO1xuICAgIH1cbiAgfSwgW3JlbmRlckRmZCwgdHJhbnNpdGlvbiwgc3RhdGUubG9jYXRpb24sIHBlbmRpbmdTdGF0ZV0pO1xuICBSZWFjdDMudXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAoIXZ0Q29udGV4dC5pc1RyYW5zaXRpb25pbmcgJiYgaW50ZXJydXB0aW9uKSB7XG4gICAgICBzZXRQZW5kaW5nU3RhdGUoaW50ZXJydXB0aW9uLnN0YXRlKTtcbiAgICAgIHNldFZ0Q29udGV4dCh7XG4gICAgICAgIGlzVHJhbnNpdGlvbmluZzogdHJ1ZSxcbiAgICAgICAgZmx1c2hTeW5jOiBmYWxzZSxcbiAgICAgICAgY3VycmVudExvY2F0aW9uOiBpbnRlcnJ1cHRpb24uY3VycmVudExvY2F0aW9uLFxuICAgICAgICBuZXh0TG9jYXRpb246IGludGVycnVwdGlvbi5uZXh0TG9jYXRpb25cbiAgICAgIH0pO1xuICAgICAgc2V0SW50ZXJydXB0aW9uKHZvaWQgMCk7XG4gICAgfVxuICB9LCBbdnRDb250ZXh0LmlzVHJhbnNpdGlvbmluZywgaW50ZXJydXB0aW9uXSk7XG4gIGxldCBuYXZpZ2F0b3IyID0gUmVhY3QzLnVzZU1lbW8oKCkgPT4ge1xuICAgIHJldHVybiB7XG4gICAgICBjcmVhdGVIcmVmOiByb3V0ZXIuY3JlYXRlSHJlZixcbiAgICAgIGVuY29kZUxvY2F0aW9uOiByb3V0ZXIuZW5jb2RlTG9jYXRpb24sXG4gICAgICBnbzogKG4pID0+IHJvdXRlci5uYXZpZ2F0ZShuKSxcbiAgICAgIHB1c2g6ICh0bywgc3RhdGUyLCBvcHRzKSA9PiByb3V0ZXIubmF2aWdhdGUodG8sIHtcbiAgICAgICAgc3RhdGU6IHN0YXRlMixcbiAgICAgICAgcHJldmVudFNjcm9sbFJlc2V0OiBvcHRzPy5wcmV2ZW50U2Nyb2xsUmVzZXRcbiAgICAgIH0pLFxuICAgICAgcmVwbGFjZTogKHRvLCBzdGF0ZTIsIG9wdHMpID0+IHJvdXRlci5uYXZpZ2F0ZSh0bywge1xuICAgICAgICByZXBsYWNlOiB0cnVlLFxuICAgICAgICBzdGF0ZTogc3RhdGUyLFxuICAgICAgICBwcmV2ZW50U2Nyb2xsUmVzZXQ6IG9wdHM/LnByZXZlbnRTY3JvbGxSZXNldFxuICAgICAgfSlcbiAgICB9O1xuICB9LCBbcm91dGVyXSk7XG4gIGxldCBiYXNlbmFtZSA9IHJvdXRlci5iYXNlbmFtZSB8fCBcIi9cIjtcbiAgbGV0IGRhdGFSb3V0ZXJDb250ZXh0ID0gUmVhY3QzLnVzZU1lbW8oXG4gICAgKCkgPT4gKHtcbiAgICAgIHJvdXRlcixcbiAgICAgIG5hdmlnYXRvcjogbmF2aWdhdG9yMixcbiAgICAgIHN0YXRpYzogZmFsc2UsXG4gICAgICBiYXNlbmFtZVxuICAgIH0pLFxuICAgIFtyb3V0ZXIsIG5hdmlnYXRvcjIsIGJhc2VuYW1lXVxuICApO1xuICByZXR1cm4gLyogQF9fUFVSRV9fICovIFJlYWN0My5jcmVhdGVFbGVtZW50KFJlYWN0My5GcmFnbWVudCwgbnVsbCwgLyogQF9fUFVSRV9fICovIFJlYWN0My5jcmVhdGVFbGVtZW50KERhdGFSb3V0ZXJDb250ZXh0LlByb3ZpZGVyLCB7IHZhbHVlOiBkYXRhUm91dGVyQ29udGV4dCB9LCAvKiBAX19QVVJFX18gKi8gUmVhY3QzLmNyZWF0ZUVsZW1lbnQoRGF0YVJvdXRlclN0YXRlQ29udGV4dC5Qcm92aWRlciwgeyB2YWx1ZTogc3RhdGUgfSwgLyogQF9fUFVSRV9fICovIFJlYWN0My5jcmVhdGVFbGVtZW50KEZldGNoZXJzQ29udGV4dC5Qcm92aWRlciwgeyB2YWx1ZTogZmV0Y2hlckRhdGEuY3VycmVudCB9LCAvKiBAX19QVVJFX18gKi8gUmVhY3QzLmNyZWF0ZUVsZW1lbnQoVmlld1RyYW5zaXRpb25Db250ZXh0LlByb3ZpZGVyLCB7IHZhbHVlOiB2dENvbnRleHQgfSwgLyogQF9fUFVSRV9fICovIFJlYWN0My5jcmVhdGVFbGVtZW50KFxuICAgIFJvdXRlcixcbiAgICB7XG4gICAgICBiYXNlbmFtZSxcbiAgICAgIGxvY2F0aW9uOiBzdGF0ZS5sb2NhdGlvbixcbiAgICAgIG5hdmlnYXRpb25UeXBlOiBzdGF0ZS5oaXN0b3J5QWN0aW9uLFxuICAgICAgbmF2aWdhdG9yOiBuYXZpZ2F0b3IyXG4gICAgfSxcbiAgICAvKiBAX19QVVJFX18gKi8gUmVhY3QzLmNyZWF0ZUVsZW1lbnQoXG4gICAgICBNZW1vaXplZERhdGFSb3V0ZXMsXG4gICAgICB7XG4gICAgICAgIHJvdXRlczogcm91dGVyLnJvdXRlcyxcbiAgICAgICAgZnV0dXJlOiByb3V0ZXIuZnV0dXJlLFxuICAgICAgICBzdGF0ZVxuICAgICAgfVxuICAgIClcbiAgKSkpKSksIG51bGwpO1xufVxudmFyIE1lbW9pemVkRGF0YVJvdXRlcyA9IFJlYWN0My5tZW1vKERhdGFSb3V0ZXMpO1xuZnVuY3Rpb24gRGF0YVJvdXRlcyh7XG4gIHJvdXRlcyxcbiAgZnV0dXJlLFxuICBzdGF0ZVxufSkge1xuICByZXR1cm4gdXNlUm91dGVzSW1wbChyb3V0ZXMsIHZvaWQgMCwgc3RhdGUsIGZ1dHVyZSk7XG59XG5mdW5jdGlvbiBNZW1vcnlSb3V0ZXIoe1xuICBiYXNlbmFtZSxcbiAgY2hpbGRyZW4sXG4gIGluaXRpYWxFbnRyaWVzLFxuICBpbml0aWFsSW5kZXhcbn0pIHtcbiAgbGV0IGhpc3RvcnlSZWYgPSBSZWFjdDMudXNlUmVmKCk7XG4gIGlmIChoaXN0b3J5UmVmLmN1cnJlbnQgPT0gbnVsbCkge1xuICAgIGhpc3RvcnlSZWYuY3VycmVudCA9IGNyZWF0ZU1lbW9yeUhpc3Rvcnkoe1xuICAgICAgaW5pdGlhbEVudHJpZXMsXG4gICAgICBpbml0aWFsSW5kZXgsXG4gICAgICB2NUNvbXBhdDogdHJ1ZVxuICAgIH0pO1xuICB9XG4gIGxldCBoaXN0b3J5ID0gaGlzdG9yeVJlZi5jdXJyZW50O1xuICBsZXQgW3N0YXRlLCBzZXRTdGF0ZUltcGxdID0gUmVhY3QzLnVzZVN0YXRlKHtcbiAgICBhY3Rpb246IGhpc3RvcnkuYWN0aW9uLFxuICAgIGxvY2F0aW9uOiBoaXN0b3J5LmxvY2F0aW9uXG4gIH0pO1xuICBsZXQgc2V0U3RhdGUgPSBSZWFjdDMudXNlQ2FsbGJhY2soXG4gICAgKG5ld1N0YXRlKSA9PiB7XG4gICAgICBSZWFjdDMuc3RhcnRUcmFuc2l0aW9uKCgpID0+IHNldFN0YXRlSW1wbChuZXdTdGF0ZSkpO1xuICAgIH0sXG4gICAgW3NldFN0YXRlSW1wbF1cbiAgKTtcbiAgUmVhY3QzLnVzZUxheW91dEVmZmVjdCgoKSA9PiBoaXN0b3J5Lmxpc3RlbihzZXRTdGF0ZSksIFtoaXN0b3J5LCBzZXRTdGF0ZV0pO1xuICByZXR1cm4gLyogQF9fUFVSRV9fICovIFJlYWN0My5jcmVhdGVFbGVtZW50KFxuICAgIFJvdXRlcixcbiAgICB7XG4gICAgICBiYXNlbmFtZSxcbiAgICAgIGNoaWxkcmVuLFxuICAgICAgbG9jYXRpb246IHN0YXRlLmxvY2F0aW9uLFxuICAgICAgbmF2aWdhdGlvblR5cGU6IHN0YXRlLmFjdGlvbixcbiAgICAgIG5hdmlnYXRvcjogaGlzdG9yeVxuICAgIH1cbiAgKTtcbn1cbmZ1bmN0aW9uIE5hdmlnYXRlKHtcbiAgdG8sXG4gIHJlcGxhY2U6IHJlcGxhY2UyLFxuICBzdGF0ZSxcbiAgcmVsYXRpdmVcbn0pIHtcbiAgaW52YXJpYW50KFxuICAgIHVzZUluUm91dGVyQ29udGV4dCgpLFxuICAgIC8vIFRPRE86IFRoaXMgZXJyb3IgaXMgcHJvYmFibHkgYmVjYXVzZSB0aGV5IHNvbWVob3cgaGF2ZSAyIHZlcnNpb25zIG9mXG4gICAgLy8gdGhlIHJvdXRlciBsb2FkZWQuIFdlIGNhbiBoZWxwIHRoZW0gdW5kZXJzdGFuZCBob3cgdG8gYXZvaWQgdGhhdC5cbiAgICBgPE5hdmlnYXRlPiBtYXkgYmUgdXNlZCBvbmx5IGluIHRoZSBjb250ZXh0IG9mIGEgPFJvdXRlcj4gY29tcG9uZW50LmBcbiAgKTtcbiAgbGV0IHsgc3RhdGljOiBpc1N0YXRpYyB9ID0gUmVhY3QzLnVzZUNvbnRleHQoTmF2aWdhdGlvbkNvbnRleHQpO1xuICB3YXJuaW5nKFxuICAgICFpc1N0YXRpYyxcbiAgICBgPE5hdmlnYXRlPiBtdXN0IG5vdCBiZSB1c2VkIG9uIHRoZSBpbml0aWFsIHJlbmRlciBpbiBhIDxTdGF0aWNSb3V0ZXI+LiBUaGlzIGlzIGEgbm8tb3AsIGJ1dCB5b3Ugc2hvdWxkIG1vZGlmeSB5b3VyIGNvZGUgc28gdGhlIDxOYXZpZ2F0ZT4gaXMgb25seSBldmVyIHJlbmRlcmVkIGluIHJlc3BvbnNlIHRvIHNvbWUgdXNlciBpbnRlcmFjdGlvbiBvciBzdGF0ZSBjaGFuZ2UuYFxuICApO1xuICBsZXQgeyBtYXRjaGVzIH0gPSBSZWFjdDMudXNlQ29udGV4dChSb3V0ZUNvbnRleHQpO1xuICBsZXQgeyBwYXRobmFtZTogbG9jYXRpb25QYXRobmFtZSB9ID0gdXNlTG9jYXRpb24oKTtcbiAgbGV0IG5hdmlnYXRlID0gdXNlTmF2aWdhdGUoKTtcbiAgbGV0IHBhdGggPSByZXNvbHZlVG8oXG4gICAgdG8sXG4gICAgZ2V0UmVzb2x2ZVRvTWF0Y2hlcyhtYXRjaGVzKSxcbiAgICBsb2NhdGlvblBhdGhuYW1lLFxuICAgIHJlbGF0aXZlID09PSBcInBhdGhcIlxuICApO1xuICBsZXQganNvblBhdGggPSBKU09OLnN0cmluZ2lmeShwYXRoKTtcbiAgUmVhY3QzLnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgbmF2aWdhdGUoSlNPTi5wYXJzZShqc29uUGF0aCksIHsgcmVwbGFjZTogcmVwbGFjZTIsIHN0YXRlLCByZWxhdGl2ZSB9KTtcbiAgfSwgW25hdmlnYXRlLCBqc29uUGF0aCwgcmVsYXRpdmUsIHJlcGxhY2UyLCBzdGF0ZV0pO1xuICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIE91dGxldChwcm9wcykge1xuICByZXR1cm4gdXNlT3V0bGV0KHByb3BzLmNvbnRleHQpO1xufVxuZnVuY3Rpb24gUm91dGUoX3Byb3BzKSB7XG4gIGludmFyaWFudChcbiAgICBmYWxzZSxcbiAgICBgQSA8Um91dGU+IGlzIG9ubHkgZXZlciB0byBiZSB1c2VkIGFzIHRoZSBjaGlsZCBvZiA8Um91dGVzPiBlbGVtZW50LCBuZXZlciByZW5kZXJlZCBkaXJlY3RseS4gUGxlYXNlIHdyYXAgeW91ciA8Um91dGU+IGluIGEgPFJvdXRlcz4uYFxuICApO1xufVxuZnVuY3Rpb24gUm91dGVyKHtcbiAgYmFzZW5hbWU6IGJhc2VuYW1lUHJvcCA9IFwiL1wiLFxuICBjaGlsZHJlbiA9IG51bGwsXG4gIGxvY2F0aW9uOiBsb2NhdGlvblByb3AsXG4gIG5hdmlnYXRpb25UeXBlID0gXCJQT1BcIiAvKiBQb3AgKi8sXG4gIG5hdmlnYXRvcjogbmF2aWdhdG9yMixcbiAgc3RhdGljOiBzdGF0aWNQcm9wID0gZmFsc2Vcbn0pIHtcbiAgaW52YXJpYW50KFxuICAgICF1c2VJblJvdXRlckNvbnRleHQoKSxcbiAgICBgWW91IGNhbm5vdCByZW5kZXIgYSA8Um91dGVyPiBpbnNpZGUgYW5vdGhlciA8Um91dGVyPi4gWW91IHNob3VsZCBuZXZlciBoYXZlIG1vcmUgdGhhbiBvbmUgaW4geW91ciBhcHAuYFxuICApO1xuICBsZXQgYmFzZW5hbWUgPSBiYXNlbmFtZVByb3AucmVwbGFjZSgvXlxcLyovLCBcIi9cIik7XG4gIGxldCBuYXZpZ2F0aW9uQ29udGV4dCA9IFJlYWN0My51c2VNZW1vKFxuICAgICgpID0+ICh7XG4gICAgICBiYXNlbmFtZSxcbiAgICAgIG5hdmlnYXRvcjogbmF2aWdhdG9yMixcbiAgICAgIHN0YXRpYzogc3RhdGljUHJvcCxcbiAgICAgIGZ1dHVyZToge31cbiAgICB9KSxcbiAgICBbYmFzZW5hbWUsIG5hdmlnYXRvcjIsIHN0YXRpY1Byb3BdXG4gICk7XG4gIGlmICh0eXBlb2YgbG9jYXRpb25Qcm9wID09PSBcInN0cmluZ1wiKSB7XG4gICAgbG9jYXRpb25Qcm9wID0gcGFyc2VQYXRoKGxvY2F0aW9uUHJvcCk7XG4gIH1cbiAgbGV0IHtcbiAgICBwYXRobmFtZSA9IFwiL1wiLFxuICAgIHNlYXJjaCA9IFwiXCIsXG4gICAgaGFzaCA9IFwiXCIsXG4gICAgc3RhdGUgPSBudWxsLFxuICAgIGtleSA9IFwiZGVmYXVsdFwiXG4gIH0gPSBsb2NhdGlvblByb3A7XG4gIGxldCBsb2NhdGlvbkNvbnRleHQgPSBSZWFjdDMudXNlTWVtbygoKSA9PiB7XG4gICAgbGV0IHRyYWlsaW5nUGF0aG5hbWUgPSBzdHJpcEJhc2VuYW1lKHBhdGhuYW1lLCBiYXNlbmFtZSk7XG4gICAgaWYgKHRyYWlsaW5nUGF0aG5hbWUgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICBsb2NhdGlvbjoge1xuICAgICAgICBwYXRobmFtZTogdHJhaWxpbmdQYXRobmFtZSxcbiAgICAgICAgc2VhcmNoLFxuICAgICAgICBoYXNoLFxuICAgICAgICBzdGF0ZSxcbiAgICAgICAga2V5XG4gICAgICB9LFxuICAgICAgbmF2aWdhdGlvblR5cGVcbiAgICB9O1xuICB9LCBbYmFzZW5hbWUsIHBhdGhuYW1lLCBzZWFyY2gsIGhhc2gsIHN0YXRlLCBrZXksIG5hdmlnYXRpb25UeXBlXSk7XG4gIHdhcm5pbmcoXG4gICAgbG9jYXRpb25Db250ZXh0ICE9IG51bGwsXG4gICAgYDxSb3V0ZXIgYmFzZW5hbWU9XCIke2Jhc2VuYW1lfVwiPiBpcyBub3QgYWJsZSB0byBtYXRjaCB0aGUgVVJMIFwiJHtwYXRobmFtZX0ke3NlYXJjaH0ke2hhc2h9XCIgYmVjYXVzZSBpdCBkb2VzIG5vdCBzdGFydCB3aXRoIHRoZSBiYXNlbmFtZSwgc28gdGhlIDxSb3V0ZXI+IHdvbid0IHJlbmRlciBhbnl0aGluZy5gXG4gICk7XG4gIGlmIChsb2NhdGlvbkNvbnRleHQgPT0gbnVsbCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8gUmVhY3QzLmNyZWF0ZUVsZW1lbnQoTmF2aWdhdGlvbkNvbnRleHQuUHJvdmlkZXIsIHsgdmFsdWU6IG5hdmlnYXRpb25Db250ZXh0IH0sIC8qIEBfX1BVUkVfXyAqLyBSZWFjdDMuY3JlYXRlRWxlbWVudChMb2NhdGlvbkNvbnRleHQuUHJvdmlkZXIsIHsgY2hpbGRyZW4sIHZhbHVlOiBsb2NhdGlvbkNvbnRleHQgfSkpO1xufVxuZnVuY3Rpb24gUm91dGVzKHtcbiAgY2hpbGRyZW4sXG4gIGxvY2F0aW9uXG59KSB7XG4gIHJldHVybiB1c2VSb3V0ZXMoY3JlYXRlUm91dGVzRnJvbUNoaWxkcmVuKGNoaWxkcmVuKSwgbG9jYXRpb24pO1xufVxuZnVuY3Rpb24gQXdhaXQoe1xuICBjaGlsZHJlbixcbiAgZXJyb3JFbGVtZW50LFxuICByZXNvbHZlXG59KSB7XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8gUmVhY3QzLmNyZWF0ZUVsZW1lbnQoQXdhaXRFcnJvckJvdW5kYXJ5LCB7IHJlc29sdmUsIGVycm9yRWxlbWVudCB9LCAvKiBAX19QVVJFX18gKi8gUmVhY3QzLmNyZWF0ZUVsZW1lbnQoUmVzb2x2ZUF3YWl0LCBudWxsLCBjaGlsZHJlbikpO1xufVxudmFyIEF3YWl0RXJyb3JCb3VuZGFyeSA9IGNsYXNzIGV4dGVuZHMgUmVhY3QzLkNvbXBvbmVudCB7XG4gIGNvbnN0cnVjdG9yKHByb3BzKSB7XG4gICAgc3VwZXIocHJvcHMpO1xuICAgIHRoaXMuc3RhdGUgPSB7IGVycm9yOiBudWxsIH07XG4gIH1cbiAgc3RhdGljIGdldERlcml2ZWRTdGF0ZUZyb21FcnJvcihlcnJvcikge1xuICAgIHJldHVybiB7IGVycm9yIH07XG4gIH1cbiAgY29tcG9uZW50RGlkQ2F0Y2goZXJyb3IsIGVycm9ySW5mbykge1xuICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICBcIjxBd2FpdD4gY2F1Z2h0IHRoZSBmb2xsb3dpbmcgZXJyb3IgZHVyaW5nIHJlbmRlclwiLFxuICAgICAgZXJyb3IsXG4gICAgICBlcnJvckluZm9cbiAgICApO1xuICB9XG4gIHJlbmRlcigpIHtcbiAgICBsZXQgeyBjaGlsZHJlbiwgZXJyb3JFbGVtZW50LCByZXNvbHZlIH0gPSB0aGlzLnByb3BzO1xuICAgIGxldCBwcm9taXNlID0gbnVsbDtcbiAgICBsZXQgc3RhdHVzID0gMCAvKiBwZW5kaW5nICovO1xuICAgIGlmICghKHJlc29sdmUgaW5zdGFuY2VvZiBQcm9taXNlKSkge1xuICAgICAgc3RhdHVzID0gMSAvKiBzdWNjZXNzICovO1xuICAgICAgcHJvbWlzZSA9IFByb21pc2UucmVzb2x2ZSgpO1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHByb21pc2UsIFwiX3RyYWNrZWRcIiwgeyBnZXQ6ICgpID0+IHRydWUgfSk7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocHJvbWlzZSwgXCJfZGF0YVwiLCB7IGdldDogKCkgPT4gcmVzb2x2ZSB9KTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuc3RhdGUuZXJyb3IpIHtcbiAgICAgIHN0YXR1cyA9IDIgLyogZXJyb3IgKi87XG4gICAgICBsZXQgcmVuZGVyRXJyb3IgPSB0aGlzLnN0YXRlLmVycm9yO1xuICAgICAgcHJvbWlzZSA9IFByb21pc2UucmVqZWN0KCkuY2F0Y2goKCkgPT4ge1xuICAgICAgfSk7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocHJvbWlzZSwgXCJfdHJhY2tlZFwiLCB7IGdldDogKCkgPT4gdHJ1ZSB9KTtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShwcm9taXNlLCBcIl9lcnJvclwiLCB7IGdldDogKCkgPT4gcmVuZGVyRXJyb3IgfSk7XG4gICAgfSBlbHNlIGlmIChyZXNvbHZlLl90cmFja2VkKSB7XG4gICAgICBwcm9taXNlID0gcmVzb2x2ZTtcbiAgICAgIHN0YXR1cyA9IFwiX2Vycm9yXCIgaW4gcHJvbWlzZSA/IDIgLyogZXJyb3IgKi8gOiBcIl9kYXRhXCIgaW4gcHJvbWlzZSA/IDEgLyogc3VjY2VzcyAqLyA6IDAgLyogcGVuZGluZyAqLztcbiAgICB9IGVsc2Uge1xuICAgICAgc3RhdHVzID0gMCAvKiBwZW5kaW5nICovO1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHJlc29sdmUsIFwiX3RyYWNrZWRcIiwgeyBnZXQ6ICgpID0+IHRydWUgfSk7XG4gICAgICBwcm9taXNlID0gcmVzb2x2ZS50aGVuKFxuICAgICAgICAoZGF0YTIpID0+IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShyZXNvbHZlLCBcIl9kYXRhXCIsIHsgZ2V0OiAoKSA9PiBkYXRhMiB9KSxcbiAgICAgICAgKGVycm9yKSA9PiBPYmplY3QuZGVmaW5lUHJvcGVydHkocmVzb2x2ZSwgXCJfZXJyb3JcIiwgeyBnZXQ6ICgpID0+IGVycm9yIH0pXG4gICAgICApO1xuICAgIH1cbiAgICBpZiAoc3RhdHVzID09PSAyIC8qIGVycm9yICovICYmICFlcnJvckVsZW1lbnQpIHtcbiAgICAgIHRocm93IHByb21pc2UuX2Vycm9yO1xuICAgIH1cbiAgICBpZiAoc3RhdHVzID09PSAyIC8qIGVycm9yICovKSB7XG4gICAgICByZXR1cm4gLyogQF9fUFVSRV9fICovIFJlYWN0My5jcmVhdGVFbGVtZW50KEF3YWl0Q29udGV4dC5Qcm92aWRlciwgeyB2YWx1ZTogcHJvbWlzZSwgY2hpbGRyZW46IGVycm9yRWxlbWVudCB9KTtcbiAgICB9XG4gICAgaWYgKHN0YXR1cyA9PT0gMSAvKiBzdWNjZXNzICovKSB7XG4gICAgICByZXR1cm4gLyogQF9fUFVSRV9fICovIFJlYWN0My5jcmVhdGVFbGVtZW50KEF3YWl0Q29udGV4dC5Qcm92aWRlciwgeyB2YWx1ZTogcHJvbWlzZSwgY2hpbGRyZW4gfSk7XG4gICAgfVxuICAgIHRocm93IHByb21pc2U7XG4gIH1cbn07XG5mdW5jdGlvbiBSZXNvbHZlQXdhaXQoe1xuICBjaGlsZHJlblxufSkge1xuICBsZXQgZGF0YTIgPSB1c2VBc3luY1ZhbHVlKCk7XG4gIGxldCB0b1JlbmRlciA9IHR5cGVvZiBjaGlsZHJlbiA9PT0gXCJmdW5jdGlvblwiID8gY2hpbGRyZW4oZGF0YTIpIDogY2hpbGRyZW47XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8gUmVhY3QzLmNyZWF0ZUVsZW1lbnQoUmVhY3QzLkZyYWdtZW50LCBudWxsLCB0b1JlbmRlcik7XG59XG5mdW5jdGlvbiBjcmVhdGVSb3V0ZXNGcm9tQ2hpbGRyZW4oY2hpbGRyZW4sIHBhcmVudFBhdGggPSBbXSkge1xuICBsZXQgcm91dGVzID0gW107XG4gIFJlYWN0My5DaGlsZHJlbi5mb3JFYWNoKGNoaWxkcmVuLCAoZWxlbWVudCwgaW5kZXgpID0+IHtcbiAgICBpZiAoIVJlYWN0My5pc1ZhbGlkRWxlbWVudChlbGVtZW50KSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBsZXQgdHJlZVBhdGggPSBbLi4ucGFyZW50UGF0aCwgaW5kZXhdO1xuICAgIGlmIChlbGVtZW50LnR5cGUgPT09IFJlYWN0My5GcmFnbWVudCkge1xuICAgICAgcm91dGVzLnB1c2guYXBwbHkoXG4gICAgICAgIHJvdXRlcyxcbiAgICAgICAgY3JlYXRlUm91dGVzRnJvbUNoaWxkcmVuKGVsZW1lbnQucHJvcHMuY2hpbGRyZW4sIHRyZWVQYXRoKVxuICAgICAgKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaW52YXJpYW50KFxuICAgICAgZWxlbWVudC50eXBlID09PSBSb3V0ZSxcbiAgICAgIGBbJHt0eXBlb2YgZWxlbWVudC50eXBlID09PSBcInN0cmluZ1wiID8gZWxlbWVudC50eXBlIDogZWxlbWVudC50eXBlLm5hbWV9XSBpcyBub3QgYSA8Um91dGU+IGNvbXBvbmVudC4gQWxsIGNvbXBvbmVudCBjaGlsZHJlbiBvZiA8Um91dGVzPiBtdXN0IGJlIGEgPFJvdXRlPiBvciA8UmVhY3QuRnJhZ21lbnQ+YFxuICAgICk7XG4gICAgaW52YXJpYW50KFxuICAgICAgIWVsZW1lbnQucHJvcHMuaW5kZXggfHwgIWVsZW1lbnQucHJvcHMuY2hpbGRyZW4sXG4gICAgICBcIkFuIGluZGV4IHJvdXRlIGNhbm5vdCBoYXZlIGNoaWxkIHJvdXRlcy5cIlxuICAgICk7XG4gICAgbGV0IHJvdXRlID0ge1xuICAgICAgaWQ6IGVsZW1lbnQucHJvcHMuaWQgfHwgdHJlZVBhdGguam9pbihcIi1cIiksXG4gICAgICBjYXNlU2Vuc2l0aXZlOiBlbGVtZW50LnByb3BzLmNhc2VTZW5zaXRpdmUsXG4gICAgICBlbGVtZW50OiBlbGVtZW50LnByb3BzLmVsZW1lbnQsXG4gICAgICBDb21wb25lbnQ6IGVsZW1lbnQucHJvcHMuQ29tcG9uZW50LFxuICAgICAgaW5kZXg6IGVsZW1lbnQucHJvcHMuaW5kZXgsXG4gICAgICBwYXRoOiBlbGVtZW50LnByb3BzLnBhdGgsXG4gICAgICBsb2FkZXI6IGVsZW1lbnQucHJvcHMubG9hZGVyLFxuICAgICAgYWN0aW9uOiBlbGVtZW50LnByb3BzLmFjdGlvbixcbiAgICAgIGh5ZHJhdGVGYWxsYmFja0VsZW1lbnQ6IGVsZW1lbnQucHJvcHMuaHlkcmF0ZUZhbGxiYWNrRWxlbWVudCxcbiAgICAgIEh5ZHJhdGVGYWxsYmFjazogZWxlbWVudC5wcm9wcy5IeWRyYXRlRmFsbGJhY2ssXG4gICAgICBlcnJvckVsZW1lbnQ6IGVsZW1lbnQucHJvcHMuZXJyb3JFbGVtZW50LFxuICAgICAgRXJyb3JCb3VuZGFyeTogZWxlbWVudC5wcm9wcy5FcnJvckJvdW5kYXJ5LFxuICAgICAgaGFzRXJyb3JCb3VuZGFyeTogZWxlbWVudC5wcm9wcy5oYXNFcnJvckJvdW5kYXJ5ID09PSB0cnVlIHx8IGVsZW1lbnQucHJvcHMuRXJyb3JCb3VuZGFyeSAhPSBudWxsIHx8IGVsZW1lbnQucHJvcHMuZXJyb3JFbGVtZW50ICE9IG51bGwsXG4gICAgICBzaG91bGRSZXZhbGlkYXRlOiBlbGVtZW50LnByb3BzLnNob3VsZFJldmFsaWRhdGUsXG4gICAgICBoYW5kbGU6IGVsZW1lbnQucHJvcHMuaGFuZGxlLFxuICAgICAgbGF6eTogZWxlbWVudC5wcm9wcy5sYXp5XG4gICAgfTtcbiAgICBpZiAoZWxlbWVudC5wcm9wcy5jaGlsZHJlbikge1xuICAgICAgcm91dGUuY2hpbGRyZW4gPSBjcmVhdGVSb3V0ZXNGcm9tQ2hpbGRyZW4oXG4gICAgICAgIGVsZW1lbnQucHJvcHMuY2hpbGRyZW4sXG4gICAgICAgIHRyZWVQYXRoXG4gICAgICApO1xuICAgIH1cbiAgICByb3V0ZXMucHVzaChyb3V0ZSk7XG4gIH0pO1xuICByZXR1cm4gcm91dGVzO1xufVxudmFyIGNyZWF0ZVJvdXRlc0Zyb21FbGVtZW50cyA9IGNyZWF0ZVJvdXRlc0Zyb21DaGlsZHJlbjtcbmZ1bmN0aW9uIHJlbmRlck1hdGNoZXMobWF0Y2hlcykge1xuICByZXR1cm4gX3JlbmRlck1hdGNoZXMobWF0Y2hlcyk7XG59XG5cbi8vIGxpYi9kb20vbGliLnRzeFxudmFyIFJlYWN0MTAgPSBfX3RvRVNNKHJlcXVpcmUoXCJyZWFjdFwiKSk7XG5cbi8vIGxpYi9kb20vZG9tLnRzXG52YXIgZGVmYXVsdE1ldGhvZCA9IFwiZ2V0XCI7XG52YXIgZGVmYXVsdEVuY1R5cGUgPSBcImFwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZFwiO1xuZnVuY3Rpb24gaXNIdG1sRWxlbWVudChvYmplY3QpIHtcbiAgcmV0dXJuIG9iamVjdCAhPSBudWxsICYmIHR5cGVvZiBvYmplY3QudGFnTmFtZSA9PT0gXCJzdHJpbmdcIjtcbn1cbmZ1bmN0aW9uIGlzQnV0dG9uRWxlbWVudChvYmplY3QpIHtcbiAgcmV0dXJuIGlzSHRtbEVsZW1lbnQob2JqZWN0KSAmJiBvYmplY3QudGFnTmFtZS50b0xvd2VyQ2FzZSgpID09PSBcImJ1dHRvblwiO1xufVxuZnVuY3Rpb24gaXNGb3JtRWxlbWVudChvYmplY3QpIHtcbiAgcmV0dXJuIGlzSHRtbEVsZW1lbnQob2JqZWN0KSAmJiBvYmplY3QudGFnTmFtZS50b0xvd2VyQ2FzZSgpID09PSBcImZvcm1cIjtcbn1cbmZ1bmN0aW9uIGlzSW5wdXRFbGVtZW50KG9iamVjdCkge1xuICByZXR1cm4gaXNIdG1sRWxlbWVudChvYmplY3QpICYmIG9iamVjdC50YWdOYW1lLnRvTG93ZXJDYXNlKCkgPT09IFwiaW5wdXRcIjtcbn1cbmZ1bmN0aW9uIGlzTW9kaWZpZWRFdmVudChldmVudCkge1xuICByZXR1cm4gISEoZXZlbnQubWV0YUtleSB8fCBldmVudC5hbHRLZXkgfHwgZXZlbnQuY3RybEtleSB8fCBldmVudC5zaGlmdEtleSk7XG59XG5mdW5jdGlvbiBzaG91bGRQcm9jZXNzTGlua0NsaWNrKGV2ZW50LCB0YXJnZXQpIHtcbiAgcmV0dXJuIGV2ZW50LmJ1dHRvbiA9PT0gMCAmJiAvLyBJZ25vcmUgZXZlcnl0aGluZyBidXQgbGVmdCBjbGlja3NcbiAgKCF0YXJnZXQgfHwgdGFyZ2V0ID09PSBcIl9zZWxmXCIpICYmIC8vIExldCBicm93c2VyIGhhbmRsZSBcInRhcmdldD1fYmxhbmtcIiBldGMuXG4gICFpc01vZGlmaWVkRXZlbnQoZXZlbnQpO1xufVxuZnVuY3Rpb24gY3JlYXRlU2VhcmNoUGFyYW1zKGluaXQgPSBcIlwiKSB7XG4gIHJldHVybiBuZXcgVVJMU2VhcmNoUGFyYW1zKFxuICAgIHR5cGVvZiBpbml0ID09PSBcInN0cmluZ1wiIHx8IEFycmF5LmlzQXJyYXkoaW5pdCkgfHwgaW5pdCBpbnN0YW5jZW9mIFVSTFNlYXJjaFBhcmFtcyA/IGluaXQgOiBPYmplY3Qua2V5cyhpbml0KS5yZWR1Y2UoKG1lbW8yLCBrZXkpID0+IHtcbiAgICAgIGxldCB2YWx1ZSA9IGluaXRba2V5XTtcbiAgICAgIHJldHVybiBtZW1vMi5jb25jYXQoXG4gICAgICAgIEFycmF5LmlzQXJyYXkodmFsdWUpID8gdmFsdWUubWFwKCh2KSA9PiBba2V5LCB2XSkgOiBbW2tleSwgdmFsdWVdXVxuICAgICAgKTtcbiAgICB9LCBbXSlcbiAgKTtcbn1cbmZ1bmN0aW9uIGdldFNlYXJjaFBhcmFtc0ZvckxvY2F0aW9uKGxvY2F0aW9uU2VhcmNoLCBkZWZhdWx0U2VhcmNoUGFyYW1zKSB7XG4gIGxldCBzZWFyY2hQYXJhbXMgPSBjcmVhdGVTZWFyY2hQYXJhbXMobG9jYXRpb25TZWFyY2gpO1xuICBpZiAoZGVmYXVsdFNlYXJjaFBhcmFtcykge1xuICAgIGRlZmF1bHRTZWFyY2hQYXJhbXMuZm9yRWFjaCgoXywga2V5KSA9PiB7XG4gICAgICBpZiAoIXNlYXJjaFBhcmFtcy5oYXMoa2V5KSkge1xuICAgICAgICBkZWZhdWx0U2VhcmNoUGFyYW1zLmdldEFsbChrZXkpLmZvckVhY2goKHZhbHVlKSA9PiB7XG4gICAgICAgICAgc2VhcmNoUGFyYW1zLmFwcGVuZChrZXksIHZhbHVlKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIHNlYXJjaFBhcmFtcztcbn1cbnZhciBfZm9ybURhdGFTdXBwb3J0c1N1Ym1pdHRlciA9IG51bGw7XG5mdW5jdGlvbiBpc0Zvcm1EYXRhU3VibWl0dGVyU3VwcG9ydGVkKCkge1xuICBpZiAoX2Zvcm1EYXRhU3VwcG9ydHNTdWJtaXR0ZXIgPT09IG51bGwpIHtcbiAgICB0cnkge1xuICAgICAgbmV3IEZvcm1EYXRhKFxuICAgICAgICBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZm9ybVwiKSxcbiAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvciBpZiBGb3JtRGF0YSBzdXBwb3J0cyB0aGUgc3VibWl0dGVyIHBhcmFtZXRlciwgdGhpcyB3aWxsIHRocm93XG4gICAgICAgIDBcbiAgICAgICk7XG4gICAgICBfZm9ybURhdGFTdXBwb3J0c1N1Ym1pdHRlciA9IGZhbHNlO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIF9mb3JtRGF0YVN1cHBvcnRzU3VibWl0dGVyID0gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIF9mb3JtRGF0YVN1cHBvcnRzU3VibWl0dGVyO1xufVxudmFyIHN1cHBvcnRlZEZvcm1FbmNUeXBlcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KFtcbiAgXCJhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWRcIixcbiAgXCJtdWx0aXBhcnQvZm9ybS1kYXRhXCIsXG4gIFwidGV4dC9wbGFpblwiXG5dKTtcbmZ1bmN0aW9uIGdldEZvcm1FbmNUeXBlKGVuY1R5cGUpIHtcbiAgaWYgKGVuY1R5cGUgIT0gbnVsbCAmJiAhc3VwcG9ydGVkRm9ybUVuY1R5cGVzLmhhcyhlbmNUeXBlKSkge1xuICAgIHdhcm5pbmcoXG4gICAgICBmYWxzZSxcbiAgICAgIGBcIiR7ZW5jVHlwZX1cIiBpcyBub3QgYSB2YWxpZCBcXGBlbmNUeXBlXFxgIGZvciBcXGA8Rm9ybT5cXGAvXFxgPGZldGNoZXIuRm9ybT5cXGAgYW5kIHdpbGwgZGVmYXVsdCB0byBcIiR7ZGVmYXVsdEVuY1R5cGV9XCJgXG4gICAgKTtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICByZXR1cm4gZW5jVHlwZTtcbn1cbmZ1bmN0aW9uIGdldEZvcm1TdWJtaXNzaW9uSW5mbyh0YXJnZXQsIGJhc2VuYW1lKSB7XG4gIGxldCBtZXRob2Q7XG4gIGxldCBhY3Rpb247XG4gIGxldCBlbmNUeXBlO1xuICBsZXQgZm9ybURhdGE7XG4gIGxldCBib2R5O1xuICBpZiAoaXNGb3JtRWxlbWVudCh0YXJnZXQpKSB7XG4gICAgbGV0IGF0dHIgPSB0YXJnZXQuZ2V0QXR0cmlidXRlKFwiYWN0aW9uXCIpO1xuICAgIGFjdGlvbiA9IGF0dHIgPyBzdHJpcEJhc2VuYW1lKGF0dHIsIGJhc2VuYW1lKSA6IG51bGw7XG4gICAgbWV0aG9kID0gdGFyZ2V0LmdldEF0dHJpYnV0ZShcIm1ldGhvZFwiKSB8fCBkZWZhdWx0TWV0aG9kO1xuICAgIGVuY1R5cGUgPSBnZXRGb3JtRW5jVHlwZSh0YXJnZXQuZ2V0QXR0cmlidXRlKFwiZW5jdHlwZVwiKSkgfHwgZGVmYXVsdEVuY1R5cGU7XG4gICAgZm9ybURhdGEgPSBuZXcgRm9ybURhdGEodGFyZ2V0KTtcbiAgfSBlbHNlIGlmIChpc0J1dHRvbkVsZW1lbnQodGFyZ2V0KSB8fCBpc0lucHV0RWxlbWVudCh0YXJnZXQpICYmICh0YXJnZXQudHlwZSA9PT0gXCJzdWJtaXRcIiB8fCB0YXJnZXQudHlwZSA9PT0gXCJpbWFnZVwiKSkge1xuICAgIGxldCBmb3JtID0gdGFyZ2V0LmZvcm07XG4gICAgaWYgKGZvcm0gPT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgQ2Fubm90IHN1Ym1pdCBhIDxidXR0b24+IG9yIDxpbnB1dCB0eXBlPVwic3VibWl0XCI+IHdpdGhvdXQgYSA8Zm9ybT5gXG4gICAgICApO1xuICAgIH1cbiAgICBsZXQgYXR0ciA9IHRhcmdldC5nZXRBdHRyaWJ1dGUoXCJmb3JtYWN0aW9uXCIpIHx8IGZvcm0uZ2V0QXR0cmlidXRlKFwiYWN0aW9uXCIpO1xuICAgIGFjdGlvbiA9IGF0dHIgPyBzdHJpcEJhc2VuYW1lKGF0dHIsIGJhc2VuYW1lKSA6IG51bGw7XG4gICAgbWV0aG9kID0gdGFyZ2V0LmdldEF0dHJpYnV0ZShcImZvcm1tZXRob2RcIikgfHwgZm9ybS5nZXRBdHRyaWJ1dGUoXCJtZXRob2RcIikgfHwgZGVmYXVsdE1ldGhvZDtcbiAgICBlbmNUeXBlID0gZ2V0Rm9ybUVuY1R5cGUodGFyZ2V0LmdldEF0dHJpYnV0ZShcImZvcm1lbmN0eXBlXCIpKSB8fCBnZXRGb3JtRW5jVHlwZShmb3JtLmdldEF0dHJpYnV0ZShcImVuY3R5cGVcIikpIHx8IGRlZmF1bHRFbmNUeXBlO1xuICAgIGZvcm1EYXRhID0gbmV3IEZvcm1EYXRhKGZvcm0sIHRhcmdldCk7XG4gICAgaWYgKCFpc0Zvcm1EYXRhU3VibWl0dGVyU3VwcG9ydGVkKCkpIHtcbiAgICAgIGxldCB7IG5hbWUsIHR5cGUsIHZhbHVlIH0gPSB0YXJnZXQ7XG4gICAgICBpZiAodHlwZSA9PT0gXCJpbWFnZVwiKSB7XG4gICAgICAgIGxldCBwcmVmaXggPSBuYW1lID8gYCR7bmFtZX0uYCA6IFwiXCI7XG4gICAgICAgIGZvcm1EYXRhLmFwcGVuZChgJHtwcmVmaXh9eGAsIFwiMFwiKTtcbiAgICAgICAgZm9ybURhdGEuYXBwZW5kKGAke3ByZWZpeH15YCwgXCIwXCIpO1xuICAgICAgfSBlbHNlIGlmIChuYW1lKSB7XG4gICAgICAgIGZvcm1EYXRhLmFwcGVuZChuYW1lLCB2YWx1ZSk7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2UgaWYgKGlzSHRtbEVsZW1lbnQodGFyZ2V0KSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIGBDYW5ub3Qgc3VibWl0IGVsZW1lbnQgdGhhdCBpcyBub3QgPGZvcm0+LCA8YnV0dG9uPiwgb3IgPGlucHV0IHR5cGU9XCJzdWJtaXR8aW1hZ2VcIj5gXG4gICAgKTtcbiAgfSBlbHNlIHtcbiAgICBtZXRob2QgPSBkZWZhdWx0TWV0aG9kO1xuICAgIGFjdGlvbiA9IG51bGw7XG4gICAgZW5jVHlwZSA9IGRlZmF1bHRFbmNUeXBlO1xuICAgIGJvZHkgPSB0YXJnZXQ7XG4gIH1cbiAgaWYgKGZvcm1EYXRhICYmIGVuY1R5cGUgPT09IFwidGV4dC9wbGFpblwiKSB7XG4gICAgYm9keSA9IGZvcm1EYXRhO1xuICAgIGZvcm1EYXRhID0gdm9pZCAwO1xuICB9XG4gIHJldHVybiB7IGFjdGlvbiwgbWV0aG9kOiBtZXRob2QudG9Mb3dlckNhc2UoKSwgZW5jVHlwZSwgZm9ybURhdGEsIGJvZHkgfTtcbn1cblxuLy8gbGliL2RvbS9zc3IvY29tcG9uZW50cy50c3hcbnZhciBSZWFjdDkgPSBfX3RvRVNNKHJlcXVpcmUoXCJyZWFjdFwiKSk7XG5cbi8vIGxpYi9kb20vc3NyL2ludmFyaWFudC50c1xuZnVuY3Rpb24gaW52YXJpYW50Mih2YWx1ZSwgbWVzc2FnZSkge1xuICBpZiAodmFsdWUgPT09IGZhbHNlIHx8IHZhbHVlID09PSBudWxsIHx8IHR5cGVvZiB2YWx1ZSA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgIHRocm93IG5ldyBFcnJvcihtZXNzYWdlKTtcbiAgfVxufVxuXG4vLyBsaWIvZG9tL3Nzci9yb3V0ZU1vZHVsZXMudHNcbmFzeW5jIGZ1bmN0aW9uIGxvYWRSb3V0ZU1vZHVsZShyb3V0ZSwgcm91dGVNb2R1bGVzQ2FjaGUpIHtcbiAgaWYgKHJvdXRlLmlkIGluIHJvdXRlTW9kdWxlc0NhY2hlKSB7XG4gICAgcmV0dXJuIHJvdXRlTW9kdWxlc0NhY2hlW3JvdXRlLmlkXTtcbiAgfVxuICB0cnkge1xuICAgIGxldCByb3V0ZU1vZHVsZSA9IGF3YWl0IGltcG9ydChcbiAgICAgIC8qIEB2aXRlLWlnbm9yZSAqL1xuICAgICAgLyogd2VicGFja0lnbm9yZTogdHJ1ZSAqL1xuICAgICAgcm91dGUubW9kdWxlXG4gICAgKTtcbiAgICByb3V0ZU1vZHVsZXNDYWNoZVtyb3V0ZS5pZF0gPSByb3V0ZU1vZHVsZTtcbiAgICByZXR1cm4gcm91dGVNb2R1bGU7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcihcbiAgICAgIGBFcnJvciBsb2FkaW5nIHJvdXRlIG1vZHVsZSBcXGAke3JvdXRlLm1vZHVsZX1cXGAsIHJlbG9hZGluZyBwYWdlLi4uYFxuICAgICk7XG4gICAgY29uc29sZS5lcnJvcihlcnJvcik7XG4gICAgaWYgKHdpbmRvdy5fX3JlYWN0Um91dGVyQ29udGV4dCAmJiB3aW5kb3cuX19yZWFjdFJvdXRlckNvbnRleHQuaXNTcGFNb2RlICYmIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICB2b2lkIDApIHtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgICB3aW5kb3cubG9jYXRpb24ucmVsb2FkKCk7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKCgpID0+IHtcbiAgICB9KTtcbiAgfVxufVxuXG4vLyBsaWIvZG9tL3Nzci9saW5rcy50c1xuZnVuY3Rpb24gZ2V0S2V5ZWRMaW5rc0Zvck1hdGNoZXMobWF0Y2hlcywgcm91dGVNb2R1bGVzLCBtYW5pZmVzdCkge1xuICBsZXQgZGVzY3JpcHRvcnMgPSBtYXRjaGVzLm1hcCgobWF0Y2gpID0+IHtcbiAgICBsZXQgbW9kdWxlMiA9IHJvdXRlTW9kdWxlc1ttYXRjaC5yb3V0ZS5pZF07XG4gICAgbGV0IHJvdXRlID0gbWFuaWZlc3Qucm91dGVzW21hdGNoLnJvdXRlLmlkXTtcbiAgICByZXR1cm4gW1xuICAgICAgcm91dGUgJiYgcm91dGUuY3NzID8gcm91dGUuY3NzLm1hcCgoaHJlZikgPT4gKHsgcmVsOiBcInN0eWxlc2hlZXRcIiwgaHJlZiB9KSkgOiBbXSxcbiAgICAgIG1vZHVsZTI/LmxpbmtzPy4oKSB8fCBbXVxuICAgIF07XG4gIH0pLmZsYXQoMik7XG4gIGxldCBwcmVsb2FkcyA9IGdldEN1cnJlbnRQYWdlTW9kdWxlUHJlbG9hZEhyZWZzKG1hdGNoZXMsIG1hbmlmZXN0KTtcbiAgcmV0dXJuIGRlZHVwZUxpbmtEZXNjcmlwdG9ycyhkZXNjcmlwdG9ycywgcHJlbG9hZHMpO1xufVxuYXN5bmMgZnVuY3Rpb24gcHJlZmV0Y2hTdHlsZUxpbmtzKHJvdXRlLCByb3V0ZU1vZHVsZSkge1xuICBpZiAoIXJvdXRlLmNzcyAmJiAhcm91dGVNb2R1bGUubGlua3MgfHwgIWlzUHJlbG9hZFN1cHBvcnRlZCgpKSByZXR1cm47XG4gIGxldCBkZXNjcmlwdG9ycyA9IFtdO1xuICBpZiAocm91dGUuY3NzKSB7XG4gICAgZGVzY3JpcHRvcnMucHVzaCguLi5yb3V0ZS5jc3MubWFwKChocmVmKSA9PiAoeyByZWw6IFwic3R5bGVzaGVldFwiLCBocmVmIH0pKSk7XG4gIH1cbiAgaWYgKHJvdXRlTW9kdWxlLmxpbmtzKSB7XG4gICAgZGVzY3JpcHRvcnMucHVzaCguLi5yb3V0ZU1vZHVsZS5saW5rcygpKTtcbiAgfVxuICBpZiAoZGVzY3JpcHRvcnMubGVuZ3RoID09PSAwKSByZXR1cm47XG4gIGxldCBzdHlsZUxpbmtzID0gW107XG4gIGZvciAobGV0IGRlc2NyaXB0b3Igb2YgZGVzY3JpcHRvcnMpIHtcbiAgICBpZiAoIWlzUGFnZUxpbmtEZXNjcmlwdG9yKGRlc2NyaXB0b3IpICYmIGRlc2NyaXB0b3IucmVsID09PSBcInN0eWxlc2hlZXRcIikge1xuICAgICAgc3R5bGVMaW5rcy5wdXNoKHtcbiAgICAgICAgLi4uZGVzY3JpcHRvcixcbiAgICAgICAgcmVsOiBcInByZWxvYWRcIixcbiAgICAgICAgYXM6IFwic3R5bGVcIlxuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIGxldCBtYXRjaGluZ0xpbmtzID0gc3R5bGVMaW5rcy5maWx0ZXIoXG4gICAgKGxpbmspID0+ICghbGluay5tZWRpYSB8fCB3aW5kb3cubWF0Y2hNZWRpYShsaW5rLm1lZGlhKS5tYXRjaGVzKSAmJiAhZG9jdW1lbnQucXVlcnlTZWxlY3RvcihgbGlua1tyZWw9XCJzdHlsZXNoZWV0XCJdW2hyZWY9XCIke2xpbmsuaHJlZn1cIl1gKVxuICApO1xuICBhd2FpdCBQcm9taXNlLmFsbChtYXRjaGluZ0xpbmtzLm1hcChwcmVmZXRjaFN0eWxlTGluaykpO1xufVxuYXN5bmMgZnVuY3Rpb24gcHJlZmV0Y2hTdHlsZUxpbmsoZGVzY3JpcHRvcikge1xuICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICBsZXQgbGluayA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJsaW5rXCIpO1xuICAgIE9iamVjdC5hc3NpZ24obGluaywgZGVzY3JpcHRvcik7XG4gICAgZnVuY3Rpb24gcmVtb3ZlTGluaygpIHtcbiAgICAgIGlmIChkb2N1bWVudC5oZWFkLmNvbnRhaW5zKGxpbmspKSB7XG4gICAgICAgIGRvY3VtZW50LmhlYWQucmVtb3ZlQ2hpbGQobGluayk7XG4gICAgICB9XG4gICAgfVxuICAgIGxpbmsub25sb2FkID0gKCkgPT4ge1xuICAgICAgcmVtb3ZlTGluaygpO1xuICAgICAgcmVzb2x2ZSgpO1xuICAgIH07XG4gICAgbGluay5vbmVycm9yID0gKCkgPT4ge1xuICAgICAgcmVtb3ZlTGluaygpO1xuICAgICAgcmVzb2x2ZSgpO1xuICAgIH07XG4gICAgZG9jdW1lbnQuaGVhZC5hcHBlbmRDaGlsZChsaW5rKTtcbiAgfSk7XG59XG5mdW5jdGlvbiBpc1BhZ2VMaW5rRGVzY3JpcHRvcihvYmplY3QpIHtcbiAgcmV0dXJuIG9iamVjdCAhPSBudWxsICYmIHR5cGVvZiBvYmplY3QucGFnZSA9PT0gXCJzdHJpbmdcIjtcbn1cbmZ1bmN0aW9uIGlzSHRtbExpbmtEZXNjcmlwdG9yKG9iamVjdCkge1xuICBpZiAob2JqZWN0ID09IG51bGwpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKG9iamVjdC5ocmVmID09IG51bGwpIHtcbiAgICByZXR1cm4gb2JqZWN0LnJlbCA9PT0gXCJwcmVsb2FkXCIgJiYgdHlwZW9mIG9iamVjdC5pbWFnZVNyY1NldCA9PT0gXCJzdHJpbmdcIiAmJiB0eXBlb2Ygb2JqZWN0LmltYWdlU2l6ZXMgPT09IFwic3RyaW5nXCI7XG4gIH1cbiAgcmV0dXJuIHR5cGVvZiBvYmplY3QucmVsID09PSBcInN0cmluZ1wiICYmIHR5cGVvZiBvYmplY3QuaHJlZiA9PT0gXCJzdHJpbmdcIjtcbn1cbmFzeW5jIGZ1bmN0aW9uIGdldEtleWVkUHJlZmV0Y2hMaW5rcyhtYXRjaGVzLCBtYW5pZmVzdCwgcm91dGVNb2R1bGVzKSB7XG4gIGxldCBsaW5rcyA9IGF3YWl0IFByb21pc2UuYWxsKFxuICAgIG1hdGNoZXMubWFwKGFzeW5jIChtYXRjaCkgPT4ge1xuICAgICAgbGV0IHJvdXRlID0gbWFuaWZlc3Qucm91dGVzW21hdGNoLnJvdXRlLmlkXTtcbiAgICAgIGlmIChyb3V0ZSkge1xuICAgICAgICBsZXQgbW9kID0gYXdhaXQgbG9hZFJvdXRlTW9kdWxlKHJvdXRlLCByb3V0ZU1vZHVsZXMpO1xuICAgICAgICByZXR1cm4gbW9kLmxpbmtzID8gbW9kLmxpbmtzKCkgOiBbXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBbXTtcbiAgICB9KVxuICApO1xuICByZXR1cm4gZGVkdXBlTGlua0Rlc2NyaXB0b3JzKFxuICAgIGxpbmtzLmZsYXQoMSkuZmlsdGVyKGlzSHRtbExpbmtEZXNjcmlwdG9yKS5maWx0ZXIoKGxpbmspID0+IGxpbmsucmVsID09PSBcInN0eWxlc2hlZXRcIiB8fCBsaW5rLnJlbCA9PT0gXCJwcmVsb2FkXCIpLm1hcChcbiAgICAgIChsaW5rKSA9PiBsaW5rLnJlbCA9PT0gXCJzdHlsZXNoZWV0XCIgPyB7IC4uLmxpbmssIHJlbDogXCJwcmVmZXRjaFwiLCBhczogXCJzdHlsZVwiIH0gOiB7IC4uLmxpbmssIHJlbDogXCJwcmVmZXRjaFwiIH1cbiAgICApXG4gICk7XG59XG5mdW5jdGlvbiBnZXROZXdNYXRjaGVzRm9yTGlua3MocGFnZSwgbmV4dE1hdGNoZXMsIGN1cnJlbnRNYXRjaGVzLCBtYW5pZmVzdCwgbG9jYXRpb24sIG1vZGUpIHtcbiAgbGV0IGlzTmV3ID0gKG1hdGNoLCBpbmRleCkgPT4ge1xuICAgIGlmICghY3VycmVudE1hdGNoZXNbaW5kZXhdKSByZXR1cm4gdHJ1ZTtcbiAgICByZXR1cm4gbWF0Y2gucm91dGUuaWQgIT09IGN1cnJlbnRNYXRjaGVzW2luZGV4XS5yb3V0ZS5pZDtcbiAgfTtcbiAgbGV0IG1hdGNoUGF0aENoYW5nZWQgPSAobWF0Y2gsIGluZGV4KSA9PiB7XG4gICAgcmV0dXJuIChcbiAgICAgIC8vIHBhcmFtIGNoYW5nZSwgL3VzZXJzLzEyMyAtPiAvdXNlcnMvNDU2XG4gICAgICBjdXJyZW50TWF0Y2hlc1tpbmRleF0ucGF0aG5hbWUgIT09IG1hdGNoLnBhdGhuYW1lIHx8IC8vIHNwbGF0IHBhcmFtIGNoYW5nZWQsIHdoaWNoIGlzIG5vdCBwcmVzZW50IGluIG1hdGNoLnBhdGhcbiAgICAgIC8vIGUuZy4gL2ZpbGVzL2ltYWdlcy9hdmF0YXIuanBnIC0+IGZpbGVzL2ZpbmFuY2VzLnhsc1xuICAgICAgY3VycmVudE1hdGNoZXNbaW5kZXhdLnJvdXRlLnBhdGg/LmVuZHNXaXRoKFwiKlwiKSAmJiBjdXJyZW50TWF0Y2hlc1tpbmRleF0ucGFyYW1zW1wiKlwiXSAhPT0gbWF0Y2gucGFyYW1zW1wiKlwiXVxuICAgICk7XG4gIH07XG4gIGlmIChtb2RlID09PSBcImFzc2V0c1wiKSB7XG4gICAgcmV0dXJuIG5leHRNYXRjaGVzLmZpbHRlcihcbiAgICAgIChtYXRjaCwgaW5kZXgpID0+IGlzTmV3KG1hdGNoLCBpbmRleCkgfHwgbWF0Y2hQYXRoQ2hhbmdlZChtYXRjaCwgaW5kZXgpXG4gICAgKTtcbiAgfVxuICBpZiAobW9kZSA9PT0gXCJkYXRhXCIpIHtcbiAgICByZXR1cm4gbmV4dE1hdGNoZXMuZmlsdGVyKChtYXRjaCwgaW5kZXgpID0+IHtcbiAgICAgIGxldCBtYW5pZmVzdFJvdXRlID0gbWFuaWZlc3Qucm91dGVzW21hdGNoLnJvdXRlLmlkXTtcbiAgICAgIGlmICghbWFuaWZlc3RSb3V0ZSB8fCAhbWFuaWZlc3RSb3V0ZS5oYXNMb2FkZXIpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgaWYgKGlzTmV3KG1hdGNoLCBpbmRleCkgfHwgbWF0Y2hQYXRoQ2hhbmdlZChtYXRjaCwgaW5kZXgpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgaWYgKG1hdGNoLnJvdXRlLnNob3VsZFJldmFsaWRhdGUpIHtcbiAgICAgICAgbGV0IHJvdXRlQ2hvaWNlID0gbWF0Y2gucm91dGUuc2hvdWxkUmV2YWxpZGF0ZSh7XG4gICAgICAgICAgY3VycmVudFVybDogbmV3IFVSTChcbiAgICAgICAgICAgIGxvY2F0aW9uLnBhdGhuYW1lICsgbG9jYXRpb24uc2VhcmNoICsgbG9jYXRpb24uaGFzaCxcbiAgICAgICAgICAgIHdpbmRvdy5vcmlnaW5cbiAgICAgICAgICApLFxuICAgICAgICAgIGN1cnJlbnRQYXJhbXM6IGN1cnJlbnRNYXRjaGVzWzBdPy5wYXJhbXMgfHwge30sXG4gICAgICAgICAgbmV4dFVybDogbmV3IFVSTChwYWdlLCB3aW5kb3cub3JpZ2luKSxcbiAgICAgICAgICBuZXh0UGFyYW1zOiBtYXRjaC5wYXJhbXMsXG4gICAgICAgICAgZGVmYXVsdFNob3VsZFJldmFsaWRhdGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIGlmICh0eXBlb2Ygcm91dGVDaG9pY2UgPT09IFwiYm9vbGVhblwiKSB7XG4gICAgICAgICAgcmV0dXJuIHJvdXRlQ2hvaWNlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9KTtcbiAgfVxuICByZXR1cm4gW107XG59XG5mdW5jdGlvbiBnZXRNb2R1bGVMaW5rSHJlZnMobWF0Y2hlcywgbWFuaWZlc3RQYXRjaCkge1xuICByZXR1cm4gZGVkdXBlSHJlZnMoXG4gICAgbWF0Y2hlcy5tYXAoKG1hdGNoKSA9PiB7XG4gICAgICBsZXQgcm91dGUgPSBtYW5pZmVzdFBhdGNoLnJvdXRlc1ttYXRjaC5yb3V0ZS5pZF07XG4gICAgICBpZiAoIXJvdXRlKSByZXR1cm4gW107XG4gICAgICBsZXQgaHJlZnMgPSBbcm91dGUubW9kdWxlXTtcbiAgICAgIGlmIChyb3V0ZS5pbXBvcnRzKSB7XG4gICAgICAgIGhyZWZzID0gaHJlZnMuY29uY2F0KHJvdXRlLmltcG9ydHMpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGhyZWZzO1xuICAgIH0pLmZsYXQoMSlcbiAgKTtcbn1cbmZ1bmN0aW9uIGdldEN1cnJlbnRQYWdlTW9kdWxlUHJlbG9hZEhyZWZzKG1hdGNoZXMsIG1hbmlmZXN0KSB7XG4gIHJldHVybiBkZWR1cGVIcmVmcyhcbiAgICBtYXRjaGVzLm1hcCgobWF0Y2gpID0+IHtcbiAgICAgIGxldCByb3V0ZSA9IG1hbmlmZXN0LnJvdXRlc1ttYXRjaC5yb3V0ZS5pZF07XG4gICAgICBpZiAoIXJvdXRlKSByZXR1cm4gW107XG4gICAgICBsZXQgaHJlZnMgPSBbcm91dGUubW9kdWxlXTtcbiAgICAgIGlmIChyb3V0ZS5pbXBvcnRzKSB7XG4gICAgICAgIGhyZWZzID0gaHJlZnMuY29uY2F0KHJvdXRlLmltcG9ydHMpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGhyZWZzO1xuICAgIH0pLmZsYXQoMSlcbiAgKTtcbn1cbmZ1bmN0aW9uIGRlZHVwZUhyZWZzKGhyZWZzKSB7XG4gIHJldHVybiBbLi4ubmV3IFNldChocmVmcyldO1xufVxuZnVuY3Rpb24gc29ydEtleXMob2JqKSB7XG4gIGxldCBzb3J0ZWQgPSB7fTtcbiAgbGV0IGtleXMgPSBPYmplY3Qua2V5cyhvYmopLnNvcnQoKTtcbiAgZm9yIChsZXQga2V5IG9mIGtleXMpIHtcbiAgICBzb3J0ZWRba2V5XSA9IG9ialtrZXldO1xuICB9XG4gIHJldHVybiBzb3J0ZWQ7XG59XG5mdW5jdGlvbiBkZWR1cGVMaW5rRGVzY3JpcHRvcnMoZGVzY3JpcHRvcnMsIHByZWxvYWRzKSB7XG4gIGxldCBzZXQgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICBsZXQgcHJlbG9hZHNTZXQgPSBuZXcgU2V0KHByZWxvYWRzKTtcbiAgcmV0dXJuIGRlc2NyaXB0b3JzLnJlZHVjZSgoZGVkdXBlZCwgZGVzY3JpcHRvcikgPT4ge1xuICAgIGxldCBhbHJlYWR5TW9kdWxlUHJlbG9hZCA9IHByZWxvYWRzICYmICFpc1BhZ2VMaW5rRGVzY3JpcHRvcihkZXNjcmlwdG9yKSAmJiBkZXNjcmlwdG9yLmFzID09PSBcInNjcmlwdFwiICYmIGRlc2NyaXB0b3IuaHJlZiAmJiBwcmVsb2Fkc1NldC5oYXMoZGVzY3JpcHRvci5ocmVmKTtcbiAgICBpZiAoYWxyZWFkeU1vZHVsZVByZWxvYWQpIHtcbiAgICAgIHJldHVybiBkZWR1cGVkO1xuICAgIH1cbiAgICBsZXQga2V5ID0gSlNPTi5zdHJpbmdpZnkoc29ydEtleXMoZGVzY3JpcHRvcikpO1xuICAgIGlmICghc2V0LmhhcyhrZXkpKSB7XG4gICAgICBzZXQuYWRkKGtleSk7XG4gICAgICBkZWR1cGVkLnB1c2goeyBrZXksIGxpbms6IGRlc2NyaXB0b3IgfSk7XG4gICAgfVxuICAgIHJldHVybiBkZWR1cGVkO1xuICB9LCBbXSk7XG59XG52YXIgX2lzUHJlbG9hZFN1cHBvcnRlZDtcbmZ1bmN0aW9uIGlzUHJlbG9hZFN1cHBvcnRlZCgpIHtcbiAgaWYgKF9pc1ByZWxvYWRTdXBwb3J0ZWQgIT09IHZvaWQgMCkge1xuICAgIHJldHVybiBfaXNQcmVsb2FkU3VwcG9ydGVkO1xuICB9XG4gIGxldCBlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJsaW5rXCIpO1xuICBfaXNQcmVsb2FkU3VwcG9ydGVkID0gZWwucmVsTGlzdC5zdXBwb3J0cyhcInByZWxvYWRcIik7XG4gIGVsID0gbnVsbDtcbiAgcmV0dXJuIF9pc1ByZWxvYWRTdXBwb3J0ZWQ7XG59XG5cbi8vIGxpYi9kb20vc3NyL21hcmt1cC50c1xudmFyIEVTQ0FQRV9MT09LVVAgPSB7XG4gIFwiJlwiOiBcIlxcXFx1MDAyNlwiLFxuICBcIj5cIjogXCJcXFxcdTAwM2VcIixcbiAgXCI8XCI6IFwiXFxcXHUwMDNjXCIsXG4gIFwiXFx1MjAyOFwiOiBcIlxcXFx1MjAyOFwiLFxuICBcIlxcdTIwMjlcIjogXCJcXFxcdTIwMjlcIlxufTtcbnZhciBFU0NBUEVfUkVHRVggPSAvWyY+PFxcdTIwMjhcXHUyMDI5XS9nO1xuZnVuY3Rpb24gZXNjYXBlSHRtbChodG1sKSB7XG4gIHJldHVybiBodG1sLnJlcGxhY2UoRVNDQVBFX1JFR0VYLCAobWF0Y2gpID0+IEVTQ0FQRV9MT09LVVBbbWF0Y2hdKTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUh0bWwoaHRtbCkge1xuICByZXR1cm4geyBfX2h0bWw6IGh0bWwgfTtcbn1cblxuLy8gbGliL2RvbS9zc3Ivc2luZ2xlLWZldGNoLnRzeFxudmFyIFJlYWN0NCA9IF9fdG9FU00ocmVxdWlyZShcInJlYWN0XCIpKTtcbnZhciBpbXBvcnRfdHVyYm9fc3RyZWFtID0gcmVxdWlyZShcInR1cmJvLXN0cmVhbVwiKTtcblxuLy8gbGliL2RvbS9zc3IvZGF0YS50c1xuYXN5bmMgZnVuY3Rpb24gY3JlYXRlUmVxdWVzdEluaXQocmVxdWVzdCkge1xuICBsZXQgaW5pdCA9IHsgc2lnbmFsOiByZXF1ZXN0LnNpZ25hbCB9O1xuICBpZiAocmVxdWVzdC5tZXRob2QgIT09IFwiR0VUXCIpIHtcbiAgICBpbml0Lm1ldGhvZCA9IHJlcXVlc3QubWV0aG9kO1xuICAgIGxldCBjb250ZW50VHlwZSA9IHJlcXVlc3QuaGVhZGVycy5nZXQoXCJDb250ZW50LVR5cGVcIik7XG4gICAgaWYgKGNvbnRlbnRUeXBlICYmIC9cXGJhcHBsaWNhdGlvblxcL2pzb25cXGIvLnRlc3QoY29udGVudFR5cGUpKSB7XG4gICAgICBpbml0LmhlYWRlcnMgPSB7IFwiQ29udGVudC1UeXBlXCI6IGNvbnRlbnRUeXBlIH07XG4gICAgICBpbml0LmJvZHkgPSBKU09OLnN0cmluZ2lmeShhd2FpdCByZXF1ZXN0Lmpzb24oKSk7XG4gICAgfSBlbHNlIGlmIChjb250ZW50VHlwZSAmJiAvXFxidGV4dFxcL3BsYWluXFxiLy50ZXN0KGNvbnRlbnRUeXBlKSkge1xuICAgICAgaW5pdC5oZWFkZXJzID0geyBcIkNvbnRlbnQtVHlwZVwiOiBjb250ZW50VHlwZSB9O1xuICAgICAgaW5pdC5ib2R5ID0gYXdhaXQgcmVxdWVzdC50ZXh0KCk7XG4gICAgfSBlbHNlIGlmIChjb250ZW50VHlwZSAmJiAvXFxiYXBwbGljYXRpb25cXC94LXd3dy1mb3JtLXVybGVuY29kZWRcXGIvLnRlc3QoY29udGVudFR5cGUpKSB7XG4gICAgICBpbml0LmJvZHkgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKGF3YWl0IHJlcXVlc3QudGV4dCgpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaW5pdC5ib2R5ID0gYXdhaXQgcmVxdWVzdC5mb3JtRGF0YSgpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gaW5pdDtcbn1cblxuLy8gbGliL2RvbS9zc3Ivc2luZ2xlLWZldGNoLnRzeFxudmFyIFNpbmdsZUZldGNoUmVkaXJlY3RTeW1ib2wgPSBTeW1ib2woXCJTaW5nbGVGZXRjaFJlZGlyZWN0XCIpO1xuZnVuY3Rpb24gU3RyZWFtVHJhbnNmZXIoe1xuICBjb250ZXh0LFxuICBpZGVudGlmaWVyLFxuICByZWFkZXIsXG4gIHRleHREZWNvZGVyLFxuICBub25jZVxufSkge1xuICBpZiAoIWNvbnRleHQucmVuZGVyTWV0YSB8fCAhY29udGV4dC5yZW5kZXJNZXRhLmRpZFJlbmRlclNjcmlwdHMpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBpZiAoIWNvbnRleHQucmVuZGVyTWV0YS5zdHJlYW1DYWNoZSkge1xuICAgIGNvbnRleHQucmVuZGVyTWV0YS5zdHJlYW1DYWNoZSA9IHt9O1xuICB9XG4gIGxldCB7IHN0cmVhbUNhY2hlIH0gPSBjb250ZXh0LnJlbmRlck1ldGE7XG4gIGxldCBwcm9taXNlID0gc3RyZWFtQ2FjaGVbaWRlbnRpZmllcl07XG4gIGlmICghcHJvbWlzZSkge1xuICAgIHByb21pc2UgPSBzdHJlYW1DYWNoZVtpZGVudGlmaWVyXSA9IHJlYWRlci5yZWFkKCkudGhlbigocmVzdWx0KSA9PiB7XG4gICAgICBzdHJlYW1DYWNoZVtpZGVudGlmaWVyXS5yZXN1bHQgPSB7XG4gICAgICAgIGRvbmU6IHJlc3VsdC5kb25lLFxuICAgICAgICB2YWx1ZTogdGV4dERlY29kZXIuZGVjb2RlKHJlc3VsdC52YWx1ZSwgeyBzdHJlYW06IHRydWUgfSlcbiAgICAgIH07XG4gICAgfSkuY2F0Y2goKGUpID0+IHtcbiAgICAgIHN0cmVhbUNhY2hlW2lkZW50aWZpZXJdLmVycm9yID0gZTtcbiAgICB9KTtcbiAgfVxuICBpZiAocHJvbWlzZS5lcnJvcikge1xuICAgIHRocm93IHByb21pc2UuZXJyb3I7XG4gIH1cbiAgaWYgKHByb21pc2UucmVzdWx0ID09PSB2b2lkIDApIHtcbiAgICB0aHJvdyBwcm9taXNlO1xuICB9XG4gIGxldCB7IGRvbmUsIHZhbHVlIH0gPSBwcm9taXNlLnJlc3VsdDtcbiAgbGV0IHNjcmlwdFRhZyA9IHZhbHVlID8gLyogQF9fUFVSRV9fICovIFJlYWN0NC5jcmVhdGVFbGVtZW50KFxuICAgIFwic2NyaXB0XCIsXG4gICAge1xuICAgICAgbm9uY2UsXG4gICAgICBkYW5nZXJvdXNseVNldElubmVySFRNTDoge1xuICAgICAgICBfX2h0bWw6IGB3aW5kb3cuX19yZWFjdFJvdXRlckNvbnRleHQuc3RyZWFtQ29udHJvbGxlci5lbnF1ZXVlKCR7ZXNjYXBlSHRtbChcbiAgICAgICAgICBKU09OLnN0cmluZ2lmeSh2YWx1ZSlcbiAgICAgICAgKX0pO2BcbiAgICAgIH1cbiAgICB9XG4gICkgOiBudWxsO1xuICBpZiAoZG9uZSkge1xuICAgIHJldHVybiAvKiBAX19QVVJFX18gKi8gUmVhY3Q0LmNyZWF0ZUVsZW1lbnQoUmVhY3Q0LkZyYWdtZW50LCBudWxsLCBzY3JpcHRUYWcsIC8qIEBfX1BVUkVfXyAqLyBSZWFjdDQuY3JlYXRlRWxlbWVudChcbiAgICAgIFwic2NyaXB0XCIsXG4gICAgICB7XG4gICAgICAgIG5vbmNlLFxuICAgICAgICBkYW5nZXJvdXNseVNldElubmVySFRNTDoge1xuICAgICAgICAgIF9faHRtbDogYHdpbmRvdy5fX3JlYWN0Um91dGVyQ29udGV4dC5zdHJlYW1Db250cm9sbGVyLmNsb3NlKCk7YFxuICAgICAgICB9XG4gICAgICB9XG4gICAgKSk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBSZWFjdDQuY3JlYXRlRWxlbWVudChSZWFjdDQuRnJhZ21lbnQsIG51bGwsIHNjcmlwdFRhZywgLyogQF9fUFVSRV9fICovIFJlYWN0NC5jcmVhdGVFbGVtZW50KFJlYWN0NC5TdXNwZW5zZSwgbnVsbCwgLyogQF9fUFVSRV9fICovIFJlYWN0NC5jcmVhdGVFbGVtZW50KFxuICAgICAgU3RyZWFtVHJhbnNmZXIsXG4gICAgICB7XG4gICAgICAgIGNvbnRleHQsXG4gICAgICAgIGlkZW50aWZpZXI6IGlkZW50aWZpZXIgKyAxLFxuICAgICAgICByZWFkZXIsXG4gICAgICAgIHRleHREZWNvZGVyLFxuICAgICAgICBub25jZVxuICAgICAgfVxuICAgICkpKTtcbiAgfVxufVxuZnVuY3Rpb24gZ2V0U2luZ2xlRmV0Y2hEYXRhU3RyYXRlZ3kobWFuaWZlc3QsIHJvdXRlTW9kdWxlcywgZ2V0Um91dGVyKSB7XG4gIHJldHVybiBhc3luYyAoeyByZXF1ZXN0LCBtYXRjaGVzLCBmZXRjaGVyS2V5IH0pID0+IHtcbiAgICBpZiAocmVxdWVzdC5tZXRob2QgIT09IFwiR0VUXCIpIHtcbiAgICAgIHJldHVybiBzaW5nbGVGZXRjaEFjdGlvblN0cmF0ZWd5KHJlcXVlc3QsIG1hdGNoZXMpO1xuICAgIH1cbiAgICBpZiAoZmV0Y2hlcktleSkge1xuICAgICAgcmV0dXJuIHNpbmdsZUZldGNoTG9hZGVyRmV0Y2hlclN0cmF0ZWd5KHJlcXVlc3QsIG1hdGNoZXMpO1xuICAgIH1cbiAgICByZXR1cm4gc2luZ2xlRmV0Y2hMb2FkZXJOYXZpZ2F0aW9uU3RyYXRlZ3koXG4gICAgICBtYW5pZmVzdCxcbiAgICAgIHJvdXRlTW9kdWxlcyxcbiAgICAgIGdldFJvdXRlcigpLFxuICAgICAgcmVxdWVzdCxcbiAgICAgIG1hdGNoZXNcbiAgICApO1xuICB9O1xufVxuYXN5bmMgZnVuY3Rpb24gc2luZ2xlRmV0Y2hBY3Rpb25TdHJhdGVneShyZXF1ZXN0LCBtYXRjaGVzKSB7XG4gIGxldCBhY3Rpb25NYXRjaCA9IG1hdGNoZXMuZmluZCgobSkgPT4gbS5zaG91bGRMb2FkKTtcbiAgaW52YXJpYW50MihhY3Rpb25NYXRjaCwgXCJObyBhY3Rpb24gbWF0Y2ggZm91bmRcIik7XG4gIGxldCBhY3Rpb25TdGF0dXMgPSB2b2lkIDA7XG4gIGxldCByZXN1bHQgPSBhd2FpdCBhY3Rpb25NYXRjaC5yZXNvbHZlKGFzeW5jIChoYW5kbGVyKSA9PiB7XG4gICAgbGV0IHJlc3VsdDIgPSBhd2FpdCBoYW5kbGVyKGFzeW5jICgpID0+IHtcbiAgICAgIGxldCB1cmwgPSBzaW5nbGVGZXRjaFVybChyZXF1ZXN0LnVybCk7XG4gICAgICBsZXQgaW5pdCA9IGF3YWl0IGNyZWF0ZVJlcXVlc3RJbml0KHJlcXVlc3QpO1xuICAgICAgbGV0IHsgZGF0YTogZGF0YTIsIHN0YXR1cyB9ID0gYXdhaXQgZmV0Y2hBbmREZWNvZGUodXJsLCBpbml0KTtcbiAgICAgIGFjdGlvblN0YXR1cyA9IHN0YXR1cztcbiAgICAgIHJldHVybiB1bndyYXBTaW5nbGVGZXRjaFJlc3VsdChcbiAgICAgICAgZGF0YTIsXG4gICAgICAgIGFjdGlvbk1hdGNoLnJvdXRlLmlkXG4gICAgICApO1xuICAgIH0pO1xuICAgIHJldHVybiByZXN1bHQyO1xuICB9KTtcbiAgaWYgKGlzUmVzcG9uc2UocmVzdWx0LnJlc3VsdCkgfHwgaXNSb3V0ZUVycm9yUmVzcG9uc2UocmVzdWx0LnJlc3VsdCkpIHtcbiAgICByZXR1cm4geyBbYWN0aW9uTWF0Y2gucm91dGUuaWRdOiByZXN1bHQgfTtcbiAgfVxuICByZXR1cm4ge1xuICAgIFthY3Rpb25NYXRjaC5yb3V0ZS5pZF06IHtcbiAgICAgIHR5cGU6IHJlc3VsdC50eXBlLFxuICAgICAgcmVzdWx0OiBkYXRhKHJlc3VsdC5yZXN1bHQsIGFjdGlvblN0YXR1cylcbiAgICB9XG4gIH07XG59XG5hc3luYyBmdW5jdGlvbiBzaW5nbGVGZXRjaExvYWRlck5hdmlnYXRpb25TdHJhdGVneShtYW5pZmVzdCwgcm91dGVNb2R1bGVzLCByb3V0ZXIsIHJlcXVlc3QsIG1hdGNoZXMpIHtcbiAgbGV0IHJvdXRlc1BhcmFtcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gIGxldCBmb3VuZE9wdE91dFJvdXRlID0gZmFsc2U7XG4gIGxldCByb3V0ZURmZHMgPSBtYXRjaGVzLm1hcCgoKSA9PiBjcmVhdGVEZWZlcnJlZDIoKSk7XG4gIGxldCByb3V0ZXNMb2FkZWRQcm9taXNlID0gUHJvbWlzZS5hbGwocm91dGVEZmRzLm1hcCgoZCkgPT4gZC5wcm9taXNlKSk7XG4gIGxldCBzaW5nbGVGZXRjaERmZCA9IGNyZWF0ZURlZmVycmVkMigpO1xuICBsZXQgdXJsID0gc3RyaXBJbmRleFBhcmFtKHNpbmdsZUZldGNoVXJsKHJlcXVlc3QudXJsKSk7XG4gIGxldCBpbml0ID0gYXdhaXQgY3JlYXRlUmVxdWVzdEluaXQocmVxdWVzdCk7XG4gIGxldCByZXN1bHRzID0ge307XG4gIGxldCByZXNvbHZlUHJvbWlzZSA9IFByb21pc2UuYWxsKFxuICAgIG1hdGNoZXMubWFwKFxuICAgICAgYXN5bmMgKG0sIGkpID0+IG0ucmVzb2x2ZShhc3luYyAoaGFuZGxlcikgPT4ge1xuICAgICAgICByb3V0ZURmZHNbaV0ucmVzb2x2ZSgpO1xuICAgICAgICBsZXQgbWFuaWZlc3RSb3V0ZSA9IG1hbmlmZXN0LnJvdXRlc1ttLnJvdXRlLmlkXTtcbiAgICAgICAgaWYgKCFtLnNob3VsZExvYWQpIHtcbiAgICAgICAgICBpZiAoIXJvdXRlci5zdGF0ZS5pbml0aWFsaXplZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAobS5yb3V0ZS5pZCBpbiByb3V0ZXIuc3RhdGUubG9hZGVyRGF0YSAmJiBtYW5pZmVzdFJvdXRlICYmIG1hbmlmZXN0Um91dGUuaGFzTG9hZGVyICYmIHJvdXRlTW9kdWxlc1ttLnJvdXRlLmlkXT8uc2hvdWxkUmV2YWxpZGF0ZSkge1xuICAgICAgICAgICAgZm91bmRPcHRPdXRSb3V0ZSA9IHRydWU7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChtYW5pZmVzdFJvdXRlICYmIG1hbmlmZXN0Um91dGUuaGFzQ2xpZW50TG9hZGVyKSB7XG4gICAgICAgICAgaWYgKG1hbmlmZXN0Um91dGUuaGFzTG9hZGVyKSB7XG4gICAgICAgICAgICBmb3VuZE9wdE91dFJvdXRlID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGxldCByZXN1bHQgPSBhd2FpdCBmZXRjaFNpbmdsZUxvYWRlcihcbiAgICAgICAgICAgICAgaGFuZGxlcixcbiAgICAgICAgICAgICAgdXJsLFxuICAgICAgICAgICAgICBpbml0LFxuICAgICAgICAgICAgICBtLnJvdXRlLmlkXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgcmVzdWx0c1ttLnJvdXRlLmlkXSA9IHsgdHlwZTogXCJkYXRhXCIsIHJlc3VsdCB9O1xuICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHJlc3VsdHNbbS5yb3V0ZS5pZF0gPSB7IHR5cGU6IFwiZXJyb3JcIiwgcmVzdWx0OiBlIH07XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWFuaWZlc3RSb3V0ZSAmJiBtYW5pZmVzdFJvdXRlLmhhc0xvYWRlcikge1xuICAgICAgICAgIHJvdXRlc1BhcmFtcy5hZGQobS5yb3V0ZS5pZCk7XG4gICAgICAgIH1cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBsZXQgcmVzdWx0ID0gYXdhaXQgaGFuZGxlcihhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICBsZXQgZGF0YTIgPSBhd2FpdCBzaW5nbGVGZXRjaERmZC5wcm9taXNlO1xuICAgICAgICAgICAgcmV0dXJuIHVud3JhcFNpbmdsZUZldGNoUmVzdWx0cyhkYXRhMiwgbS5yb3V0ZS5pZCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgcmVzdWx0c1ttLnJvdXRlLmlkXSA9IHtcbiAgICAgICAgICAgIHR5cGU6IFwiZGF0YVwiLFxuICAgICAgICAgICAgcmVzdWx0XG4gICAgICAgICAgfTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIHJlc3VsdHNbbS5yb3V0ZS5pZF0gPSB7XG4gICAgICAgICAgICB0eXBlOiBcImVycm9yXCIsXG4gICAgICAgICAgICByZXN1bHQ6IGVcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICB9KVxuICAgIClcbiAgKTtcbiAgYXdhaXQgcm91dGVzTG9hZGVkUHJvbWlzZTtcbiAgaWYgKCghcm91dGVyLnN0YXRlLmluaXRpYWxpemVkIHx8IHJvdXRlc1BhcmFtcy5zaXplID09PSAwKSAmJiAhd2luZG93Ll9fcmVhY3RSb3V0ZXJIZHJBY3RpdmUpIHtcbiAgICBzaW5nbGVGZXRjaERmZC5yZXNvbHZlKHt9KTtcbiAgfSBlbHNlIHtcbiAgICB0cnkge1xuICAgICAgaWYgKGZvdW5kT3B0T3V0Um91dGUgJiYgcm91dGVzUGFyYW1zLnNpemUgPiAwKSB7XG4gICAgICAgIHVybC5zZWFyY2hQYXJhbXMuc2V0KFxuICAgICAgICAgIFwiX3JvdXRlc1wiLFxuICAgICAgICAgIG1hdGNoZXMuZmlsdGVyKChtKSA9PiByb3V0ZXNQYXJhbXMuaGFzKG0ucm91dGUuaWQpKS5tYXAoKG0pID0+IG0ucm91dGUuaWQpLmpvaW4oXCIsXCIpXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBsZXQgZGF0YTIgPSBhd2FpdCBmZXRjaEFuZERlY29kZSh1cmwsIGluaXQpO1xuICAgICAgc2luZ2xlRmV0Y2hEZmQucmVzb2x2ZShkYXRhMi5kYXRhKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBzaW5nbGVGZXRjaERmZC5yZWplY3QoZSk7XG4gICAgfVxuICB9XG4gIGF3YWl0IHJlc29sdmVQcm9taXNlO1xuICByZXR1cm4gcmVzdWx0cztcbn1cbmFzeW5jIGZ1bmN0aW9uIHNpbmdsZUZldGNoTG9hZGVyRmV0Y2hlclN0cmF0ZWd5KHJlcXVlc3QsIG1hdGNoZXMpIHtcbiAgbGV0IGZldGNoZXJNYXRjaCA9IG1hdGNoZXMuZmluZCgobSkgPT4gbS5zaG91bGRMb2FkKTtcbiAgaW52YXJpYW50MihmZXRjaGVyTWF0Y2gsIFwiTm8gZmV0Y2hlciBtYXRjaCBmb3VuZFwiKTtcbiAgbGV0IHJlc3VsdCA9IGF3YWl0IGZldGNoZXJNYXRjaC5yZXNvbHZlKGFzeW5jIChoYW5kbGVyKSA9PiB7XG4gICAgbGV0IHVybCA9IHN0cmlwSW5kZXhQYXJhbShzaW5nbGVGZXRjaFVybChyZXF1ZXN0LnVybCkpO1xuICAgIGxldCBpbml0ID0gYXdhaXQgY3JlYXRlUmVxdWVzdEluaXQocmVxdWVzdCk7XG4gICAgcmV0dXJuIGZldGNoU2luZ2xlTG9hZGVyKGhhbmRsZXIsIHVybCwgaW5pdCwgZmV0Y2hlck1hdGNoLnJvdXRlLmlkKTtcbiAgfSk7XG4gIHJldHVybiB7IFtmZXRjaGVyTWF0Y2gucm91dGUuaWRdOiByZXN1bHQgfTtcbn1cbmZ1bmN0aW9uIGZldGNoU2luZ2xlTG9hZGVyKGhhbmRsZXIsIHVybCwgaW5pdCwgcm91dGVJZCkge1xuICByZXR1cm4gaGFuZGxlcihhc3luYyAoKSA9PiB7XG4gICAgbGV0IHNpbmdsZUxvYWRlclVybCA9IG5ldyBVUkwodXJsKTtcbiAgICBzaW5nbGVMb2FkZXJVcmwuc2VhcmNoUGFyYW1zLnNldChcIl9yb3V0ZXNcIiwgcm91dGVJZCk7XG4gICAgbGV0IHsgZGF0YTogZGF0YTIgfSA9IGF3YWl0IGZldGNoQW5kRGVjb2RlKHNpbmdsZUxvYWRlclVybCwgaW5pdCk7XG4gICAgcmV0dXJuIHVud3JhcFNpbmdsZUZldGNoUmVzdWx0cyhkYXRhMiwgcm91dGVJZCk7XG4gIH0pO1xufVxuZnVuY3Rpb24gc3RyaXBJbmRleFBhcmFtKHVybCkge1xuICBsZXQgaW5kZXhWYWx1ZXMgPSB1cmwuc2VhcmNoUGFyYW1zLmdldEFsbChcImluZGV4XCIpO1xuICB1cmwuc2VhcmNoUGFyYW1zLmRlbGV0ZShcImluZGV4XCIpO1xuICBsZXQgaW5kZXhWYWx1ZXNUb0tlZXAgPSBbXTtcbiAgZm9yIChsZXQgaW5kZXhWYWx1ZSBvZiBpbmRleFZhbHVlcykge1xuICAgIGlmIChpbmRleFZhbHVlKSB7XG4gICAgICBpbmRleFZhbHVlc1RvS2VlcC5wdXNoKGluZGV4VmFsdWUpO1xuICAgIH1cbiAgfVxuICBmb3IgKGxldCB0b0tlZXAgb2YgaW5kZXhWYWx1ZXNUb0tlZXApIHtcbiAgICB1cmwuc2VhcmNoUGFyYW1zLmFwcGVuZChcImluZGV4XCIsIHRvS2VlcCk7XG4gIH1cbiAgcmV0dXJuIHVybDtcbn1cbmZ1bmN0aW9uIHNpbmdsZUZldGNoVXJsKHJlcVVybCkge1xuICBsZXQgdXJsID0gdHlwZW9mIHJlcVVybCA9PT0gXCJzdHJpbmdcIiA/IG5ldyBVUkwoXG4gICAgcmVxVXJsLFxuICAgIC8vIFRoaXMgY2FuIGJlIGNhbGxlZCBkdXJpbmcgdGhlIFNTUiBmbG93IHZpYSBQcmVmZXRjaFBhZ2VMaW5rc0ltcGwgc29cbiAgICAvLyBkb24ndCBhc3N1bWUgd2luZG93IGlzIGF2YWlsYWJsZVxuICAgIHR5cGVvZiB3aW5kb3cgPT09IFwidW5kZWZpbmVkXCIgPyBcInNlcnZlcjovL3NpbmdsZWZldGNoL1wiIDogd2luZG93LmxvY2F0aW9uLm9yaWdpblxuICApIDogcmVxVXJsO1xuICBpZiAodXJsLnBhdGhuYW1lID09PSBcIi9cIikge1xuICAgIHVybC5wYXRobmFtZSA9IFwiX3Jvb3QuZGF0YVwiO1xuICB9IGVsc2Uge1xuICAgIHVybC5wYXRobmFtZSA9IGAke3VybC5wYXRobmFtZS5yZXBsYWNlKC9cXC8kLywgXCJcIil9LmRhdGFgO1xuICB9XG4gIHJldHVybiB1cmw7XG59XG5hc3luYyBmdW5jdGlvbiBmZXRjaEFuZERlY29kZSh1cmwsIGluaXQpIHtcbiAgbGV0IHJlcyA9IGF3YWl0IGZldGNoKHVybCwgaW5pdCk7XG4gIGlmIChyZXMuc3RhdHVzID09PSA0MDQgJiYgIXJlcy5oZWFkZXJzLmhhcyhcIlgtUmVtaXgtUmVzcG9uc2VcIikpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3JSZXNwb25zZUltcGwoNDA0LCBcIk5vdCBGb3VuZFwiLCB0cnVlKTtcbiAgfVxuICBpbnZhcmlhbnQyKHJlcy5ib2R5LCBcIk5vIHJlc3BvbnNlIGJvZHkgdG8gZGVjb2RlXCIpO1xuICB0cnkge1xuICAgIGxldCBkZWNvZGVkID0gYXdhaXQgZGVjb2RlVmlhVHVyYm9TdHJlYW0ocmVzLmJvZHksIHdpbmRvdyk7XG4gICAgcmV0dXJuIHsgc3RhdHVzOiByZXMuc3RhdHVzLCBkYXRhOiBkZWNvZGVkLnZhbHVlIH07XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmFibGUgdG8gZGVjb2RlIHR1cmJvLXN0cmVhbSByZXNwb25zZVwiKTtcbiAgfVxufVxuZnVuY3Rpb24gZGVjb2RlVmlhVHVyYm9TdHJlYW0oYm9keSwgZ2xvYmFsMikge1xuICByZXR1cm4gKDAsIGltcG9ydF90dXJib19zdHJlYW0uZGVjb2RlKShib2R5LCB7XG4gICAgcGx1Z2luczogW1xuICAgICAgKHR5cGUsIC4uLnJlc3QpID0+IHtcbiAgICAgICAgaWYgKHR5cGUgPT09IFwiU2FuaXRpemVkRXJyb3JcIikge1xuICAgICAgICAgIGxldCBbbmFtZSwgbWVzc2FnZSwgc3RhY2tdID0gcmVzdDtcbiAgICAgICAgICBsZXQgQ29uc3RydWN0b3IgPSBFcnJvcjtcbiAgICAgICAgICBpZiAobmFtZSAmJiBuYW1lIGluIGdsb2JhbDIgJiYgdHlwZW9mIGdsb2JhbDJbbmFtZV0gPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgQ29uc3RydWN0b3IgPSBnbG9iYWwyW25hbWVdO1xuICAgICAgICAgIH1cbiAgICAgICAgICBsZXQgZXJyb3IgPSBuZXcgQ29uc3RydWN0b3IobWVzc2FnZSk7XG4gICAgICAgICAgZXJyb3Iuc3RhY2sgPSBzdGFjaztcbiAgICAgICAgICByZXR1cm4geyB2YWx1ZTogZXJyb3IgfTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZSA9PT0gXCJFcnJvclJlc3BvbnNlXCIpIHtcbiAgICAgICAgICBsZXQgW2RhdGEyLCBzdGF0dXMsIHN0YXR1c1RleHRdID0gcmVzdDtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdmFsdWU6IG5ldyBFcnJvclJlc3BvbnNlSW1wbChzdGF0dXMsIHN0YXR1c1RleHQsIGRhdGEyKVxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGUgPT09IFwiU2luZ2xlRmV0Y2hSZWRpcmVjdFwiKSB7XG4gICAgICAgICAgcmV0dXJuIHsgdmFsdWU6IHsgW1NpbmdsZUZldGNoUmVkaXJlY3RTeW1ib2xdOiByZXN0WzBdIH0gfTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZSA9PT0gXCJTaW5nbGVGZXRjaENsYXNzSW5zdGFuY2VcIikge1xuICAgICAgICAgIHJldHVybiB7IHZhbHVlOiByZXN0WzBdIH07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGUgPT09IFwiU2luZ2xlRmV0Y2hGYWxsYmFja1wiKSB7XG4gICAgICAgICAgcmV0dXJuIHsgdmFsdWU6IHZvaWQgMCB9O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgXVxuICB9KTtcbn1cbmZ1bmN0aW9uIHVud3JhcFNpbmdsZUZldGNoUmVzdWx0cyhyZXN1bHRzLCByb3V0ZUlkKSB7XG4gIGxldCByZWRpcmVjdDIgPSByZXN1bHRzW1NpbmdsZUZldGNoUmVkaXJlY3RTeW1ib2xdO1xuICBpZiAocmVkaXJlY3QyKSB7XG4gICAgcmV0dXJuIHVud3JhcFNpbmdsZUZldGNoUmVzdWx0KHJlZGlyZWN0Miwgcm91dGVJZCk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdHNbcm91dGVJZF0gIT09IHZvaWQgMCA/IHVud3JhcFNpbmdsZUZldGNoUmVzdWx0KHJlc3VsdHNbcm91dGVJZF0sIHJvdXRlSWQpIDogbnVsbDtcbn1cbmZ1bmN0aW9uIHVud3JhcFNpbmdsZUZldGNoUmVzdWx0KHJlc3VsdCwgcm91dGVJZCkge1xuICBpZiAoXCJlcnJvclwiIGluIHJlc3VsdCkge1xuICAgIHRocm93IHJlc3VsdC5lcnJvcjtcbiAgfSBlbHNlIGlmIChcInJlZGlyZWN0XCIgaW4gcmVzdWx0KSB7XG4gICAgbGV0IGhlYWRlcnMgPSB7fTtcbiAgICBpZiAocmVzdWx0LnJldmFsaWRhdGUpIHtcbiAgICAgIGhlYWRlcnNbXCJYLVJlbWl4LVJldmFsaWRhdGVcIl0gPSBcInllc1wiO1xuICAgIH1cbiAgICBpZiAocmVzdWx0LnJlbG9hZCkge1xuICAgICAgaGVhZGVyc1tcIlgtUmVtaXgtUmVsb2FkLURvY3VtZW50XCJdID0gXCJ5ZXNcIjtcbiAgICB9XG4gICAgaWYgKHJlc3VsdC5yZXBsYWNlKSB7XG4gICAgICBoZWFkZXJzW1wiWC1SZW1peC1SZXBsYWNlXCJdID0gXCJ5ZXNcIjtcbiAgICB9XG4gICAgdGhyb3cgcmVkaXJlY3QocmVzdWx0LnJlZGlyZWN0LCB7IHN0YXR1czogcmVzdWx0LnN0YXR1cywgaGVhZGVycyB9KTtcbiAgfSBlbHNlIGlmIChcImRhdGFcIiBpbiByZXN1bHQpIHtcbiAgICByZXR1cm4gcmVzdWx0LmRhdGE7XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBObyByZXNwb25zZSBmb3VuZCBmb3Igcm91dGVJZCBcIiR7cm91dGVJZH1cImApO1xuICB9XG59XG5mdW5jdGlvbiBjcmVhdGVEZWZlcnJlZDIoKSB7XG4gIGxldCByZXNvbHZlO1xuICBsZXQgcmVqZWN0O1xuICBsZXQgcHJvbWlzZSA9IG5ldyBQcm9taXNlKChyZXMsIHJlaikgPT4ge1xuICAgIHJlc29sdmUgPSBhc3luYyAodmFsKSA9PiB7XG4gICAgICByZXModmFsKTtcbiAgICAgIHRyeSB7XG4gICAgICAgIGF3YWl0IHByb21pc2U7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICB9XG4gICAgfTtcbiAgICByZWplY3QgPSBhc3luYyAoZXJyb3IpID0+IHtcbiAgICAgIHJlaihlcnJvcik7XG4gICAgICB0cnkge1xuICAgICAgICBhd2FpdCBwcm9taXNlO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgfVxuICAgIH07XG4gIH0pO1xuICByZXR1cm4ge1xuICAgIHByb21pc2UsXG4gICAgLy9AdHMtaWdub3JlXG4gICAgcmVzb2x2ZSxcbiAgICAvL0B0cy1pZ25vcmVcbiAgICByZWplY3RcbiAgfTtcbn1cblxuLy8gbGliL2RvbS9zc3IvZm9nLW9mLXdhci50c1xudmFyIFJlYWN0OCA9IF9fdG9FU00ocmVxdWlyZShcInJlYWN0XCIpKTtcblxuLy8gbGliL2RvbS9zc3Ivcm91dGVzLnRzeFxudmFyIFJlYWN0NyA9IF9fdG9FU00ocmVxdWlyZShcInJlYWN0XCIpKTtcblxuLy8gbGliL2RvbS9zc3IvZXJyb3JCb3VuZGFyaWVzLnRzeFxudmFyIFJlYWN0NSA9IF9fdG9FU00ocmVxdWlyZShcInJlYWN0XCIpKTtcbnZhciBSZW1peEVycm9yQm91bmRhcnkgPSBjbGFzcyBleHRlbmRzIFJlYWN0NS5Db21wb25lbnQge1xuICBjb25zdHJ1Y3Rvcihwcm9wcykge1xuICAgIHN1cGVyKHByb3BzKTtcbiAgICB0aGlzLnN0YXRlID0geyBlcnJvcjogcHJvcHMuZXJyb3IgfHwgbnVsbCwgbG9jYXRpb246IHByb3BzLmxvY2F0aW9uIH07XG4gIH1cbiAgc3RhdGljIGdldERlcml2ZWRTdGF0ZUZyb21FcnJvcihlcnJvcikge1xuICAgIHJldHVybiB7IGVycm9yIH07XG4gIH1cbiAgc3RhdGljIGdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyhwcm9wcywgc3RhdGUpIHtcbiAgICBpZiAoc3RhdGUubG9jYXRpb24gIT09IHByb3BzLmxvY2F0aW9uKSB7XG4gICAgICByZXR1cm4geyBlcnJvcjogcHJvcHMuZXJyb3IgfHwgbnVsbCwgbG9jYXRpb246IHByb3BzLmxvY2F0aW9uIH07XG4gICAgfVxuICAgIHJldHVybiB7IGVycm9yOiBwcm9wcy5lcnJvciB8fCBzdGF0ZS5lcnJvciwgbG9jYXRpb246IHN0YXRlLmxvY2F0aW9uIH07XG4gIH1cbiAgcmVuZGVyKCkge1xuICAgIGlmICh0aGlzLnN0YXRlLmVycm9yKSB7XG4gICAgICByZXR1cm4gLyogQF9fUFVSRV9fICovIFJlYWN0NS5jcmVhdGVFbGVtZW50KFxuICAgICAgICBSZW1peFJvb3REZWZhdWx0RXJyb3JCb3VuZGFyeSxcbiAgICAgICAge1xuICAgICAgICAgIGVycm9yOiB0aGlzLnN0YXRlLmVycm9yLFxuICAgICAgICAgIGlzT3V0c2lkZVJlbWl4QXBwOiB0cnVlXG4gICAgICAgIH1cbiAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0aGlzLnByb3BzLmNoaWxkcmVuO1xuICAgIH1cbiAgfVxufTtcbmZ1bmN0aW9uIFJlbWl4Um9vdERlZmF1bHRFcnJvckJvdW5kYXJ5KHtcbiAgZXJyb3IsXG4gIGlzT3V0c2lkZVJlbWl4QXBwXG59KSB7XG4gIGNvbnNvbGUuZXJyb3IoZXJyb3IpO1xuICBsZXQgaGV5RGV2ZWxvcGVyID0gLyogQF9fUFVSRV9fICovIFJlYWN0NS5jcmVhdGVFbGVtZW50KFxuICAgIFwic2NyaXB0XCIsXG4gICAge1xuICAgICAgZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUw6IHtcbiAgICAgICAgX19odG1sOiBgXG4gICAgICAgIGNvbnNvbGUubG9nKFxuICAgICAgICAgIFwiXFx1ezFGNEJGfSBIZXkgZGV2ZWxvcGVyIFxcdXsxRjQ0Qn0uIFlvdSBjYW4gcHJvdmlkZSBhIHdheSBiZXR0ZXIgVVggdGhhbiB0aGlzIHdoZW4geW91ciBhcHAgdGhyb3dzIGVycm9ycy4gQ2hlY2sgb3V0IGh0dHBzOi8vcmVtaXgucnVuL2d1aWRlcy9lcnJvcnMgZm9yIG1vcmUgaW5mb3JtYXRpb24uXCJcbiAgICAgICAgKTtcbiAgICAgIGBcbiAgICAgIH1cbiAgICB9XG4gICk7XG4gIGlmIChpc1JvdXRlRXJyb3JSZXNwb25zZShlcnJvcikpIHtcbiAgICByZXR1cm4gLyogQF9fUFVSRV9fICovIFJlYWN0NS5jcmVhdGVFbGVtZW50KEJvdW5kYXJ5U2hlbGwsIHsgdGl0bGU6IFwiVW5oYW5kbGVkIFRocm93biBSZXNwb25zZSFcIiB9LCAvKiBAX19QVVJFX18gKi8gUmVhY3Q1LmNyZWF0ZUVsZW1lbnQoXCJoMVwiLCB7IHN0eWxlOiB7IGZvbnRTaXplOiBcIjI0cHhcIiB9IH0sIGVycm9yLnN0YXR1cywgXCIgXCIsIGVycm9yLnN0YXR1c1RleHQpLCBoZXlEZXZlbG9wZXIpO1xuICB9XG4gIGxldCBlcnJvckluc3RhbmNlO1xuICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgIGVycm9ySW5zdGFuY2UgPSBlcnJvcjtcbiAgfSBlbHNlIHtcbiAgICBsZXQgZXJyb3JTdHJpbmcgPSBlcnJvciA9PSBudWxsID8gXCJVbmtub3duIEVycm9yXCIgOiB0eXBlb2YgZXJyb3IgPT09IFwib2JqZWN0XCIgJiYgXCJ0b1N0cmluZ1wiIGluIGVycm9yID8gZXJyb3IudG9TdHJpbmcoKSA6IEpTT04uc3RyaW5naWZ5KGVycm9yKTtcbiAgICBlcnJvckluc3RhbmNlID0gbmV3IEVycm9yKGVycm9yU3RyaW5nKTtcbiAgfVxuICByZXR1cm4gLyogQF9fUFVSRV9fICovIFJlYWN0NS5jcmVhdGVFbGVtZW50KFxuICAgIEJvdW5kYXJ5U2hlbGwsXG4gICAge1xuICAgICAgdGl0bGU6IFwiQXBwbGljYXRpb24gRXJyb3IhXCIsXG4gICAgICBpc091dHNpZGVSZW1peEFwcFxuICAgIH0sXG4gICAgLyogQF9fUFVSRV9fICovIFJlYWN0NS5jcmVhdGVFbGVtZW50KFwiaDFcIiwgeyBzdHlsZTogeyBmb250U2l6ZTogXCIyNHB4XCIgfSB9LCBcIkFwcGxpY2F0aW9uIEVycm9yXCIpLFxuICAgIC8qIEBfX1BVUkVfXyAqLyBSZWFjdDUuY3JlYXRlRWxlbWVudChcbiAgICAgIFwicHJlXCIsXG4gICAgICB7XG4gICAgICAgIHN0eWxlOiB7XG4gICAgICAgICAgcGFkZGluZzogXCIycmVtXCIsXG4gICAgICAgICAgYmFja2dyb3VuZDogXCJoc2xhKDEwLCA1MCUsIDUwJSwgMC4xKVwiLFxuICAgICAgICAgIGNvbG9yOiBcInJlZFwiLFxuICAgICAgICAgIG92ZXJmbG93OiBcImF1dG9cIlxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgZXJyb3JJbnN0YW5jZS5zdGFja1xuICAgICksXG4gICAgaGV5RGV2ZWxvcGVyXG4gICk7XG59XG5mdW5jdGlvbiBCb3VuZGFyeVNoZWxsKHtcbiAgdGl0bGUsXG4gIHJlbmRlclNjcmlwdHMsXG4gIGlzT3V0c2lkZVJlbWl4QXBwLFxuICBjaGlsZHJlblxufSkge1xuICBsZXQgeyByb3V0ZU1vZHVsZXMgfSA9IHVzZUZyYW1ld29ya0NvbnRleHQoKTtcbiAgaWYgKHJvdXRlTW9kdWxlcy5yb290Py5MYXlvdXQgJiYgIWlzT3V0c2lkZVJlbWl4QXBwKSB7XG4gICAgcmV0dXJuIGNoaWxkcmVuO1xuICB9XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8gUmVhY3Q1LmNyZWF0ZUVsZW1lbnQoXCJodG1sXCIsIHsgbGFuZzogXCJlblwiIH0sIC8qIEBfX1BVUkVfXyAqLyBSZWFjdDUuY3JlYXRlRWxlbWVudChcImhlYWRcIiwgbnVsbCwgLyogQF9fUFVSRV9fICovIFJlYWN0NS5jcmVhdGVFbGVtZW50KFwibWV0YVwiLCB7IGNoYXJTZXQ6IFwidXRmLThcIiB9KSwgLyogQF9fUFVSRV9fICovIFJlYWN0NS5jcmVhdGVFbGVtZW50KFxuICAgIFwibWV0YVwiLFxuICAgIHtcbiAgICAgIG5hbWU6IFwidmlld3BvcnRcIixcbiAgICAgIGNvbnRlbnQ6IFwid2lkdGg9ZGV2aWNlLXdpZHRoLGluaXRpYWwtc2NhbGU9MSx2aWV3cG9ydC1maXQ9Y292ZXJcIlxuICAgIH1cbiAgKSwgLyogQF9fUFVSRV9fICovIFJlYWN0NS5jcmVhdGVFbGVtZW50KFwidGl0bGVcIiwgbnVsbCwgdGl0bGUpKSwgLyogQF9fUFVSRV9fICovIFJlYWN0NS5jcmVhdGVFbGVtZW50KFwiYm9keVwiLCBudWxsLCAvKiBAX19QVVJFX18gKi8gUmVhY3Q1LmNyZWF0ZUVsZW1lbnQoXCJtYWluXCIsIHsgc3R5bGU6IHsgZm9udEZhbWlseTogXCJzeXN0ZW0tdWksIHNhbnMtc2VyaWZcIiwgcGFkZGluZzogXCIycmVtXCIgfSB9LCBjaGlsZHJlbiwgcmVuZGVyU2NyaXB0cyA/IC8qIEBfX1BVUkVfXyAqLyBSZWFjdDUuY3JlYXRlRWxlbWVudChTY3JpcHRzLCBudWxsKSA6IG51bGwpKSk7XG59XG5cbi8vIGxpYi9kb20vc3NyL2ZhbGxiYWNrLnRzeFxudmFyIFJlYWN0NiA9IF9fdG9FU00ocmVxdWlyZShcInJlYWN0XCIpKTtcbmZ1bmN0aW9uIFJlbWl4Um9vdERlZmF1bHRIeWRyYXRlRmFsbGJhY2soKSB7XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8gUmVhY3Q2LmNyZWF0ZUVsZW1lbnQoQm91bmRhcnlTaGVsbCwgeyB0aXRsZTogXCJMb2FkaW5nLi4uXCIsIHJlbmRlclNjcmlwdHM6IHRydWUgfSwgLyogQF9fUFVSRV9fICovIFJlYWN0Ni5jcmVhdGVFbGVtZW50KFxuICAgIFwic2NyaXB0XCIsXG4gICAge1xuICAgICAgZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUw6IHtcbiAgICAgICAgX19odG1sOiBgXG4gICAgICAgICAgICAgIGNvbnNvbGUubG9nKFxuICAgICAgICAgICAgICAgIFwiXFx1ezFGNEJGfSBIZXkgZGV2ZWxvcGVyIFxcdXsxRjQ0Qn0uIFlvdSBjYW4gcHJvdmlkZSBhIHdheSBiZXR0ZXIgVVggdGhhbiB0aGlzIFwiICtcbiAgICAgICAgICAgICAgICBcIndoZW4geW91ciBhcHAgaXMgbG9hZGluZyBKUyBtb2R1bGVzIGFuZC9vciBydW5uaW5nIFxcYGNsaWVudExvYWRlclxcYCBcIiArXG4gICAgICAgICAgICAgICAgXCJmdW5jdGlvbnMuIENoZWNrIG91dCBodHRwczovL3JlbWl4LnJ1bi9yb3V0ZS9oeWRyYXRlLWZhbGxiYWNrIFwiICtcbiAgICAgICAgICAgICAgICBcImZvciBtb3JlIGluZm9ybWF0aW9uLlwiXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICBgXG4gICAgICB9XG4gICAgfVxuICApKTtcbn1cblxuLy8gbGliL2RvbS9zc3Ivcm91dGVzLnRzeFxuZnVuY3Rpb24gZ3JvdXBSb3V0ZXNCeVBhcmVudElkKG1hbmlmZXN0KSB7XG4gIGxldCByb3V0ZXMgPSB7fTtcbiAgT2JqZWN0LnZhbHVlcyhtYW5pZmVzdCkuZm9yRWFjaCgocm91dGUpID0+IHtcbiAgICBpZiAocm91dGUpIHtcbiAgICAgIGxldCBwYXJlbnRJZCA9IHJvdXRlLnBhcmVudElkIHx8IFwiXCI7XG4gICAgICBpZiAoIXJvdXRlc1twYXJlbnRJZF0pIHtcbiAgICAgICAgcm91dGVzW3BhcmVudElkXSA9IFtdO1xuICAgICAgfVxuICAgICAgcm91dGVzW3BhcmVudElkXS5wdXNoKHJvdXRlKTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gcm91dGVzO1xufVxuZnVuY3Rpb24gZ2V0Um91dGVDb21wb25lbnRzKHJvdXRlLCByb3V0ZU1vZHVsZSwgaXNTcGFNb2RlKSB7XG4gIGxldCBDb21wb25lbnQ0ID0gZ2V0Um91dGVNb2R1bGVDb21wb25lbnQocm91dGVNb2R1bGUpO1xuICBsZXQgSHlkcmF0ZUZhbGxiYWNrID0gcm91dGVNb2R1bGUuSHlkcmF0ZUZhbGxiYWNrICYmICghaXNTcGFNb2RlIHx8IHJvdXRlLmlkID09PSBcInJvb3RcIikgPyByb3V0ZU1vZHVsZS5IeWRyYXRlRmFsbGJhY2sgOiByb3V0ZS5pZCA9PT0gXCJyb290XCIgPyBSZW1peFJvb3REZWZhdWx0SHlkcmF0ZUZhbGxiYWNrIDogdm9pZCAwO1xuICBsZXQgRXJyb3JCb3VuZGFyeSA9IHJvdXRlTW9kdWxlLkVycm9yQm91bmRhcnkgPyByb3V0ZU1vZHVsZS5FcnJvckJvdW5kYXJ5IDogcm91dGUuaWQgPT09IFwicm9vdFwiID8gKCkgPT4gLyogQF9fUFVSRV9fICovIFJlYWN0Ny5jcmVhdGVFbGVtZW50KFJlbWl4Um9vdERlZmF1bHRFcnJvckJvdW5kYXJ5LCB7IGVycm9yOiB1c2VSb3V0ZUVycm9yKCkgfSkgOiB2b2lkIDA7XG4gIGlmIChyb3V0ZS5pZCA9PT0gXCJyb290XCIgJiYgcm91dGVNb2R1bGUuTGF5b3V0KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLkNvbXBvbmVudDQgPyB7XG4gICAgICAgIGVsZW1lbnQ6IC8qIEBfX1BVUkVfXyAqLyBSZWFjdDcuY3JlYXRlRWxlbWVudChyb3V0ZU1vZHVsZS5MYXlvdXQsIG51bGwsIC8qIEBfX1BVUkVfXyAqLyBSZWFjdDcuY3JlYXRlRWxlbWVudChDb21wb25lbnQ0LCBudWxsKSlcbiAgICAgIH0gOiB7IENvbXBvbmVudDogQ29tcG9uZW50NCB9LFxuICAgICAgLi4uRXJyb3JCb3VuZGFyeSA/IHtcbiAgICAgICAgZXJyb3JFbGVtZW50OiAvKiBAX19QVVJFX18gKi8gUmVhY3Q3LmNyZWF0ZUVsZW1lbnQocm91dGVNb2R1bGUuTGF5b3V0LCBudWxsLCAvKiBAX19QVVJFX18gKi8gUmVhY3Q3LmNyZWF0ZUVsZW1lbnQoRXJyb3JCb3VuZGFyeSwgbnVsbCkpXG4gICAgICB9IDogeyBFcnJvckJvdW5kYXJ5IH0sXG4gICAgICAuLi5IeWRyYXRlRmFsbGJhY2sgPyB7XG4gICAgICAgIGh5ZHJhdGVGYWxsYmFja0VsZW1lbnQ6IC8qIEBfX1BVUkVfXyAqLyBSZWFjdDcuY3JlYXRlRWxlbWVudChyb3V0ZU1vZHVsZS5MYXlvdXQsIG51bGwsIC8qIEBfX1BVUkVfXyAqLyBSZWFjdDcuY3JlYXRlRWxlbWVudChIeWRyYXRlRmFsbGJhY2ssIG51bGwpKVxuICAgICAgfSA6IHsgSHlkcmF0ZUZhbGxiYWNrIH1cbiAgICB9O1xuICB9XG4gIHJldHVybiB7IENvbXBvbmVudDogQ29tcG9uZW50NCwgRXJyb3JCb3VuZGFyeSwgSHlkcmF0ZUZhbGxiYWNrIH07XG59XG5mdW5jdGlvbiBjcmVhdGVTZXJ2ZXJSb3V0ZXMobWFuaWZlc3QsIHJvdXRlTW9kdWxlcywgZnV0dXJlLCBpc1NwYU1vZGUsIHBhcmVudElkID0gXCJcIiwgcm91dGVzQnlQYXJlbnRJZCA9IGdyb3VwUm91dGVzQnlQYXJlbnRJZChtYW5pZmVzdCksIHNwYU1vZGVMYXp5UHJvbWlzZSA9IFByb21pc2UucmVzb2x2ZSh7IENvbXBvbmVudDogKCkgPT4gbnVsbCB9KSkge1xuICByZXR1cm4gKHJvdXRlc0J5UGFyZW50SWRbcGFyZW50SWRdIHx8IFtdKS5tYXAoKHJvdXRlKSA9PiB7XG4gICAgbGV0IHJvdXRlTW9kdWxlID0gcm91dGVNb2R1bGVzW3JvdXRlLmlkXTtcbiAgICBpbnZhcmlhbnQyKFxuICAgICAgcm91dGVNb2R1bGUsXG4gICAgICBcIk5vIGByb3V0ZU1vZHVsZWAgYXZhaWxhYmxlIHRvIGNyZWF0ZSBzZXJ2ZXIgcm91dGVzXCJcbiAgICApO1xuICAgIGxldCBkYXRhUm91dGUgPSB7XG4gICAgICAuLi5nZXRSb3V0ZUNvbXBvbmVudHMocm91dGUsIHJvdXRlTW9kdWxlLCBpc1NwYU1vZGUpLFxuICAgICAgY2FzZVNlbnNpdGl2ZTogcm91dGUuY2FzZVNlbnNpdGl2ZSxcbiAgICAgIGlkOiByb3V0ZS5pZCxcbiAgICAgIGluZGV4OiByb3V0ZS5pbmRleCxcbiAgICAgIHBhdGg6IHJvdXRlLnBhdGgsXG4gICAgICBoYW5kbGU6IHJvdXRlTW9kdWxlLmhhbmRsZSxcbiAgICAgIC8vIEZvciBTUEEgTW9kZSwgYWxsIHJvdXRlcyBhcmUgbGF6eSBleGNlcHQgcm9vdC4gIEhvd2V2ZXIgd2UgdGVsbCB0aGVcbiAgICAgIC8vIHJvdXRlciByb290IGlzIGFsc28gbGF6eSBoZXJlIHRvbyBzaW5jZSB3ZSBkb24ndCBuZWVkIGEgZnVsbFxuICAgICAgLy8gaW1wbGVtZW50YXRpb24gLSB3ZSBqdXN0IG5lZWQgYSBgbGF6eWAgcHJvcCB0byB0ZWxsIHRoZSBSUiByZW5kZXJpbmdcbiAgICAgIC8vIHdoZXJlIHRvIHN0b3Agd2hpY2ggaXMgYWx3YXlzIGF0IHRoZSByb290IHJvdXRlIGluIFNQQSBtb2RlXG4gICAgICBsYXp5OiBpc1NwYU1vZGUgPyAoKSA9PiBzcGFNb2RlTGF6eVByb21pc2UgOiB2b2lkIDAsXG4gICAgICAvLyBGb3IgcGFydGlhbCBoeWRyYXRpb24gcmVuZGVyaW5nLCB3ZSBuZWVkIHRvIGluZGljYXRlIHdoZW4gdGhlIHJvdXRlXG4gICAgICAvLyBoYXMgYSBsb2FkZXIvY2xpZW50TG9hZGVyLCBidXQgaXQgd29uJ3QgZXZlciBiZSBjYWxsZWQgZHVyaW5nIHRoZSBzdGF0aWNcbiAgICAgIC8vIHJlbmRlciwgc28ganVzdCBnaXZlIGl0IGEgbm8tb3AgZnVuY3Rpb24gc28gd2UgY2FuIHJlbmRlciBkb3duIHRvIHRoZVxuICAgICAgLy8gcHJvcGVyIGZhbGxiYWNrXG4gICAgICBsb2FkZXI6IHJvdXRlLmhhc0xvYWRlciB8fCByb3V0ZS5oYXNDbGllbnRMb2FkZXIgPyAoKSA9PiBudWxsIDogdm9pZCAwXG4gICAgICAvLyBXZSBkb24ndCBuZWVkIGFjdGlvbi9zaG91bGRSZXZhbGlkYXRlIG9uIHRoZXNlIHJvdXRlcyBzaW5jZSB0aGV5J3JlXG4gICAgICAvLyBmb3IgYSBzdGF0aWMgcmVuZGVyXG4gICAgfTtcbiAgICBsZXQgY2hpbGRyZW4gPSBjcmVhdGVTZXJ2ZXJSb3V0ZXMoXG4gICAgICBtYW5pZmVzdCxcbiAgICAgIHJvdXRlTW9kdWxlcyxcbiAgICAgIGZ1dHVyZSxcbiAgICAgIGlzU3BhTW9kZSxcbiAgICAgIHJvdXRlLmlkLFxuICAgICAgcm91dGVzQnlQYXJlbnRJZCxcbiAgICAgIHNwYU1vZGVMYXp5UHJvbWlzZVxuICAgICk7XG4gICAgaWYgKGNoaWxkcmVuLmxlbmd0aCA+IDApIGRhdGFSb3V0ZS5jaGlsZHJlbiA9IGNoaWxkcmVuO1xuICAgIHJldHVybiBkYXRhUm91dGU7XG4gIH0pO1xufVxuZnVuY3Rpb24gY3JlYXRlQ2xpZW50Um91dGVzV2l0aEhNUlJldmFsaWRhdGlvbk9wdE91dChuZWVkc1JldmFsaWRhdGlvbiwgbWFuaWZlc3QsIHJvdXRlTW9kdWxlc0NhY2hlLCBpbml0aWFsU3RhdGUsIGZ1dHVyZSwgaXNTcGFNb2RlKSB7XG4gIHJldHVybiBjcmVhdGVDbGllbnRSb3V0ZXMoXG4gICAgbWFuaWZlc3QsXG4gICAgcm91dGVNb2R1bGVzQ2FjaGUsXG4gICAgaW5pdGlhbFN0YXRlLFxuICAgIGlzU3BhTW9kZSxcbiAgICBcIlwiLFxuICAgIGdyb3VwUm91dGVzQnlQYXJlbnRJZChtYW5pZmVzdCksXG4gICAgbmVlZHNSZXZhbGlkYXRpb25cbiAgKTtcbn1cbmZ1bmN0aW9uIHByZXZlbnRJbnZhbGlkU2VydmVySGFuZGxlckNhbGwodHlwZSwgcm91dGUsIGlzU3BhTW9kZSkge1xuICBpZiAoaXNTcGFNb2RlKSB7XG4gICAgbGV0IGZuMiA9IHR5cGUgPT09IFwiYWN0aW9uXCIgPyBcInNlcnZlckFjdGlvbigpXCIgOiBcInNlcnZlckxvYWRlcigpXCI7XG4gICAgbGV0IG1zZzIgPSBgWW91IGNhbm5vdCBjYWxsICR7Zm4yfSBpbiBTUEEgTW9kZSAocm91dGVJZDogXCIke3JvdXRlLmlkfVwiKWA7XG4gICAgY29uc29sZS5lcnJvcihtc2cyKTtcbiAgICB0aHJvdyBuZXcgRXJyb3JSZXNwb25zZUltcGwoNDAwLCBcIkJhZCBSZXF1ZXN0XCIsIG5ldyBFcnJvcihtc2cyKSwgdHJ1ZSk7XG4gIH1cbiAgbGV0IGZuID0gdHlwZSA9PT0gXCJhY3Rpb25cIiA/IFwic2VydmVyQWN0aW9uKClcIiA6IFwic2VydmVyTG9hZGVyKClcIjtcbiAgbGV0IG1zZyA9IGBZb3UgYXJlIHRyeWluZyB0byBjYWxsICR7Zm59IG9uIGEgcm91dGUgdGhhdCBkb2VzIG5vdCBoYXZlIGEgc2VydmVyICR7dHlwZX0gKHJvdXRlSWQ6IFwiJHtyb3V0ZS5pZH1cIilgO1xuICBpZiAodHlwZSA9PT0gXCJsb2FkZXJcIiAmJiAhcm91dGUuaGFzTG9hZGVyIHx8IHR5cGUgPT09IFwiYWN0aW9uXCIgJiYgIXJvdXRlLmhhc0FjdGlvbikge1xuICAgIGNvbnNvbGUuZXJyb3IobXNnKTtcbiAgICB0aHJvdyBuZXcgRXJyb3JSZXNwb25zZUltcGwoNDAwLCBcIkJhZCBSZXF1ZXN0XCIsIG5ldyBFcnJvcihtc2cpLCB0cnVlKTtcbiAgfVxufVxuZnVuY3Rpb24gbm9BY3Rpb25EZWZpbmVkRXJyb3IodHlwZSwgcm91dGVJZCkge1xuICBsZXQgYXJ0aWNsZSA9IHR5cGUgPT09IFwiY2xpZW50QWN0aW9uXCIgPyBcImFcIiA6IFwiYW5cIjtcbiAgbGV0IG1zZyA9IGBSb3V0ZSBcIiR7cm91dGVJZH1cIiBkb2VzIG5vdCBoYXZlICR7YXJ0aWNsZX0gJHt0eXBlfSwgYnV0IHlvdSBhcmUgdHJ5aW5nIHRvIHN1Ym1pdCB0byBpdC4gVG8gZml4IHRoaXMsIHBsZWFzZSBhZGQgJHthcnRpY2xlfSBcXGAke3R5cGV9XFxgIGZ1bmN0aW9uIHRvIHRoZSByb3V0ZWA7XG4gIGNvbnNvbGUuZXJyb3IobXNnKTtcbiAgdGhyb3cgbmV3IEVycm9yUmVzcG9uc2VJbXBsKDQwNSwgXCJNZXRob2QgTm90IEFsbG93ZWRcIiwgbmV3IEVycm9yKG1zZyksIHRydWUpO1xufVxuZnVuY3Rpb24gY3JlYXRlQ2xpZW50Um91dGVzKG1hbmlmZXN0LCByb3V0ZU1vZHVsZXNDYWNoZSwgaW5pdGlhbFN0YXRlLCBpc1NwYU1vZGUsIHBhcmVudElkID0gXCJcIiwgcm91dGVzQnlQYXJlbnRJZCA9IGdyb3VwUm91dGVzQnlQYXJlbnRJZChtYW5pZmVzdCksIG5lZWRzUmV2YWxpZGF0aW9uKSB7XG4gIHJldHVybiAocm91dGVzQnlQYXJlbnRJZFtwYXJlbnRJZF0gfHwgW10pLm1hcCgocm91dGUpID0+IHtcbiAgICBsZXQgcm91dGVNb2R1bGUgPSByb3V0ZU1vZHVsZXNDYWNoZVtyb3V0ZS5pZF07XG4gICAgZnVuY3Rpb24gZmV0Y2hTZXJ2ZXJIYW5kbGVyKHNpbmdsZUZldGNoKSB7XG4gICAgICBpbnZhcmlhbnQyKFxuICAgICAgICB0eXBlb2Ygc2luZ2xlRmV0Y2ggPT09IFwiZnVuY3Rpb25cIixcbiAgICAgICAgXCJObyBzaW5nbGUgZmV0Y2ggZnVuY3Rpb24gYXZhaWxhYmxlIGZvciByb3V0ZSBoYW5kbGVyXCJcbiAgICAgICk7XG4gICAgICByZXR1cm4gc2luZ2xlRmV0Y2goKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZmV0Y2hTZXJ2ZXJMb2FkZXIoc2luZ2xlRmV0Y2gpIHtcbiAgICAgIGlmICghcm91dGUuaGFzTG9hZGVyKSByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKG51bGwpO1xuICAgICAgcmV0dXJuIGZldGNoU2VydmVySGFuZGxlcihzaW5nbGVGZXRjaCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGZldGNoU2VydmVyQWN0aW9uKHNpbmdsZUZldGNoKSB7XG4gICAgICBpZiAoIXJvdXRlLmhhc0FjdGlvbikge1xuICAgICAgICB0aHJvdyBub0FjdGlvbkRlZmluZWRFcnJvcihcImFjdGlvblwiLCByb3V0ZS5pZCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZmV0Y2hTZXJ2ZXJIYW5kbGVyKHNpbmdsZUZldGNoKTtcbiAgICB9XG4gICAgYXN5bmMgZnVuY3Rpb24gcHJlZmV0Y2hTdHlsZXNBbmRDYWxsSGFuZGxlcihoYW5kbGVyKSB7XG4gICAgICBsZXQgY2FjaGVkTW9kdWxlID0gcm91dGVNb2R1bGVzQ2FjaGVbcm91dGUuaWRdO1xuICAgICAgbGV0IGxpbmtQcmVmZXRjaFByb21pc2UgPSBjYWNoZWRNb2R1bGUgPyBwcmVmZXRjaFN0eWxlTGlua3Mocm91dGUsIGNhY2hlZE1vZHVsZSkgOiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBoYW5kbGVyKCk7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBhd2FpdCBsaW5rUHJlZmV0Y2hQcm9taXNlO1xuICAgICAgfVxuICAgIH1cbiAgICBsZXQgZGF0YVJvdXRlID0ge1xuICAgICAgaWQ6IHJvdXRlLmlkLFxuICAgICAgaW5kZXg6IHJvdXRlLmluZGV4LFxuICAgICAgcGF0aDogcm91dGUucGF0aFxuICAgIH07XG4gICAgaWYgKHJvdXRlTW9kdWxlKSB7XG4gICAgICBPYmplY3QuYXNzaWduKGRhdGFSb3V0ZSwge1xuICAgICAgICAuLi5kYXRhUm91dGUsXG4gICAgICAgIC4uLmdldFJvdXRlQ29tcG9uZW50cyhyb3V0ZSwgcm91dGVNb2R1bGUsIGlzU3BhTW9kZSksXG4gICAgICAgIGhhbmRsZTogcm91dGVNb2R1bGUuaGFuZGxlLFxuICAgICAgICBzaG91bGRSZXZhbGlkYXRlOiBnZXRTaG91bGRSZXZhbGlkYXRlRnVuY3Rpb24oXG4gICAgICAgICAgcm91dGVNb2R1bGUsXG4gICAgICAgICAgcm91dGUuaWQsXG4gICAgICAgICAgbmVlZHNSZXZhbGlkYXRpb25cbiAgICAgICAgKVxuICAgICAgfSk7XG4gICAgICBsZXQgaGFzSW5pdGlhbERhdGEgPSBpbml0aWFsU3RhdGUgJiYgaW5pdGlhbFN0YXRlLmxvYWRlckRhdGEgJiYgcm91dGUuaWQgaW4gaW5pdGlhbFN0YXRlLmxvYWRlckRhdGE7XG4gICAgICBsZXQgaW5pdGlhbERhdGEgPSBoYXNJbml0aWFsRGF0YSA/IGluaXRpYWxTdGF0ZT8ubG9hZGVyRGF0YT8uW3JvdXRlLmlkXSA6IHZvaWQgMDtcbiAgICAgIGxldCBoYXNJbml0aWFsRXJyb3IgPSBpbml0aWFsU3RhdGUgJiYgaW5pdGlhbFN0YXRlLmVycm9ycyAmJiByb3V0ZS5pZCBpbiBpbml0aWFsU3RhdGUuZXJyb3JzO1xuICAgICAgbGV0IGluaXRpYWxFcnJvciA9IGhhc0luaXRpYWxFcnJvciA/IGluaXRpYWxTdGF0ZT8uZXJyb3JzPy5bcm91dGUuaWRdIDogdm9pZCAwO1xuICAgICAgbGV0IGlzSHlkcmF0aW9uUmVxdWVzdCA9IG5lZWRzUmV2YWxpZGF0aW9uID09IG51bGwgJiYgKHJvdXRlTW9kdWxlLmNsaWVudExvYWRlcj8uaHlkcmF0ZSA9PT0gdHJ1ZSB8fCAhcm91dGUuaGFzTG9hZGVyKTtcbiAgICAgIGRhdGFSb3V0ZS5sb2FkZXIgPSBhc3luYyAoeyByZXF1ZXN0LCBwYXJhbXMgfSwgc2luZ2xlRmV0Y2gpID0+IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBsZXQgcmVzdWx0ID0gYXdhaXQgcHJlZmV0Y2hTdHlsZXNBbmRDYWxsSGFuZGxlcihhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICBpbnZhcmlhbnQyKFxuICAgICAgICAgICAgICByb3V0ZU1vZHVsZSxcbiAgICAgICAgICAgICAgXCJObyBgcm91dGVNb2R1bGVgIGF2YWlsYWJsZSBmb3IgY3JpdGljYWwtcm91dGUgbG9hZGVyXCJcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBpZiAoIXJvdXRlTW9kdWxlLmNsaWVudExvYWRlcikge1xuICAgICAgICAgICAgICBpZiAoaXNTcGFNb2RlKSByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgcmV0dXJuIGZldGNoU2VydmVyTG9hZGVyKHNpbmdsZUZldGNoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByb3V0ZU1vZHVsZS5jbGllbnRMb2FkZXIoe1xuICAgICAgICAgICAgICByZXF1ZXN0LFxuICAgICAgICAgICAgICBwYXJhbXMsXG4gICAgICAgICAgICAgIGFzeW5jIHNlcnZlckxvYWRlcigpIHtcbiAgICAgICAgICAgICAgICBwcmV2ZW50SW52YWxpZFNlcnZlckhhbmRsZXJDYWxsKFwibG9hZGVyXCIsIHJvdXRlLCBpc1NwYU1vZGUpO1xuICAgICAgICAgICAgICAgIGlmIChpc0h5ZHJhdGlvblJlcXVlc3QpIHtcbiAgICAgICAgICAgICAgICAgIGlmIChoYXNJbml0aWFsRGF0YSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaW5pdGlhbERhdGE7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBpZiAoaGFzSW5pdGlhbEVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IGluaXRpYWxFcnJvcjtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZldGNoU2VydmVyTG9hZGVyKHNpbmdsZUZldGNoKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICBpc0h5ZHJhdGlvblJlcXVlc3QgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIGRhdGFSb3V0ZS5sb2FkZXIuaHlkcmF0ZSA9IHNob3VsZEh5ZHJhdGVSb3V0ZUxvYWRlcihcbiAgICAgICAgcm91dGUsXG4gICAgICAgIHJvdXRlTW9kdWxlLFxuICAgICAgICBpc1NwYU1vZGVcbiAgICAgICk7XG4gICAgICBkYXRhUm91dGUuYWN0aW9uID0gKHsgcmVxdWVzdCwgcGFyYW1zIH0sIHNpbmdsZUZldGNoKSA9PiB7XG4gICAgICAgIHJldHVybiBwcmVmZXRjaFN0eWxlc0FuZENhbGxIYW5kbGVyKGFzeW5jICgpID0+IHtcbiAgICAgICAgICBpbnZhcmlhbnQyKFxuICAgICAgICAgICAgcm91dGVNb2R1bGUsXG4gICAgICAgICAgICBcIk5vIGByb3V0ZU1vZHVsZWAgYXZhaWxhYmxlIGZvciBjcml0aWNhbC1yb3V0ZSBhY3Rpb25cIlxuICAgICAgICAgICk7XG4gICAgICAgICAgaWYgKCFyb3V0ZU1vZHVsZS5jbGllbnRBY3Rpb24pIHtcbiAgICAgICAgICAgIGlmIChpc1NwYU1vZGUpIHtcbiAgICAgICAgICAgICAgdGhyb3cgbm9BY3Rpb25EZWZpbmVkRXJyb3IoXCJjbGllbnRBY3Rpb25cIiwgcm91dGUuaWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZldGNoU2VydmVyQWN0aW9uKHNpbmdsZUZldGNoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHJvdXRlTW9kdWxlLmNsaWVudEFjdGlvbih7XG4gICAgICAgICAgICByZXF1ZXN0LFxuICAgICAgICAgICAgcGFyYW1zLFxuICAgICAgICAgICAgYXN5bmMgc2VydmVyQWN0aW9uKCkge1xuICAgICAgICAgICAgICBwcmV2ZW50SW52YWxpZFNlcnZlckhhbmRsZXJDYWxsKFwiYWN0aW9uXCIsIHJvdXRlLCBpc1NwYU1vZGUpO1xuICAgICAgICAgICAgICByZXR1cm4gZmV0Y2hTZXJ2ZXJBY3Rpb24oc2luZ2xlRmV0Y2gpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICghcm91dGUuaGFzQ2xpZW50TG9hZGVyKSB7XG4gICAgICAgIGRhdGFSb3V0ZS5sb2FkZXIgPSAoeyByZXF1ZXN0IH0sIHNpbmdsZUZldGNoKSA9PiBwcmVmZXRjaFN0eWxlc0FuZENhbGxIYW5kbGVyKCgpID0+IHtcbiAgICAgICAgICBpZiAoaXNTcGFNb2RlKSByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKG51bGwpO1xuICAgICAgICAgIHJldHVybiBmZXRjaFNlcnZlckxvYWRlcihzaW5nbGVGZXRjaCk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgaWYgKCFyb3V0ZS5oYXNDbGllbnRBY3Rpb24pIHtcbiAgICAgICAgZGF0YVJvdXRlLmFjdGlvbiA9ICh7IHJlcXVlc3QgfSwgc2luZ2xlRmV0Y2gpID0+IHByZWZldGNoU3R5bGVzQW5kQ2FsbEhhbmRsZXIoKCkgPT4ge1xuICAgICAgICAgIGlmIChpc1NwYU1vZGUpIHtcbiAgICAgICAgICAgIHRocm93IG5vQWN0aW9uRGVmaW5lZEVycm9yKFwiY2xpZW50QWN0aW9uXCIsIHJvdXRlLmlkKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGZldGNoU2VydmVyQWN0aW9uKHNpbmdsZUZldGNoKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBkYXRhUm91dGUubGF6eSA9IGFzeW5jICgpID0+IHtcbiAgICAgICAgbGV0IG1vZCA9IGF3YWl0IGxvYWRSb3V0ZU1vZHVsZVdpdGhCbG9ja2luZ0xpbmtzKFxuICAgICAgICAgIHJvdXRlLFxuICAgICAgICAgIHJvdXRlTW9kdWxlc0NhY2hlXG4gICAgICAgICk7XG4gICAgICAgIGxldCBsYXp5Um91dGUgPSB7IC4uLm1vZCB9O1xuICAgICAgICBpZiAobW9kLmNsaWVudExvYWRlcikge1xuICAgICAgICAgIGxldCBjbGllbnRMb2FkZXIgPSBtb2QuY2xpZW50TG9hZGVyO1xuICAgICAgICAgIGxhenlSb3V0ZS5sb2FkZXIgPSAoYXJncywgc2luZ2xlRmV0Y2gpID0+IGNsaWVudExvYWRlcih7XG4gICAgICAgICAgICAuLi5hcmdzLFxuICAgICAgICAgICAgYXN5bmMgc2VydmVyTG9hZGVyKCkge1xuICAgICAgICAgICAgICBwcmV2ZW50SW52YWxpZFNlcnZlckhhbmRsZXJDYWxsKFwibG9hZGVyXCIsIHJvdXRlLCBpc1NwYU1vZGUpO1xuICAgICAgICAgICAgICByZXR1cm4gZmV0Y2hTZXJ2ZXJMb2FkZXIoc2luZ2xlRmV0Y2gpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtb2QuY2xpZW50QWN0aW9uKSB7XG4gICAgICAgICAgbGV0IGNsaWVudEFjdGlvbiA9IG1vZC5jbGllbnRBY3Rpb247XG4gICAgICAgICAgbGF6eVJvdXRlLmFjdGlvbiA9IChhcmdzLCBzaW5nbGVGZXRjaCkgPT4gY2xpZW50QWN0aW9uKHtcbiAgICAgICAgICAgIC4uLmFyZ3MsXG4gICAgICAgICAgICBhc3luYyBzZXJ2ZXJBY3Rpb24oKSB7XG4gICAgICAgICAgICAgIHByZXZlbnRJbnZhbGlkU2VydmVySGFuZGxlckNhbGwoXCJhY3Rpb25cIiwgcm91dGUsIGlzU3BhTW9kZSk7XG4gICAgICAgICAgICAgIHJldHVybiBmZXRjaFNlcnZlckFjdGlvbihzaW5nbGVGZXRjaCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAuLi5sYXp5Um91dGUubG9hZGVyID8geyBsb2FkZXI6IGxhenlSb3V0ZS5sb2FkZXIgfSA6IHt9LFxuICAgICAgICAgIC4uLmxhenlSb3V0ZS5hY3Rpb24gPyB7IGFjdGlvbjogbGF6eVJvdXRlLmFjdGlvbiB9IDoge30sXG4gICAgICAgICAgaGFzRXJyb3JCb3VuZGFyeTogbGF6eVJvdXRlLmhhc0Vycm9yQm91bmRhcnksXG4gICAgICAgICAgc2hvdWxkUmV2YWxpZGF0ZTogZ2V0U2hvdWxkUmV2YWxpZGF0ZUZ1bmN0aW9uKFxuICAgICAgICAgICAgbGF6eVJvdXRlLFxuICAgICAgICAgICAgcm91dGUuaWQsXG4gICAgICAgICAgICBuZWVkc1JldmFsaWRhdGlvblxuICAgICAgICAgICksXG4gICAgICAgICAgaGFuZGxlOiBsYXp5Um91dGUuaGFuZGxlLFxuICAgICAgICAgIC8vIE5vIG5lZWQgdG8gd3JhcCB0aGVzZSBpbiBsYXlvdXQgc2luY2UgdGhlIHJvb3Qgcm91dGUgaXMgbmV2ZXJcbiAgICAgICAgICAvLyBsb2FkZWQgdmlhIHJvdXRlLmxhenkoKVxuICAgICAgICAgIENvbXBvbmVudDogbGF6eVJvdXRlLkNvbXBvbmVudCxcbiAgICAgICAgICBFcnJvckJvdW5kYXJ5OiBsYXp5Um91dGUuRXJyb3JCb3VuZGFyeVxuICAgICAgICB9O1xuICAgICAgfTtcbiAgICB9XG4gICAgbGV0IGNoaWxkcmVuID0gY3JlYXRlQ2xpZW50Um91dGVzKFxuICAgICAgbWFuaWZlc3QsXG4gICAgICByb3V0ZU1vZHVsZXNDYWNoZSxcbiAgICAgIGluaXRpYWxTdGF0ZSxcbiAgICAgIGlzU3BhTW9kZSxcbiAgICAgIHJvdXRlLmlkLFxuICAgICAgcm91dGVzQnlQYXJlbnRJZCxcbiAgICAgIG5lZWRzUmV2YWxpZGF0aW9uXG4gICAgKTtcbiAgICBpZiAoY2hpbGRyZW4ubGVuZ3RoID4gMCkgZGF0YVJvdXRlLmNoaWxkcmVuID0gY2hpbGRyZW47XG4gICAgcmV0dXJuIGRhdGFSb3V0ZTtcbiAgfSk7XG59XG5mdW5jdGlvbiBnZXRTaG91bGRSZXZhbGlkYXRlRnVuY3Rpb24ocm91dGUsIHJvdXRlSWQsIG5lZWRzUmV2YWxpZGF0aW9uKSB7XG4gIGlmIChuZWVkc1JldmFsaWRhdGlvbikge1xuICAgIHJldHVybiB3cmFwU2hvdWxkUmV2YWxpZGF0ZUZvckhkcihcbiAgICAgIHJvdXRlSWQsXG4gICAgICByb3V0ZS5zaG91bGRSZXZhbGlkYXRlLFxuICAgICAgbmVlZHNSZXZhbGlkYXRpb25cbiAgICApO1xuICB9XG4gIGlmIChyb3V0ZS5zaG91bGRSZXZhbGlkYXRlKSB7XG4gICAgbGV0IGZuID0gcm91dGUuc2hvdWxkUmV2YWxpZGF0ZTtcbiAgICByZXR1cm4gKG9wdHMpID0+IGZuKHsgLi4ub3B0cywgZGVmYXVsdFNob3VsZFJldmFsaWRhdGU6IHRydWUgfSk7XG4gIH1cbiAgcmV0dXJuIHJvdXRlLnNob3VsZFJldmFsaWRhdGU7XG59XG5mdW5jdGlvbiB3cmFwU2hvdWxkUmV2YWxpZGF0ZUZvckhkcihyb3V0ZUlkLCByb3V0ZVNob3VsZFJldmFsaWRhdGUsIG5lZWRzUmV2YWxpZGF0aW9uKSB7XG4gIGxldCBoYW5kbGVkUmV2YWxpZGF0aW9uID0gZmFsc2U7XG4gIHJldHVybiAoYXJnKSA9PiB7XG4gICAgaWYgKCFoYW5kbGVkUmV2YWxpZGF0aW9uKSB7XG4gICAgICBoYW5kbGVkUmV2YWxpZGF0aW9uID0gdHJ1ZTtcbiAgICAgIHJldHVybiBuZWVkc1JldmFsaWRhdGlvbi5oYXMocm91dGVJZCk7XG4gICAgfVxuICAgIHJldHVybiByb3V0ZVNob3VsZFJldmFsaWRhdGUgPyByb3V0ZVNob3VsZFJldmFsaWRhdGUoYXJnKSA6IGFyZy5kZWZhdWx0U2hvdWxkUmV2YWxpZGF0ZTtcbiAgfTtcbn1cbmFzeW5jIGZ1bmN0aW9uIGxvYWRSb3V0ZU1vZHVsZVdpdGhCbG9ja2luZ0xpbmtzKHJvdXRlLCByb3V0ZU1vZHVsZXMpIHtcbiAgbGV0IHJvdXRlTW9kdWxlID0gYXdhaXQgbG9hZFJvdXRlTW9kdWxlKHJvdXRlLCByb3V0ZU1vZHVsZXMpO1xuICBhd2FpdCBwcmVmZXRjaFN0eWxlTGlua3Mocm91dGUsIHJvdXRlTW9kdWxlKTtcbiAgcmV0dXJuIHtcbiAgICBDb21wb25lbnQ6IGdldFJvdXRlTW9kdWxlQ29tcG9uZW50KHJvdXRlTW9kdWxlKSxcbiAgICBFcnJvckJvdW5kYXJ5OiByb3V0ZU1vZHVsZS5FcnJvckJvdW5kYXJ5LFxuICAgIGNsaWVudEFjdGlvbjogcm91dGVNb2R1bGUuY2xpZW50QWN0aW9uLFxuICAgIGNsaWVudExvYWRlcjogcm91dGVNb2R1bGUuY2xpZW50TG9hZGVyLFxuICAgIGhhbmRsZTogcm91dGVNb2R1bGUuaGFuZGxlLFxuICAgIGxpbmtzOiByb3V0ZU1vZHVsZS5saW5rcyxcbiAgICBtZXRhOiByb3V0ZU1vZHVsZS5tZXRhLFxuICAgIHNob3VsZFJldmFsaWRhdGU6IHJvdXRlTW9kdWxlLnNob3VsZFJldmFsaWRhdGVcbiAgfTtcbn1cbmZ1bmN0aW9uIGdldFJvdXRlTW9kdWxlQ29tcG9uZW50KHJvdXRlTW9kdWxlKSB7XG4gIGlmIChyb3V0ZU1vZHVsZS5kZWZhdWx0ID09IG51bGwpIHJldHVybiB2b2lkIDA7XG4gIGxldCBpc0VtcHR5T2JqZWN0ID0gdHlwZW9mIHJvdXRlTW9kdWxlLmRlZmF1bHQgPT09IFwib2JqZWN0XCIgJiYgT2JqZWN0LmtleXMocm91dGVNb2R1bGUuZGVmYXVsdCkubGVuZ3RoID09PSAwO1xuICBpZiAoIWlzRW1wdHlPYmplY3QpIHtcbiAgICByZXR1cm4gcm91dGVNb2R1bGUuZGVmYXVsdDtcbiAgfVxufVxuZnVuY3Rpb24gc2hvdWxkSHlkcmF0ZVJvdXRlTG9hZGVyKHJvdXRlLCByb3V0ZU1vZHVsZSwgaXNTcGFNb2RlKSB7XG4gIHJldHVybiBpc1NwYU1vZGUgJiYgcm91dGUuaWQgIT09IFwicm9vdFwiIHx8IHJvdXRlTW9kdWxlLmNsaWVudExvYWRlciAhPSBudWxsICYmIChyb3V0ZU1vZHVsZS5jbGllbnRMb2FkZXIuaHlkcmF0ZSA9PT0gdHJ1ZSB8fCByb3V0ZS5oYXNMb2FkZXIgIT09IHRydWUpO1xufVxuXG4vLyBsaWIvZG9tL3Nzci9mb2ctb2Ytd2FyLnRzXG52YXIgbmV4dFBhdGhzID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbnZhciBkaXNjb3ZlcmVkUGF0aHNNYXhTaXplID0gMWUzO1xudmFyIGRpc2NvdmVyZWRQYXRocyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG52YXIgVVJMX0xJTUlUID0gNzY4MDtcbmZ1bmN0aW9uIGlzRm9nT2ZXYXJFbmFibGVkKGlzU3BhTW9kZSkge1xuICByZXR1cm4gIWlzU3BhTW9kZTtcbn1cbmZ1bmN0aW9uIGdldFBhcnRpYWxNYW5pZmVzdChtYW5pZmVzdCwgcm91dGVyKSB7XG4gIGxldCByb3V0ZUlkcyA9IG5ldyBTZXQocm91dGVyLnN0YXRlLm1hdGNoZXMubWFwKChtKSA9PiBtLnJvdXRlLmlkKSk7XG4gIGxldCBzZWdtZW50cyA9IHJvdXRlci5zdGF0ZS5sb2NhdGlvbi5wYXRobmFtZS5zcGxpdChcIi9cIikuZmlsdGVyKEJvb2xlYW4pO1xuICBsZXQgcGF0aHMgPSBbXCIvXCJdO1xuICBzZWdtZW50cy5wb3AoKTtcbiAgd2hpbGUgKHNlZ21lbnRzLmxlbmd0aCA+IDApIHtcbiAgICBwYXRocy5wdXNoKGAvJHtzZWdtZW50cy5qb2luKFwiL1wiKX1gKTtcbiAgICBzZWdtZW50cy5wb3AoKTtcbiAgfVxuICBwYXRocy5mb3JFYWNoKChwYXRoKSA9PiB7XG4gICAgbGV0IG1hdGNoZXMgPSBtYXRjaFJvdXRlcyhyb3V0ZXIucm91dGVzLCBwYXRoLCByb3V0ZXIuYmFzZW5hbWUpO1xuICAgIGlmIChtYXRjaGVzKSB7XG4gICAgICBtYXRjaGVzLmZvckVhY2goKG0pID0+IHJvdXRlSWRzLmFkZChtLnJvdXRlLmlkKSk7XG4gICAgfVxuICB9KTtcbiAgbGV0IGluaXRpYWxSb3V0ZXMgPSBbLi4ucm91dGVJZHNdLnJlZHVjZShcbiAgICAoYWNjLCBpZCkgPT4gT2JqZWN0LmFzc2lnbihhY2MsIHsgW2lkXTogbWFuaWZlc3Qucm91dGVzW2lkXSB9KSxcbiAgICB7fVxuICApO1xuICByZXR1cm4ge1xuICAgIC4uLm1hbmlmZXN0LFxuICAgIHJvdXRlczogaW5pdGlhbFJvdXRlc1xuICB9O1xufVxuZnVuY3Rpb24gZ2V0UGF0Y2hSb3V0ZXNPbk5hdmlnYXRpb25GdW5jdGlvbihtYW5pZmVzdCwgcm91dGVNb2R1bGVzLCBpc1NwYU1vZGUsIGJhc2VuYW1lKSB7XG4gIGlmICghaXNGb2dPZldhckVuYWJsZWQoaXNTcGFNb2RlKSkge1xuICAgIHJldHVybiB2b2lkIDA7XG4gIH1cbiAgcmV0dXJuIGFzeW5jICh7IHBhdGgsIHBhdGNoIH0pID0+IHtcbiAgICBpZiAoZGlzY292ZXJlZFBhdGhzLmhhcyhwYXRoKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBhd2FpdCBmZXRjaEFuZEFwcGx5TWFuaWZlc3RQYXRjaGVzKFxuICAgICAgW3BhdGhdLFxuICAgICAgbWFuaWZlc3QsXG4gICAgICByb3V0ZU1vZHVsZXMsXG4gICAgICBpc1NwYU1vZGUsXG4gICAgICBiYXNlbmFtZSxcbiAgICAgIHBhdGNoXG4gICAgKTtcbiAgfTtcbn1cbmZ1bmN0aW9uIHVzZUZvZ09GV2FyRGlzY292ZXJ5KHJvdXRlciwgbWFuaWZlc3QsIHJvdXRlTW9kdWxlcywgaXNTcGFNb2RlKSB7XG4gIFJlYWN0OC51c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmICghaXNGb2dPZldhckVuYWJsZWQoaXNTcGFNb2RlKSB8fCBuYXZpZ2F0b3IuY29ubmVjdGlvbj8uc2F2ZURhdGEgPT09IHRydWUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZnVuY3Rpb24gcmVnaXN0ZXJFbGVtZW50KGVsKSB7XG4gICAgICBsZXQgcGF0aCA9IGVsLnRhZ05hbWUgPT09IFwiRk9STVwiID8gZWwuZ2V0QXR0cmlidXRlKFwiYWN0aW9uXCIpIDogZWwuZ2V0QXR0cmlidXRlKFwiaHJlZlwiKTtcbiAgICAgIGlmICghcGF0aCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBsZXQgdXJsID0gbmV3IFVSTChwYXRoLCB3aW5kb3cubG9jYXRpb24ub3JpZ2luKTtcbiAgICAgIGlmICghZGlzY292ZXJlZFBhdGhzLmhhcyh1cmwucGF0aG5hbWUpKSB7XG4gICAgICAgIG5leHRQYXRocy5hZGQodXJsLnBhdGhuYW1lKTtcbiAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgZnVuY3Rpb24gZmV0Y2hQYXRjaGVzKCkge1xuICAgICAgbGV0IGxhenlQYXRocyA9IEFycmF5LmZyb20obmV4dFBhdGhzLmtleXMoKSkuZmlsdGVyKChwYXRoKSA9PiB7XG4gICAgICAgIGlmIChkaXNjb3ZlcmVkUGF0aHMuaGFzKHBhdGgpKSB7XG4gICAgICAgICAgbmV4dFBhdGhzLmRlbGV0ZShwYXRoKTtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9KTtcbiAgICAgIGlmIChsYXp5UGF0aHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRyeSB7XG4gICAgICAgIGF3YWl0IGZldGNoQW5kQXBwbHlNYW5pZmVzdFBhdGNoZXMoXG4gICAgICAgICAgbGF6eVBhdGhzLFxuICAgICAgICAgIG1hbmlmZXN0LFxuICAgICAgICAgIHJvdXRlTW9kdWxlcyxcbiAgICAgICAgICBpc1NwYU1vZGUsXG4gICAgICAgICAgcm91dGVyLmJhc2VuYW1lLFxuICAgICAgICAgIHJvdXRlci5wYXRjaFJvdXRlc1xuICAgICAgICApO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjb25zb2xlLmVycm9yKFwiRmFpbGVkIHRvIGZldGNoIG1hbmlmZXN0IHBhdGNoZXNcIiwgZSk7XG4gICAgICB9XG4gICAgfVxuICAgIGRvY3VtZW50LmJvZHkucXVlcnlTZWxlY3RvckFsbChcImFbZGF0YS1kaXNjb3Zlcl0sIGZvcm1bZGF0YS1kaXNjb3Zlcl1cIikuZm9yRWFjaCgoZWwpID0+IHJlZ2lzdGVyRWxlbWVudChlbCkpO1xuICAgIGZldGNoUGF0Y2hlcygpO1xuICAgIGxldCBkZWJvdW5jZWRGZXRjaFBhdGNoZXMgPSBkZWJvdW5jZShmZXRjaFBhdGNoZXMsIDEwMCk7XG4gICAgZnVuY3Rpb24gaXNFbGVtZW50KG5vZGUpIHtcbiAgICAgIHJldHVybiBub2RlLm5vZGVUeXBlID09PSBOb2RlLkVMRU1FTlRfTk9ERTtcbiAgICB9XG4gICAgbGV0IG9ic2VydmVyID0gbmV3IE11dGF0aW9uT2JzZXJ2ZXIoKHJlY29yZHMpID0+IHtcbiAgICAgIGxldCBlbGVtZW50cyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gICAgICByZWNvcmRzLmZvckVhY2goKHIpID0+IHtcbiAgICAgICAgW3IudGFyZ2V0LCAuLi5yLmFkZGVkTm9kZXNdLmZvckVhY2goKG5vZGUpID0+IHtcbiAgICAgICAgICBpZiAoIWlzRWxlbWVudChub2RlKSkgcmV0dXJuO1xuICAgICAgICAgIGlmIChub2RlLnRhZ05hbWUgPT09IFwiQVwiICYmIG5vZGUuZ2V0QXR0cmlidXRlKFwiZGF0YS1kaXNjb3ZlclwiKSkge1xuICAgICAgICAgICAgZWxlbWVudHMuYWRkKG5vZGUpO1xuICAgICAgICAgIH0gZWxzZSBpZiAobm9kZS50YWdOYW1lID09PSBcIkZPUk1cIiAmJiBub2RlLmdldEF0dHJpYnV0ZShcImRhdGEtZGlzY292ZXJcIikpIHtcbiAgICAgICAgICAgIGVsZW1lbnRzLmFkZChub2RlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG5vZGUudGFnTmFtZSAhPT0gXCJBXCIpIHtcbiAgICAgICAgICAgIG5vZGUucXVlcnlTZWxlY3RvckFsbChcImFbZGF0YS1kaXNjb3Zlcl0sIGZvcm1bZGF0YS1kaXNjb3Zlcl1cIikuZm9yRWFjaCgoZWwpID0+IGVsZW1lbnRzLmFkZChlbCkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICAgIGVsZW1lbnRzLmZvckVhY2goKGVsKSA9PiByZWdpc3RlckVsZW1lbnQoZWwpKTtcbiAgICAgIGRlYm91bmNlZEZldGNoUGF0Y2hlcygpO1xuICAgIH0pO1xuICAgIG9ic2VydmVyLm9ic2VydmUoZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LCB7XG4gICAgICBzdWJ0cmVlOiB0cnVlLFxuICAgICAgY2hpbGRMaXN0OiB0cnVlLFxuICAgICAgYXR0cmlidXRlczogdHJ1ZSxcbiAgICAgIGF0dHJpYnV0ZUZpbHRlcjogW1wiZGF0YS1kaXNjb3ZlclwiLCBcImhyZWZcIiwgXCJhY3Rpb25cIl1cbiAgICB9KTtcbiAgICByZXR1cm4gKCkgPT4gb2JzZXJ2ZXIuZGlzY29ubmVjdCgpO1xuICB9LCBbaXNTcGFNb2RlLCBtYW5pZmVzdCwgcm91dGVNb2R1bGVzLCByb3V0ZXJdKTtcbn1cbmFzeW5jIGZ1bmN0aW9uIGZldGNoQW5kQXBwbHlNYW5pZmVzdFBhdGNoZXMocGF0aHMsIG1hbmlmZXN0LCByb3V0ZU1vZHVsZXMsIGlzU3BhTW9kZSwgYmFzZW5hbWUsIHBhdGNoUm91dGVzKSB7XG4gIGxldCBtYW5pZmVzdFBhdGggPSBgJHtiYXNlbmFtZSAhPSBudWxsID8gYmFzZW5hbWUgOiBcIi9cIn0vX19tYW5pZmVzdGAucmVwbGFjZShcbiAgICAvXFwvKy9nLFxuICAgIFwiL1wiXG4gICk7XG4gIGxldCB1cmwgPSBuZXcgVVJMKG1hbmlmZXN0UGF0aCwgd2luZG93LmxvY2F0aW9uLm9yaWdpbik7XG4gIHBhdGhzLnNvcnQoKS5mb3JFYWNoKChwYXRoKSA9PiB1cmwuc2VhcmNoUGFyYW1zLmFwcGVuZChcInBcIiwgcGF0aCkpO1xuICB1cmwuc2VhcmNoUGFyYW1zLnNldChcInZlcnNpb25cIiwgbWFuaWZlc3QudmVyc2lvbik7XG4gIGlmICh1cmwudG9TdHJpbmcoKS5sZW5ndGggPiBVUkxfTElNSVQpIHtcbiAgICBuZXh0UGF0aHMuY2xlYXIoKTtcbiAgICByZXR1cm47XG4gIH1cbiAgbGV0IHJlcyA9IGF3YWl0IGZldGNoKHVybCk7XG4gIGlmICghcmVzLm9rKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGAke3Jlcy5zdGF0dXN9ICR7cmVzLnN0YXR1c1RleHR9YCk7XG4gIH0gZWxzZSBpZiAocmVzLnN0YXR1cyA+PSA0MDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYXdhaXQgcmVzLnRleHQoKSk7XG4gIH1cbiAgbGV0IHNlcnZlclBhdGNoZXMgPSBhd2FpdCByZXMuanNvbigpO1xuICBsZXQga25vd25Sb3V0ZXMgPSBuZXcgU2V0KE9iamVjdC5rZXlzKG1hbmlmZXN0LnJvdXRlcykpO1xuICBsZXQgcGF0Y2hlcyA9IE9iamVjdC52YWx1ZXMoc2VydmVyUGF0Y2hlcykucmVkdWNlKChhY2MsIHJvdXRlKSA9PiB7XG4gICAgaWYgKHJvdXRlICYmICFrbm93blJvdXRlcy5oYXMocm91dGUuaWQpKSB7XG4gICAgICBhY2Nbcm91dGUuaWRdID0gcm91dGU7XG4gICAgfVxuICAgIHJldHVybiBhY2M7XG4gIH0sIHt9KTtcbiAgT2JqZWN0LmFzc2lnbihtYW5pZmVzdC5yb3V0ZXMsIHBhdGNoZXMpO1xuICBwYXRocy5mb3JFYWNoKChwKSA9PiBhZGRUb0ZpZm9RdWV1ZShwLCBkaXNjb3ZlcmVkUGF0aHMpKTtcbiAgbGV0IHBhcmVudElkcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gIE9iamVjdC52YWx1ZXMocGF0Y2hlcykuZm9yRWFjaCgocGF0Y2gpID0+IHtcbiAgICBpZiAocGF0Y2ggJiYgKCFwYXRjaC5wYXJlbnRJZCB8fCAhcGF0Y2hlc1twYXRjaC5wYXJlbnRJZF0pKSB7XG4gICAgICBwYXJlbnRJZHMuYWRkKHBhdGNoLnBhcmVudElkKTtcbiAgICB9XG4gIH0pO1xuICBwYXJlbnRJZHMuZm9yRWFjaChcbiAgICAocGFyZW50SWQpID0+IHBhdGNoUm91dGVzKFxuICAgICAgcGFyZW50SWQgfHwgbnVsbCxcbiAgICAgIGNyZWF0ZUNsaWVudFJvdXRlcyhwYXRjaGVzLCByb3V0ZU1vZHVsZXMsIG51bGwsIGlzU3BhTW9kZSwgcGFyZW50SWQpXG4gICAgKVxuICApO1xufVxuZnVuY3Rpb24gYWRkVG9GaWZvUXVldWUocGF0aCwgcXVldWUpIHtcbiAgaWYgKHF1ZXVlLnNpemUgPj0gZGlzY292ZXJlZFBhdGhzTWF4U2l6ZSkge1xuICAgIGxldCBmaXJzdCA9IHF1ZXVlLnZhbHVlcygpLm5leHQoKS52YWx1ZTtcbiAgICBxdWV1ZS5kZWxldGUoZmlyc3QpO1xuICB9XG4gIHF1ZXVlLmFkZChwYXRoKTtcbn1cbmZ1bmN0aW9uIGRlYm91bmNlKGNhbGxiYWNrLCB3YWl0KSB7XG4gIGxldCB0aW1lb3V0SWQ7XG4gIHJldHVybiAoLi4uYXJncykgPT4ge1xuICAgIHdpbmRvdy5jbGVhclRpbWVvdXQodGltZW91dElkKTtcbiAgICB0aW1lb3V0SWQgPSB3aW5kb3cuc2V0VGltZW91dCgoKSA9PiBjYWxsYmFjayguLi5hcmdzKSwgd2FpdCk7XG4gIH07XG59XG5cbi8vIGxpYi9kb20vc3NyL2NvbXBvbmVudHMudHN4XG5mdW5jdGlvbiB1c2VEYXRhUm91dGVyQ29udGV4dDIoKSB7XG4gIGxldCBjb250ZXh0ID0gUmVhY3Q5LnVzZUNvbnRleHQoRGF0YVJvdXRlckNvbnRleHQpO1xuICBpbnZhcmlhbnQyKFxuICAgIGNvbnRleHQsXG4gICAgXCJZb3UgbXVzdCByZW5kZXIgdGhpcyBlbGVtZW50IGluc2lkZSBhIDxEYXRhUm91dGVyQ29udGV4dC5Qcm92aWRlcj4gZWxlbWVudFwiXG4gICk7XG4gIHJldHVybiBjb250ZXh0O1xufVxuZnVuY3Rpb24gdXNlRGF0YVJvdXRlclN0YXRlQ29udGV4dCgpIHtcbiAgbGV0IGNvbnRleHQgPSBSZWFjdDkudXNlQ29udGV4dChEYXRhUm91dGVyU3RhdGVDb250ZXh0KTtcbiAgaW52YXJpYW50MihcbiAgICBjb250ZXh0LFxuICAgIFwiWW91IG11c3QgcmVuZGVyIHRoaXMgZWxlbWVudCBpbnNpZGUgYSA8RGF0YVJvdXRlclN0YXRlQ29udGV4dC5Qcm92aWRlcj4gZWxlbWVudFwiXG4gICk7XG4gIHJldHVybiBjb250ZXh0O1xufVxudmFyIEZyYW1ld29ya0NvbnRleHQgPSBSZWFjdDkuY3JlYXRlQ29udGV4dCh2b2lkIDApO1xuRnJhbWV3b3JrQ29udGV4dC5kaXNwbGF5TmFtZSA9IFwiRnJhbWV3b3JrQ29udGV4dFwiO1xuZnVuY3Rpb24gdXNlRnJhbWV3b3JrQ29udGV4dCgpIHtcbiAgbGV0IGNvbnRleHQgPSBSZWFjdDkudXNlQ29udGV4dChGcmFtZXdvcmtDb250ZXh0KTtcbiAgaW52YXJpYW50MihcbiAgICBjb250ZXh0LFxuICAgIFwiWW91IG11c3QgcmVuZGVyIHRoaXMgZWxlbWVudCBpbnNpZGUgYSA8SHlkcmF0ZWRSb3V0ZXI+IGVsZW1lbnRcIlxuICApO1xuICByZXR1cm4gY29udGV4dDtcbn1cbmZ1bmN0aW9uIHVzZVByZWZldGNoQmVoYXZpb3IocHJlZmV0Y2gsIHRoZWlyRWxlbWVudFByb3BzKSB7XG4gIGxldCBmcmFtZXdvcmtDb250ZXh0ID0gUmVhY3Q5LnVzZUNvbnRleHQoRnJhbWV3b3JrQ29udGV4dCk7XG4gIGxldCBbbWF5YmVQcmVmZXRjaCwgc2V0TWF5YmVQcmVmZXRjaF0gPSBSZWFjdDkudXNlU3RhdGUoZmFsc2UpO1xuICBsZXQgW3Nob3VsZFByZWZldGNoLCBzZXRTaG91bGRQcmVmZXRjaF0gPSBSZWFjdDkudXNlU3RhdGUoZmFsc2UpO1xuICBsZXQgeyBvbkZvY3VzLCBvbkJsdXIsIG9uTW91c2VFbnRlciwgb25Nb3VzZUxlYXZlLCBvblRvdWNoU3RhcnQgfSA9IHRoZWlyRWxlbWVudFByb3BzO1xuICBsZXQgcmVmID0gUmVhY3Q5LnVzZVJlZihudWxsKTtcbiAgUmVhY3Q5LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKHByZWZldGNoID09PSBcInJlbmRlclwiKSB7XG4gICAgICBzZXRTaG91bGRQcmVmZXRjaCh0cnVlKTtcbiAgICB9XG4gICAgaWYgKHByZWZldGNoID09PSBcInZpZXdwb3J0XCIpIHtcbiAgICAgIGxldCBjYWxsYmFjayA9IChlbnRyaWVzKSA9PiB7XG4gICAgICAgIGVudHJpZXMuZm9yRWFjaCgoZW50cnkpID0+IHtcbiAgICAgICAgICBzZXRTaG91bGRQcmVmZXRjaChlbnRyeS5pc0ludGVyc2VjdGluZyk7XG4gICAgICAgIH0pO1xuICAgICAgfTtcbiAgICAgIGxldCBvYnNlcnZlciA9IG5ldyBJbnRlcnNlY3Rpb25PYnNlcnZlcihjYWxsYmFjaywgeyB0aHJlc2hvbGQ6IDAuNSB9KTtcbiAgICAgIGlmIChyZWYuY3VycmVudCkgb2JzZXJ2ZXIub2JzZXJ2ZShyZWYuY3VycmVudCk7XG4gICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICBvYnNlcnZlci5kaXNjb25uZWN0KCk7XG4gICAgICB9O1xuICAgIH1cbiAgfSwgW3ByZWZldGNoXSk7XG4gIFJlYWN0OS51c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmIChtYXliZVByZWZldGNoKSB7XG4gICAgICBsZXQgaWQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgc2V0U2hvdWxkUHJlZmV0Y2godHJ1ZSk7XG4gICAgICB9LCAxMDApO1xuICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KGlkKTtcbiAgICAgIH07XG4gICAgfVxuICB9LCBbbWF5YmVQcmVmZXRjaF0pO1xuICBsZXQgc2V0SW50ZW50ID0gKCkgPT4ge1xuICAgIHNldE1heWJlUHJlZmV0Y2godHJ1ZSk7XG4gIH07XG4gIGxldCBjYW5jZWxJbnRlbnQgPSAoKSA9PiB7XG4gICAgc2V0TWF5YmVQcmVmZXRjaChmYWxzZSk7XG4gICAgc2V0U2hvdWxkUHJlZmV0Y2goZmFsc2UpO1xuICB9O1xuICBpZiAoIWZyYW1ld29ya0NvbnRleHQpIHtcbiAgICByZXR1cm4gW2ZhbHNlLCByZWYsIHt9XTtcbiAgfVxuICBpZiAocHJlZmV0Y2ggIT09IFwiaW50ZW50XCIpIHtcbiAgICByZXR1cm4gW3Nob3VsZFByZWZldGNoLCByZWYsIHt9XTtcbiAgfVxuICByZXR1cm4gW1xuICAgIHNob3VsZFByZWZldGNoLFxuICAgIHJlZixcbiAgICB7XG4gICAgICBvbkZvY3VzOiBjb21wb3NlRXZlbnRIYW5kbGVycyhvbkZvY3VzLCBzZXRJbnRlbnQpLFxuICAgICAgb25CbHVyOiBjb21wb3NlRXZlbnRIYW5kbGVycyhvbkJsdXIsIGNhbmNlbEludGVudCksXG4gICAgICBvbk1vdXNlRW50ZXI6IGNvbXBvc2VFdmVudEhhbmRsZXJzKG9uTW91c2VFbnRlciwgc2V0SW50ZW50KSxcbiAgICAgIG9uTW91c2VMZWF2ZTogY29tcG9zZUV2ZW50SGFuZGxlcnMob25Nb3VzZUxlYXZlLCBjYW5jZWxJbnRlbnQpLFxuICAgICAgb25Ub3VjaFN0YXJ0OiBjb21wb3NlRXZlbnRIYW5kbGVycyhvblRvdWNoU3RhcnQsIHNldEludGVudClcbiAgICB9XG4gIF07XG59XG5mdW5jdGlvbiBjb21wb3NlRXZlbnRIYW5kbGVycyh0aGVpckhhbmRsZXIsIG91ckhhbmRsZXIpIHtcbiAgcmV0dXJuIChldmVudCkgPT4ge1xuICAgIHRoZWlySGFuZGxlciAmJiB0aGVpckhhbmRsZXIoZXZlbnQpO1xuICAgIGlmICghZXZlbnQuZGVmYXVsdFByZXZlbnRlZCkge1xuICAgICAgb3VySGFuZGxlcihldmVudCk7XG4gICAgfVxuICB9O1xufVxuZnVuY3Rpb24gZ2V0QWN0aXZlTWF0Y2hlcyhtYXRjaGVzLCBlcnJvcnMsIGlzU3BhTW9kZSkge1xuICBpZiAoaXNTcGFNb2RlICYmICFpc0h5ZHJhdGVkKSB7XG4gICAgcmV0dXJuIFttYXRjaGVzWzBdXTtcbiAgfVxuICBpZiAoZXJyb3JzKSB7XG4gICAgbGV0IGVycm9ySWR4ID0gbWF0Y2hlcy5maW5kSW5kZXgoKG0pID0+IGVycm9yc1ttLnJvdXRlLmlkXSAhPT0gdm9pZCAwKTtcbiAgICByZXR1cm4gbWF0Y2hlcy5zbGljZSgwLCBlcnJvcklkeCArIDEpO1xuICB9XG4gIHJldHVybiBtYXRjaGVzO1xufVxuZnVuY3Rpb24gTGlua3MoKSB7XG4gIGxldCB7IGlzU3BhTW9kZSwgbWFuaWZlc3QsIHJvdXRlTW9kdWxlcywgY3JpdGljYWxDc3MgfSA9IHVzZUZyYW1ld29ya0NvbnRleHQoKTtcbiAgbGV0IHsgZXJyb3JzLCBtYXRjaGVzOiByb3V0ZXJNYXRjaGVzIH0gPSB1c2VEYXRhUm91dGVyU3RhdGVDb250ZXh0KCk7XG4gIGxldCBtYXRjaGVzID0gZ2V0QWN0aXZlTWF0Y2hlcyhyb3V0ZXJNYXRjaGVzLCBlcnJvcnMsIGlzU3BhTW9kZSk7XG4gIGxldCBrZXllZExpbmtzID0gUmVhY3Q5LnVzZU1lbW8oXG4gICAgKCkgPT4gZ2V0S2V5ZWRMaW5rc0Zvck1hdGNoZXMobWF0Y2hlcywgcm91dGVNb2R1bGVzLCBtYW5pZmVzdCksXG4gICAgW21hdGNoZXMsIHJvdXRlTW9kdWxlcywgbWFuaWZlc3RdXG4gICk7XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8gUmVhY3Q5LmNyZWF0ZUVsZW1lbnQoUmVhY3Q5LkZyYWdtZW50LCBudWxsLCBjcml0aWNhbENzcyA/IC8qIEBfX1BVUkVfXyAqLyBSZWFjdDkuY3JlYXRlRWxlbWVudChcInN0eWxlXCIsIHsgZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUw6IHsgX19odG1sOiBjcml0aWNhbENzcyB9IH0pIDogbnVsbCwga2V5ZWRMaW5rcy5tYXAoXG4gICAgKHsga2V5LCBsaW5rIH0pID0+IGlzUGFnZUxpbmtEZXNjcmlwdG9yKGxpbmspID8gLyogQF9fUFVSRV9fICovIFJlYWN0OS5jcmVhdGVFbGVtZW50KFByZWZldGNoUGFnZUxpbmtzLCB7IGtleSwgLi4ubGluayB9KSA6IC8qIEBfX1BVUkVfXyAqLyBSZWFjdDkuY3JlYXRlRWxlbWVudChcImxpbmtcIiwgeyBrZXksIC4uLmxpbmsgfSlcbiAgKSk7XG59XG5mdW5jdGlvbiBQcmVmZXRjaFBhZ2VMaW5rcyh7XG4gIHBhZ2UsXG4gIC4uLmRhdGFMaW5rUHJvcHNcbn0pIHtcbiAgbGV0IHsgcm91dGVyIH0gPSB1c2VEYXRhUm91dGVyQ29udGV4dDIoKTtcbiAgbGV0IG1hdGNoZXMgPSBSZWFjdDkudXNlTWVtbyhcbiAgICAoKSA9PiBtYXRjaFJvdXRlcyhyb3V0ZXIucm91dGVzLCBwYWdlLCByb3V0ZXIuYmFzZW5hbWUpLFxuICAgIFtyb3V0ZXIucm91dGVzLCBwYWdlLCByb3V0ZXIuYmFzZW5hbWVdXG4gICk7XG4gIGlmICghbWF0Y2hlcykge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8gUmVhY3Q5LmNyZWF0ZUVsZW1lbnQoUHJlZmV0Y2hQYWdlTGlua3NJbXBsLCB7IHBhZ2UsIG1hdGNoZXMsIC4uLmRhdGFMaW5rUHJvcHMgfSk7XG59XG5mdW5jdGlvbiB1c2VLZXllZFByZWZldGNoTGlua3MobWF0Y2hlcykge1xuICBsZXQgeyBtYW5pZmVzdCwgcm91dGVNb2R1bGVzIH0gPSB1c2VGcmFtZXdvcmtDb250ZXh0KCk7XG4gIGxldCBba2V5ZWRQcmVmZXRjaExpbmtzLCBzZXRLZXllZFByZWZldGNoTGlua3NdID0gUmVhY3Q5LnVzZVN0YXRlKFtdKTtcbiAgUmVhY3Q5LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgbGV0IGludGVycnVwdGVkID0gZmFsc2U7XG4gICAgdm9pZCBnZXRLZXllZFByZWZldGNoTGlua3MobWF0Y2hlcywgbWFuaWZlc3QsIHJvdXRlTW9kdWxlcykudGhlbihcbiAgICAgIChsaW5rcykgPT4ge1xuICAgICAgICBpZiAoIWludGVycnVwdGVkKSB7XG4gICAgICAgICAgc2V0S2V5ZWRQcmVmZXRjaExpbmtzKGxpbmtzKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICk7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIGludGVycnVwdGVkID0gdHJ1ZTtcbiAgICB9O1xuICB9LCBbbWF0Y2hlcywgbWFuaWZlc3QsIHJvdXRlTW9kdWxlc10pO1xuICByZXR1cm4ga2V5ZWRQcmVmZXRjaExpbmtzO1xufVxuZnVuY3Rpb24gUHJlZmV0Y2hQYWdlTGlua3NJbXBsKHtcbiAgcGFnZSxcbiAgbWF0Y2hlczogbmV4dE1hdGNoZXMsXG4gIC4uLmxpbmtQcm9wc1xufSkge1xuICBsZXQgbG9jYXRpb24gPSB1c2VMb2NhdGlvbigpO1xuICBsZXQgeyBtYW5pZmVzdCwgcm91dGVNb2R1bGVzIH0gPSB1c2VGcmFtZXdvcmtDb250ZXh0KCk7XG4gIGxldCB7IGxvYWRlckRhdGEsIG1hdGNoZXMgfSA9IHVzZURhdGFSb3V0ZXJTdGF0ZUNvbnRleHQoKTtcbiAgbGV0IG5ld01hdGNoZXNGb3JEYXRhID0gUmVhY3Q5LnVzZU1lbW8oXG4gICAgKCkgPT4gZ2V0TmV3TWF0Y2hlc0ZvckxpbmtzKFxuICAgICAgcGFnZSxcbiAgICAgIG5leHRNYXRjaGVzLFxuICAgICAgbWF0Y2hlcyxcbiAgICAgIG1hbmlmZXN0LFxuICAgICAgbG9jYXRpb24sXG4gICAgICBcImRhdGFcIlxuICAgICksXG4gICAgW3BhZ2UsIG5leHRNYXRjaGVzLCBtYXRjaGVzLCBtYW5pZmVzdCwgbG9jYXRpb25dXG4gICk7XG4gIGxldCBuZXdNYXRjaGVzRm9yQXNzZXRzID0gUmVhY3Q5LnVzZU1lbW8oXG4gICAgKCkgPT4gZ2V0TmV3TWF0Y2hlc0ZvckxpbmtzKFxuICAgICAgcGFnZSxcbiAgICAgIG5leHRNYXRjaGVzLFxuICAgICAgbWF0Y2hlcyxcbiAgICAgIG1hbmlmZXN0LFxuICAgICAgbG9jYXRpb24sXG4gICAgICBcImFzc2V0c1wiXG4gICAgKSxcbiAgICBbcGFnZSwgbmV4dE1hdGNoZXMsIG1hdGNoZXMsIG1hbmlmZXN0LCBsb2NhdGlvbl1cbiAgKTtcbiAgbGV0IGRhdGFIcmVmcyA9IFJlYWN0OS51c2VNZW1vKCgpID0+IHtcbiAgICBpZiAocGFnZSA9PT0gbG9jYXRpb24ucGF0aG5hbWUgKyBsb2NhdGlvbi5zZWFyY2ggKyBsb2NhdGlvbi5oYXNoKSB7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuICAgIGxldCByb3V0ZXNQYXJhbXMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICAgIGxldCBmb3VuZE9wdE91dFJvdXRlID0gZmFsc2U7XG4gICAgbmV4dE1hdGNoZXMuZm9yRWFjaCgobSkgPT4ge1xuICAgICAgbGV0IG1hbmlmZXN0Um91dGUgPSBtYW5pZmVzdC5yb3V0ZXNbbS5yb3V0ZS5pZF07XG4gICAgICBpZiAoIW1hbmlmZXN0Um91dGUgfHwgIW1hbmlmZXN0Um91dGUuaGFzTG9hZGVyKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmICghbmV3TWF0Y2hlc0ZvckRhdGEuc29tZSgobTIpID0+IG0yLnJvdXRlLmlkID09PSBtLnJvdXRlLmlkKSAmJiBtLnJvdXRlLmlkIGluIGxvYWRlckRhdGEgJiYgcm91dGVNb2R1bGVzW20ucm91dGUuaWRdPy5zaG91bGRSZXZhbGlkYXRlKSB7XG4gICAgICAgIGZvdW5kT3B0T3V0Um91dGUgPSB0cnVlO1xuICAgICAgfSBlbHNlIGlmIChtYW5pZmVzdFJvdXRlLmhhc0NsaWVudExvYWRlcikge1xuICAgICAgICBmb3VuZE9wdE91dFJvdXRlID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJvdXRlc1BhcmFtcy5hZGQobS5yb3V0ZS5pZCk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgaWYgKHJvdXRlc1BhcmFtcy5zaXplID09PSAwKSB7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuICAgIGxldCB1cmwgPSBzaW5nbGVGZXRjaFVybChwYWdlKTtcbiAgICBpZiAoZm91bmRPcHRPdXRSb3V0ZSAmJiByb3V0ZXNQYXJhbXMuc2l6ZSA+IDApIHtcbiAgICAgIHVybC5zZWFyY2hQYXJhbXMuc2V0KFxuICAgICAgICBcIl9yb3V0ZXNcIixcbiAgICAgICAgbmV4dE1hdGNoZXMuZmlsdGVyKChtKSA9PiByb3V0ZXNQYXJhbXMuaGFzKG0ucm91dGUuaWQpKS5tYXAoKG0pID0+IG0ucm91dGUuaWQpLmpvaW4oXCIsXCIpXG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4gW3VybC5wYXRobmFtZSArIHVybC5zZWFyY2hdO1xuICB9LCBbXG4gICAgbG9hZGVyRGF0YSxcbiAgICBsb2NhdGlvbixcbiAgICBtYW5pZmVzdCxcbiAgICBuZXdNYXRjaGVzRm9yRGF0YSxcbiAgICBuZXh0TWF0Y2hlcyxcbiAgICBwYWdlLFxuICAgIHJvdXRlTW9kdWxlc1xuICBdKTtcbiAgbGV0IG1vZHVsZUhyZWZzID0gUmVhY3Q5LnVzZU1lbW8oXG4gICAgKCkgPT4gZ2V0TW9kdWxlTGlua0hyZWZzKG5ld01hdGNoZXNGb3JBc3NldHMsIG1hbmlmZXN0KSxcbiAgICBbbmV3TWF0Y2hlc0ZvckFzc2V0cywgbWFuaWZlc3RdXG4gICk7XG4gIGxldCBrZXllZFByZWZldGNoTGlua3MgPSB1c2VLZXllZFByZWZldGNoTGlua3MobmV3TWF0Y2hlc0ZvckFzc2V0cyk7XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8gUmVhY3Q5LmNyZWF0ZUVsZW1lbnQoUmVhY3Q5LkZyYWdtZW50LCBudWxsLCBkYXRhSHJlZnMubWFwKChocmVmKSA9PiAvKiBAX19QVVJFX18gKi8gUmVhY3Q5LmNyZWF0ZUVsZW1lbnQoXCJsaW5rXCIsIHsga2V5OiBocmVmLCByZWw6IFwicHJlZmV0Y2hcIiwgYXM6IFwiZmV0Y2hcIiwgaHJlZiwgLi4ubGlua1Byb3BzIH0pKSwgbW9kdWxlSHJlZnMubWFwKChocmVmKSA9PiAvKiBAX19QVVJFX18gKi8gUmVhY3Q5LmNyZWF0ZUVsZW1lbnQoXCJsaW5rXCIsIHsga2V5OiBocmVmLCByZWw6IFwibW9kdWxlcHJlbG9hZFwiLCBocmVmLCAuLi5saW5rUHJvcHMgfSkpLCBrZXllZFByZWZldGNoTGlua3MubWFwKCh7IGtleSwgbGluayB9KSA9PiAoXG4gICAgLy8gdGhlc2UgZG9uJ3Qgc3ByZWFkIGBsaW5rUHJvcHNgIGJlY2F1c2UgdGhleSBhcmUgZnVsbCBsaW5rIGRlc2NyaXB0b3JzXG4gICAgLy8gYWxyZWFkeSB3aXRoIHRoZWlyIG93biBwcm9wc1xuICAgIC8qIEBfX1BVUkVfXyAqLyBSZWFjdDkuY3JlYXRlRWxlbWVudChcImxpbmtcIiwgeyBrZXksIC4uLmxpbmsgfSlcbiAgKSkpO1xufVxuZnVuY3Rpb24gTWV0YSgpIHtcbiAgbGV0IHsgaXNTcGFNb2RlLCByb3V0ZU1vZHVsZXMgfSA9IHVzZUZyYW1ld29ya0NvbnRleHQoKTtcbiAgbGV0IHtcbiAgICBlcnJvcnMsXG4gICAgbWF0Y2hlczogcm91dGVyTWF0Y2hlcyxcbiAgICBsb2FkZXJEYXRhXG4gIH0gPSB1c2VEYXRhUm91dGVyU3RhdGVDb250ZXh0KCk7XG4gIGxldCBsb2NhdGlvbiA9IHVzZUxvY2F0aW9uKCk7XG4gIGxldCBfbWF0Y2hlcyA9IGdldEFjdGl2ZU1hdGNoZXMocm91dGVyTWF0Y2hlcywgZXJyb3JzLCBpc1NwYU1vZGUpO1xuICBsZXQgZXJyb3IgPSBudWxsO1xuICBpZiAoZXJyb3JzKSB7XG4gICAgZXJyb3IgPSBlcnJvcnNbX21hdGNoZXNbX21hdGNoZXMubGVuZ3RoIC0gMV0ucm91dGUuaWRdO1xuICB9XG4gIGxldCBtZXRhID0gW107XG4gIGxldCBsZWFmTWV0YSA9IG51bGw7XG4gIGxldCBtYXRjaGVzID0gW107XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgX21hdGNoZXMubGVuZ3RoOyBpKyspIHtcbiAgICBsZXQgX21hdGNoID0gX21hdGNoZXNbaV07XG4gICAgbGV0IHJvdXRlSWQgPSBfbWF0Y2gucm91dGUuaWQ7XG4gICAgbGV0IGRhdGEyID0gbG9hZGVyRGF0YVtyb3V0ZUlkXTtcbiAgICBsZXQgcGFyYW1zID0gX21hdGNoLnBhcmFtcztcbiAgICBsZXQgcm91dGVNb2R1bGUgPSByb3V0ZU1vZHVsZXNbcm91dGVJZF07XG4gICAgbGV0IHJvdXRlTWV0YSA9IFtdO1xuICAgIGxldCBtYXRjaCA9IHtcbiAgICAgIGlkOiByb3V0ZUlkLFxuICAgICAgZGF0YTogZGF0YTIsXG4gICAgICBtZXRhOiBbXSxcbiAgICAgIHBhcmFtczogX21hdGNoLnBhcmFtcyxcbiAgICAgIHBhdGhuYW1lOiBfbWF0Y2gucGF0aG5hbWUsXG4gICAgICBoYW5kbGU6IF9tYXRjaC5yb3V0ZS5oYW5kbGUsXG4gICAgICBlcnJvclxuICAgIH07XG4gICAgbWF0Y2hlc1tpXSA9IG1hdGNoO1xuICAgIGlmIChyb3V0ZU1vZHVsZT8ubWV0YSkge1xuICAgICAgcm91dGVNZXRhID0gdHlwZW9mIHJvdXRlTW9kdWxlLm1ldGEgPT09IFwiZnVuY3Rpb25cIiA/IHJvdXRlTW9kdWxlLm1ldGEoe1xuICAgICAgICBkYXRhOiBkYXRhMixcbiAgICAgICAgcGFyYW1zLFxuICAgICAgICBsb2NhdGlvbixcbiAgICAgICAgbWF0Y2hlcyxcbiAgICAgICAgZXJyb3JcbiAgICAgIH0pIDogQXJyYXkuaXNBcnJheShyb3V0ZU1vZHVsZS5tZXRhKSA/IFsuLi5yb3V0ZU1vZHVsZS5tZXRhXSA6IHJvdXRlTW9kdWxlLm1ldGE7XG4gICAgfSBlbHNlIGlmIChsZWFmTWV0YSkge1xuICAgICAgcm91dGVNZXRhID0gWy4uLmxlYWZNZXRhXTtcbiAgICB9XG4gICAgcm91dGVNZXRhID0gcm91dGVNZXRhIHx8IFtdO1xuICAgIGlmICghQXJyYXkuaXNBcnJheShyb3V0ZU1ldGEpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIFwiVGhlIHJvdXRlIGF0IFwiICsgX21hdGNoLnJvdXRlLnBhdGggKyBcIiByZXR1cm5zIGFuIGludmFsaWQgdmFsdWUuIEFsbCByb3V0ZSBtZXRhIGZ1bmN0aW9ucyBtdXN0IHJldHVybiBhbiBhcnJheSBvZiBtZXRhIG9iamVjdHMuXFxuXFxuVG8gcmVmZXJlbmNlIHRoZSBtZXRhIGZ1bmN0aW9uIEFQSSwgc2VlIGh0dHBzOi8vcmVtaXgucnVuL3JvdXRlL21ldGFcIlxuICAgICAgKTtcbiAgICB9XG4gICAgbWF0Y2gubWV0YSA9IHJvdXRlTWV0YTtcbiAgICBtYXRjaGVzW2ldID0gbWF0Y2g7XG4gICAgbWV0YSA9IFsuLi5yb3V0ZU1ldGFdO1xuICAgIGxlYWZNZXRhID0gbWV0YTtcbiAgfVxuICByZXR1cm4gLyogQF9fUFVSRV9fICovIFJlYWN0OS5jcmVhdGVFbGVtZW50KFJlYWN0OS5GcmFnbWVudCwgbnVsbCwgbWV0YS5mbGF0KCkubWFwKChtZXRhUHJvcHMpID0+IHtcbiAgICBpZiAoIW1ldGFQcm9wcykge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGlmIChcInRhZ05hbWVcIiBpbiBtZXRhUHJvcHMpIHtcbiAgICAgIGxldCB7IHRhZ05hbWUsIC4uLnJlc3QgfSA9IG1ldGFQcm9wcztcbiAgICAgIGlmICghaXNWYWxpZE1ldGFUYWcodGFnTmFtZSkpIHtcbiAgICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICAgIGBBIG1ldGEgb2JqZWN0IHVzZXMgYW4gaW52YWxpZCB0YWdOYW1lOiAke3RhZ05hbWV9LiBFeHBlY3RlZCBlaXRoZXIgJ2xpbmsnIG9yICdtZXRhJ2BcbiAgICAgICAgKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICBsZXQgQ29tcCA9IHRhZ05hbWU7XG4gICAgICByZXR1cm4gLyogQF9fUFVSRV9fICovIFJlYWN0OS5jcmVhdGVFbGVtZW50KENvbXAsIHsga2V5OiBKU09OLnN0cmluZ2lmeShyZXN0KSwgLi4ucmVzdCB9KTtcbiAgICB9XG4gICAgaWYgKFwidGl0bGVcIiBpbiBtZXRhUHJvcHMpIHtcbiAgICAgIHJldHVybiAvKiBAX19QVVJFX18gKi8gUmVhY3Q5LmNyZWF0ZUVsZW1lbnQoXCJ0aXRsZVwiLCB7IGtleTogXCJ0aXRsZVwiIH0sIFN0cmluZyhtZXRhUHJvcHMudGl0bGUpKTtcbiAgICB9XG4gICAgaWYgKFwiY2hhcnNldFwiIGluIG1ldGFQcm9wcykge1xuICAgICAgbWV0YVByb3BzLmNoYXJTZXQgPz8gKG1ldGFQcm9wcy5jaGFyU2V0ID0gbWV0YVByb3BzLmNoYXJzZXQpO1xuICAgICAgZGVsZXRlIG1ldGFQcm9wcy5jaGFyc2V0O1xuICAgIH1cbiAgICBpZiAoXCJjaGFyU2V0XCIgaW4gbWV0YVByb3BzICYmIG1ldGFQcm9wcy5jaGFyU2V0ICE9IG51bGwpIHtcbiAgICAgIHJldHVybiB0eXBlb2YgbWV0YVByb3BzLmNoYXJTZXQgPT09IFwic3RyaW5nXCIgPyAvKiBAX19QVVJFX18gKi8gUmVhY3Q5LmNyZWF0ZUVsZW1lbnQoXCJtZXRhXCIsIHsga2V5OiBcImNoYXJTZXRcIiwgY2hhclNldDogbWV0YVByb3BzLmNoYXJTZXQgfSkgOiBudWxsO1xuICAgIH1cbiAgICBpZiAoXCJzY3JpcHQ6bGQranNvblwiIGluIG1ldGFQcm9wcykge1xuICAgICAgdHJ5IHtcbiAgICAgICAgbGV0IGpzb24gPSBKU09OLnN0cmluZ2lmeShtZXRhUHJvcHNbXCJzY3JpcHQ6bGQranNvblwiXSk7XG4gICAgICAgIHJldHVybiAvKiBAX19QVVJFX18gKi8gUmVhY3Q5LmNyZWF0ZUVsZW1lbnQoXG4gICAgICAgICAgXCJzY3JpcHRcIixcbiAgICAgICAgICB7XG4gICAgICAgICAgICBrZXk6IGBzY3JpcHQ6bGQranNvbjoke2pzb259YCxcbiAgICAgICAgICAgIHR5cGU6IFwiYXBwbGljYXRpb24vbGQranNvblwiLFxuICAgICAgICAgICAgZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUw6IHsgX19odG1sOiBqc29uIH1cbiAgICAgICAgICB9XG4gICAgICAgICk7XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiAvKiBAX19QVVJFX18gKi8gUmVhY3Q5LmNyZWF0ZUVsZW1lbnQoXCJtZXRhXCIsIHsga2V5OiBKU09OLnN0cmluZ2lmeShtZXRhUHJvcHMpLCAuLi5tZXRhUHJvcHMgfSk7XG4gIH0pKTtcbn1cbmZ1bmN0aW9uIGlzVmFsaWRNZXRhVGFnKHRhZ05hbWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB0YWdOYW1lID09PSBcInN0cmluZ1wiICYmIC9eKG1ldGF8bGluaykkLy50ZXN0KHRhZ05hbWUpO1xufVxudmFyIGlzSHlkcmF0ZWQgPSBmYWxzZTtcbmZ1bmN0aW9uIFNjcmlwdHMocHJvcHMpIHtcbiAgbGV0IHsgbWFuaWZlc3QsIHNlcnZlckhhbmRvZmZTdHJpbmcsIGlzU3BhTW9kZSwgcmVuZGVyTWV0YSB9ID0gdXNlRnJhbWV3b3JrQ29udGV4dCgpO1xuICBsZXQgeyByb3V0ZXIsIHN0YXRpYzogaXNTdGF0aWMsIHN0YXRpY0NvbnRleHQgfSA9IHVzZURhdGFSb3V0ZXJDb250ZXh0MigpO1xuICBsZXQgeyBtYXRjaGVzOiByb3V0ZXJNYXRjaGVzIH0gPSB1c2VEYXRhUm91dGVyU3RhdGVDb250ZXh0KCk7XG4gIGxldCBlbmFibGVGb2dPZldhciA9IGlzRm9nT2ZXYXJFbmFibGVkKGlzU3BhTW9kZSk7XG4gIGlmIChyZW5kZXJNZXRhKSB7XG4gICAgcmVuZGVyTWV0YS5kaWRSZW5kZXJTY3JpcHRzID0gdHJ1ZTtcbiAgfVxuICBsZXQgbWF0Y2hlcyA9IGdldEFjdGl2ZU1hdGNoZXMocm91dGVyTWF0Y2hlcywgbnVsbCwgaXNTcGFNb2RlKTtcbiAgUmVhY3Q5LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaXNIeWRyYXRlZCA9IHRydWU7XG4gIH0sIFtdKTtcbiAgbGV0IGluaXRpYWxTY3JpcHRzID0gUmVhY3Q5LnVzZU1lbW8oKCkgPT4ge1xuICAgIGxldCBzdHJlYW1TY3JpcHQgPSBcIndpbmRvdy5fX3JlYWN0Um91dGVyQ29udGV4dC5zdHJlYW0gPSBuZXcgUmVhZGFibGVTdHJlYW0oe3N0YXJ0KGNvbnRyb2xsZXIpe3dpbmRvdy5fX3JlYWN0Um91dGVyQ29udGV4dC5zdHJlYW1Db250cm9sbGVyID0gY29udHJvbGxlcjt9fSkucGlwZVRocm91Z2gobmV3IFRleHRFbmNvZGVyU3RyZWFtKCkpO1wiO1xuICAgIGxldCBjb250ZXh0U2NyaXB0ID0gc3RhdGljQ29udGV4dCA/IGB3aW5kb3cuX19yZWFjdFJvdXRlckNvbnRleHQgPSAke3NlcnZlckhhbmRvZmZTdHJpbmd9OyR7c3RyZWFtU2NyaXB0fWAgOiBcIiBcIjtcbiAgICBsZXQgcm91dGVNb2R1bGVzU2NyaXB0ID0gIWlzU3RhdGljID8gXCIgXCIgOiBgJHttYW5pZmVzdC5obXI/LnJ1bnRpbWUgPyBgaW1wb3J0ICR7SlNPTi5zdHJpbmdpZnkobWFuaWZlc3QuaG1yLnJ1bnRpbWUpfTtgIDogXCJcIn0keyFlbmFibGVGb2dPZldhciA/IGBpbXBvcnQgJHtKU09OLnN0cmluZ2lmeShtYW5pZmVzdC51cmwpfWAgOiBcIlwifTtcbiR7bWF0Y2hlcy5tYXAoXG4gICAgICAobWF0Y2gsIGluZGV4KSA9PiBgaW1wb3J0ICogYXMgcm91dGUke2luZGV4fSBmcm9tICR7SlNPTi5zdHJpbmdpZnkoXG4gICAgICAgIG1hbmlmZXN0LnJvdXRlc1ttYXRjaC5yb3V0ZS5pZF0ubW9kdWxlXG4gICAgICApfTtgXG4gICAgKS5qb2luKFwiXFxuXCIpfVxuICAke2VuYWJsZUZvZ09mV2FyID8gKFxuICAgICAgLy8gSW5saW5lIGEgbWluaW1hbCBtYW5pZmVzdCB3aXRoIHRoZSBTU1IgbWF0Y2hlc1xuICAgICAgYHdpbmRvdy5fX3JlYWN0Um91dGVyTWFuaWZlc3QgPSAke0pTT04uc3RyaW5naWZ5KFxuICAgICAgICBnZXRQYXJ0aWFsTWFuaWZlc3QobWFuaWZlc3QsIHJvdXRlciksXG4gICAgICAgIG51bGwsXG4gICAgICAgIDJcbiAgICAgICl9O2BcbiAgICApIDogXCJcIn1cbiAgd2luZG93Ll9fcmVhY3RSb3V0ZXJSb3V0ZU1vZHVsZXMgPSB7JHttYXRjaGVzLm1hcCgobWF0Y2gsIGluZGV4KSA9PiBgJHtKU09OLnN0cmluZ2lmeShtYXRjaC5yb3V0ZS5pZCl9OnJvdXRlJHtpbmRleH1gKS5qb2luKFwiLFwiKX19O1xuXG5pbXBvcnQoJHtKU09OLnN0cmluZ2lmeShtYW5pZmVzdC5lbnRyeS5tb2R1bGUpfSk7YDtcbiAgICByZXR1cm4gLyogQF9fUFVSRV9fICovIFJlYWN0OS5jcmVhdGVFbGVtZW50KFJlYWN0OS5GcmFnbWVudCwgbnVsbCwgLyogQF9fUFVSRV9fICovIFJlYWN0OS5jcmVhdGVFbGVtZW50KFxuICAgICAgXCJzY3JpcHRcIixcbiAgICAgIHtcbiAgICAgICAgLi4ucHJvcHMsXG4gICAgICAgIHN1cHByZXNzSHlkcmF0aW9uV2FybmluZzogdHJ1ZSxcbiAgICAgICAgZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUw6IGNyZWF0ZUh0bWwoY29udGV4dFNjcmlwdCksXG4gICAgICAgIHR5cGU6IHZvaWQgMFxuICAgICAgfVxuICAgICksIC8qIEBfX1BVUkVfXyAqLyBSZWFjdDkuY3JlYXRlRWxlbWVudChcbiAgICAgIFwic2NyaXB0XCIsXG4gICAgICB7XG4gICAgICAgIC4uLnByb3BzLFxuICAgICAgICBzdXBwcmVzc0h5ZHJhdGlvbldhcm5pbmc6IHRydWUsXG4gICAgICAgIGRhbmdlcm91c2x5U2V0SW5uZXJIVE1MOiBjcmVhdGVIdG1sKHJvdXRlTW9kdWxlc1NjcmlwdCksXG4gICAgICAgIHR5cGU6IFwibW9kdWxlXCIsXG4gICAgICAgIGFzeW5jOiB0cnVlXG4gICAgICB9XG4gICAgKSk7XG4gIH0sIFtdKTtcbiAgbGV0IHJvdXRlUHJlbG9hZHMgPSBtYXRjaGVzLm1hcCgobWF0Y2gpID0+IHtcbiAgICBsZXQgcm91dGUgPSBtYW5pZmVzdC5yb3V0ZXNbbWF0Y2gucm91dGUuaWRdO1xuICAgIHJldHVybiByb3V0ZSA/IChyb3V0ZS5pbXBvcnRzIHx8IFtdKS5jb25jYXQoW3JvdXRlLm1vZHVsZV0pIDogW107XG4gIH0pLmZsYXQoMSk7XG4gIGxldCBwcmVsb2FkcyA9IGlzSHlkcmF0ZWQgPyBbXSA6IG1hbmlmZXN0LmVudHJ5LmltcG9ydHMuY29uY2F0KHJvdXRlUHJlbG9hZHMpO1xuICByZXR1cm4gaXNIeWRyYXRlZCA/IG51bGwgOiAvKiBAX19QVVJFX18gKi8gUmVhY3Q5LmNyZWF0ZUVsZW1lbnQoUmVhY3Q5LkZyYWdtZW50LCBudWxsLCAhZW5hYmxlRm9nT2ZXYXIgPyAvKiBAX19QVVJFX18gKi8gUmVhY3Q5LmNyZWF0ZUVsZW1lbnQoXG4gICAgXCJsaW5rXCIsXG4gICAge1xuICAgICAgcmVsOiBcIm1vZHVsZXByZWxvYWRcIixcbiAgICAgIGhyZWY6IG1hbmlmZXN0LnVybCxcbiAgICAgIGNyb3NzT3JpZ2luOiBwcm9wcy5jcm9zc09yaWdpblxuICAgIH1cbiAgKSA6IG51bGwsIC8qIEBfX1BVUkVfXyAqLyBSZWFjdDkuY3JlYXRlRWxlbWVudChcbiAgICBcImxpbmtcIixcbiAgICB7XG4gICAgICByZWw6IFwibW9kdWxlcHJlbG9hZFwiLFxuICAgICAgaHJlZjogbWFuaWZlc3QuZW50cnkubW9kdWxlLFxuICAgICAgY3Jvc3NPcmlnaW46IHByb3BzLmNyb3NzT3JpZ2luXG4gICAgfVxuICApLCBkZWR1cGUocHJlbG9hZHMpLm1hcCgocGF0aCkgPT4gLyogQF9fUFVSRV9fICovIFJlYWN0OS5jcmVhdGVFbGVtZW50KFxuICAgIFwibGlua1wiLFxuICAgIHtcbiAgICAgIGtleTogcGF0aCxcbiAgICAgIHJlbDogXCJtb2R1bGVwcmVsb2FkXCIsXG4gICAgICBocmVmOiBwYXRoLFxuICAgICAgY3Jvc3NPcmlnaW46IHByb3BzLmNyb3NzT3JpZ2luXG4gICAgfVxuICApKSwgaW5pdGlhbFNjcmlwdHMpO1xufVxuZnVuY3Rpb24gZGVkdXBlKGFycmF5KSB7XG4gIHJldHVybiBbLi4ubmV3IFNldChhcnJheSldO1xufVxuZnVuY3Rpb24gbWVyZ2VSZWZzKC4uLnJlZnMpIHtcbiAgcmV0dXJuICh2YWx1ZSkgPT4ge1xuICAgIHJlZnMuZm9yRWFjaCgocmVmKSA9PiB7XG4gICAgICBpZiAodHlwZW9mIHJlZiA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIHJlZih2YWx1ZSk7XG4gICAgICB9IGVsc2UgaWYgKHJlZiAhPSBudWxsKSB7XG4gICAgICAgIHJlZi5jdXJyZW50ID0gdmFsdWU7XG4gICAgICB9XG4gICAgfSk7XG4gIH07XG59XG5cbi8vIGxpYi9kb20vbGliLnRzeFxudmFyIGlzQnJvd3NlciA9IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgJiYgdHlwZW9mIHdpbmRvdy5kb2N1bWVudCAhPT0gXCJ1bmRlZmluZWRcIiAmJiB0eXBlb2Ygd2luZG93LmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQgIT09IFwidW5kZWZpbmVkXCI7XG50cnkge1xuICBpZiAoaXNCcm93c2VyKSB7XG4gICAgd2luZG93Ll9fcmVhY3RSb3V0ZXJWZXJzaW9uID0gXCI3LjEuMFwiO1xuICB9XG59IGNhdGNoIChlKSB7XG59XG5mdW5jdGlvbiBjcmVhdGVCcm93c2VyUm91dGVyKHJvdXRlcywgb3B0cykge1xuICByZXR1cm4gY3JlYXRlUm91dGVyKHtcbiAgICBiYXNlbmFtZTogb3B0cz8uYmFzZW5hbWUsXG4gICAgZnV0dXJlOiBvcHRzPy5mdXR1cmUsXG4gICAgaGlzdG9yeTogY3JlYXRlQnJvd3Nlckhpc3RvcnkoeyB3aW5kb3c6IG9wdHM/LndpbmRvdyB9KSxcbiAgICBoeWRyYXRpb25EYXRhOiBvcHRzPy5oeWRyYXRpb25EYXRhIHx8IHBhcnNlSHlkcmF0aW9uRGF0YSgpLFxuICAgIHJvdXRlcyxcbiAgICBtYXBSb3V0ZVByb3BlcnRpZXMsXG4gICAgZGF0YVN0cmF0ZWd5OiBvcHRzPy5kYXRhU3RyYXRlZ3ksXG4gICAgcGF0Y2hSb3V0ZXNPbk5hdmlnYXRpb246IG9wdHM/LnBhdGNoUm91dGVzT25OYXZpZ2F0aW9uLFxuICAgIHdpbmRvdzogb3B0cz8ud2luZG93XG4gIH0pLmluaXRpYWxpemUoKTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUhhc2hSb3V0ZXIocm91dGVzLCBvcHRzKSB7XG4gIHJldHVybiBjcmVhdGVSb3V0ZXIoe1xuICAgIGJhc2VuYW1lOiBvcHRzPy5iYXNlbmFtZSxcbiAgICBmdXR1cmU6IG9wdHM/LmZ1dHVyZSxcbiAgICBoaXN0b3J5OiBjcmVhdGVIYXNoSGlzdG9yeSh7IHdpbmRvdzogb3B0cz8ud2luZG93IH0pLFxuICAgIGh5ZHJhdGlvbkRhdGE6IG9wdHM/Lmh5ZHJhdGlvbkRhdGEgfHwgcGFyc2VIeWRyYXRpb25EYXRhKCksXG4gICAgcm91dGVzLFxuICAgIG1hcFJvdXRlUHJvcGVydGllcyxcbiAgICBkYXRhU3RyYXRlZ3k6IG9wdHM/LmRhdGFTdHJhdGVneSxcbiAgICBwYXRjaFJvdXRlc09uTmF2aWdhdGlvbjogb3B0cz8ucGF0Y2hSb3V0ZXNPbk5hdmlnYXRpb24sXG4gICAgd2luZG93OiBvcHRzPy53aW5kb3dcbiAgfSkuaW5pdGlhbGl6ZSgpO1xufVxuZnVuY3Rpb24gcGFyc2VIeWRyYXRpb25EYXRhKCkge1xuICBsZXQgc3RhdGUgPSB3aW5kb3c/Ll9fc3RhdGljUm91dGVySHlkcmF0aW9uRGF0YTtcbiAgaWYgKHN0YXRlICYmIHN0YXRlLmVycm9ycykge1xuICAgIHN0YXRlID0ge1xuICAgICAgLi4uc3RhdGUsXG4gICAgICBlcnJvcnM6IGRlc2VyaWFsaXplRXJyb3JzKHN0YXRlLmVycm9ycylcbiAgICB9O1xuICB9XG4gIHJldHVybiBzdGF0ZTtcbn1cbmZ1bmN0aW9uIGRlc2VyaWFsaXplRXJyb3JzKGVycm9ycykge1xuICBpZiAoIWVycm9ycykgcmV0dXJuIG51bGw7XG4gIGxldCBlbnRyaWVzID0gT2JqZWN0LmVudHJpZXMoZXJyb3JzKTtcbiAgbGV0IHNlcmlhbGl6ZWQgPSB7fTtcbiAgZm9yIChsZXQgW2tleSwgdmFsXSBvZiBlbnRyaWVzKSB7XG4gICAgaWYgKHZhbCAmJiB2YWwuX190eXBlID09PSBcIlJvdXRlRXJyb3JSZXNwb25zZVwiKSB7XG4gICAgICBzZXJpYWxpemVkW2tleV0gPSBuZXcgRXJyb3JSZXNwb25zZUltcGwoXG4gICAgICAgIHZhbC5zdGF0dXMsXG4gICAgICAgIHZhbC5zdGF0dXNUZXh0LFxuICAgICAgICB2YWwuZGF0YSxcbiAgICAgICAgdmFsLmludGVybmFsID09PSB0cnVlXG4gICAgICApO1xuICAgIH0gZWxzZSBpZiAodmFsICYmIHZhbC5fX3R5cGUgPT09IFwiRXJyb3JcIikge1xuICAgICAgaWYgKHZhbC5fX3N1YlR5cGUpIHtcbiAgICAgICAgbGV0IEVycm9yQ29uc3RydWN0b3IgPSB3aW5kb3dbdmFsLl9fc3ViVHlwZV07XG4gICAgICAgIGlmICh0eXBlb2YgRXJyb3JDb25zdHJ1Y3RvciA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGxldCBlcnJvciA9IG5ldyBFcnJvckNvbnN0cnVjdG9yKHZhbC5tZXNzYWdlKTtcbiAgICAgICAgICAgIGVycm9yLnN0YWNrID0gXCJcIjtcbiAgICAgICAgICAgIHNlcmlhbGl6ZWRba2V5XSA9IGVycm9yO1xuICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChzZXJpYWxpemVkW2tleV0gPT0gbnVsbCkge1xuICAgICAgICBsZXQgZXJyb3IgPSBuZXcgRXJyb3IodmFsLm1lc3NhZ2UpO1xuICAgICAgICBlcnJvci5zdGFjayA9IFwiXCI7XG4gICAgICAgIHNlcmlhbGl6ZWRba2V5XSA9IGVycm9yO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBzZXJpYWxpemVkW2tleV0gPSB2YWw7XG4gICAgfVxuICB9XG4gIHJldHVybiBzZXJpYWxpemVkO1xufVxuZnVuY3Rpb24gQnJvd3NlclJvdXRlcih7XG4gIGJhc2VuYW1lLFxuICBjaGlsZHJlbixcbiAgd2luZG93OiB3aW5kb3cyXG59KSB7XG4gIGxldCBoaXN0b3J5UmVmID0gUmVhY3QxMC51c2VSZWYoKTtcbiAgaWYgKGhpc3RvcnlSZWYuY3VycmVudCA9PSBudWxsKSB7XG4gICAgaGlzdG9yeVJlZi5jdXJyZW50ID0gY3JlYXRlQnJvd3Nlckhpc3RvcnkoeyB3aW5kb3c6IHdpbmRvdzIsIHY1Q29tcGF0OiB0cnVlIH0pO1xuICB9XG4gIGxldCBoaXN0b3J5ID0gaGlzdG9yeVJlZi5jdXJyZW50O1xuICBsZXQgW3N0YXRlLCBzZXRTdGF0ZUltcGxdID0gUmVhY3QxMC51c2VTdGF0ZSh7XG4gICAgYWN0aW9uOiBoaXN0b3J5LmFjdGlvbixcbiAgICBsb2NhdGlvbjogaGlzdG9yeS5sb2NhdGlvblxuICB9KTtcbiAgbGV0IHNldFN0YXRlID0gUmVhY3QxMC51c2VDYWxsYmFjayhcbiAgICAobmV3U3RhdGUpID0+IHtcbiAgICAgIFJlYWN0MTAuc3RhcnRUcmFuc2l0aW9uKCgpID0+IHNldFN0YXRlSW1wbChuZXdTdGF0ZSkpO1xuICAgIH0sXG4gICAgW3NldFN0YXRlSW1wbF1cbiAgKTtcbiAgUmVhY3QxMC51c2VMYXlvdXRFZmZlY3QoKCkgPT4gaGlzdG9yeS5saXN0ZW4oc2V0U3RhdGUpLCBbaGlzdG9yeSwgc2V0U3RhdGVdKTtcbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBSZWFjdDEwLmNyZWF0ZUVsZW1lbnQoXG4gICAgUm91dGVyLFxuICAgIHtcbiAgICAgIGJhc2VuYW1lLFxuICAgICAgY2hpbGRyZW4sXG4gICAgICBsb2NhdGlvbjogc3RhdGUubG9jYXRpb24sXG4gICAgICBuYXZpZ2F0aW9uVHlwZTogc3RhdGUuYWN0aW9uLFxuICAgICAgbmF2aWdhdG9yOiBoaXN0b3J5XG4gICAgfVxuICApO1xufVxuZnVuY3Rpb24gSGFzaFJvdXRlcih7IGJhc2VuYW1lLCBjaGlsZHJlbiwgd2luZG93OiB3aW5kb3cyIH0pIHtcbiAgbGV0IGhpc3RvcnlSZWYgPSBSZWFjdDEwLnVzZVJlZigpO1xuICBpZiAoaGlzdG9yeVJlZi5jdXJyZW50ID09IG51bGwpIHtcbiAgICBoaXN0b3J5UmVmLmN1cnJlbnQgPSBjcmVhdGVIYXNoSGlzdG9yeSh7IHdpbmRvdzogd2luZG93MiwgdjVDb21wYXQ6IHRydWUgfSk7XG4gIH1cbiAgbGV0IGhpc3RvcnkgPSBoaXN0b3J5UmVmLmN1cnJlbnQ7XG4gIGxldCBbc3RhdGUsIHNldFN0YXRlSW1wbF0gPSBSZWFjdDEwLnVzZVN0YXRlKHtcbiAgICBhY3Rpb246IGhpc3RvcnkuYWN0aW9uLFxuICAgIGxvY2F0aW9uOiBoaXN0b3J5LmxvY2F0aW9uXG4gIH0pO1xuICBsZXQgc2V0U3RhdGUgPSBSZWFjdDEwLnVzZUNhbGxiYWNrKFxuICAgIChuZXdTdGF0ZSkgPT4ge1xuICAgICAgUmVhY3QxMC5zdGFydFRyYW5zaXRpb24oKCkgPT4gc2V0U3RhdGVJbXBsKG5ld1N0YXRlKSk7XG4gICAgfSxcbiAgICBbc2V0U3RhdGVJbXBsXVxuICApO1xuICBSZWFjdDEwLnVzZUxheW91dEVmZmVjdCgoKSA9PiBoaXN0b3J5Lmxpc3RlbihzZXRTdGF0ZSksIFtoaXN0b3J5LCBzZXRTdGF0ZV0pO1xuICByZXR1cm4gLyogQF9fUFVSRV9fICovIFJlYWN0MTAuY3JlYXRlRWxlbWVudChcbiAgICBSb3V0ZXIsXG4gICAge1xuICAgICAgYmFzZW5hbWUsXG4gICAgICBjaGlsZHJlbixcbiAgICAgIGxvY2F0aW9uOiBzdGF0ZS5sb2NhdGlvbixcbiAgICAgIG5hdmlnYXRpb25UeXBlOiBzdGF0ZS5hY3Rpb24sXG4gICAgICBuYXZpZ2F0b3I6IGhpc3RvcnlcbiAgICB9XG4gICk7XG59XG5mdW5jdGlvbiBIaXN0b3J5Um91dGVyKHtcbiAgYmFzZW5hbWUsXG4gIGNoaWxkcmVuLFxuICBoaXN0b3J5XG59KSB7XG4gIGxldCBbc3RhdGUsIHNldFN0YXRlSW1wbF0gPSBSZWFjdDEwLnVzZVN0YXRlKHtcbiAgICBhY3Rpb246IGhpc3RvcnkuYWN0aW9uLFxuICAgIGxvY2F0aW9uOiBoaXN0b3J5LmxvY2F0aW9uXG4gIH0pO1xuICBsZXQgc2V0U3RhdGUgPSBSZWFjdDEwLnVzZUNhbGxiYWNrKFxuICAgIChuZXdTdGF0ZSkgPT4ge1xuICAgICAgUmVhY3QxMC5zdGFydFRyYW5zaXRpb24oKCkgPT4gc2V0U3RhdGVJbXBsKG5ld1N0YXRlKSk7XG4gICAgfSxcbiAgICBbc2V0U3RhdGVJbXBsXVxuICApO1xuICBSZWFjdDEwLnVzZUxheW91dEVmZmVjdCgoKSA9PiBoaXN0b3J5Lmxpc3RlbihzZXRTdGF0ZSksIFtoaXN0b3J5LCBzZXRTdGF0ZV0pO1xuICByZXR1cm4gLyogQF9fUFVSRV9fICovIFJlYWN0MTAuY3JlYXRlRWxlbWVudChcbiAgICBSb3V0ZXIsXG4gICAge1xuICAgICAgYmFzZW5hbWUsXG4gICAgICBjaGlsZHJlbixcbiAgICAgIGxvY2F0aW9uOiBzdGF0ZS5sb2NhdGlvbixcbiAgICAgIG5hdmlnYXRpb25UeXBlOiBzdGF0ZS5hY3Rpb24sXG4gICAgICBuYXZpZ2F0b3I6IGhpc3RvcnlcbiAgICB9XG4gICk7XG59XG5IaXN0b3J5Um91dGVyLmRpc3BsYXlOYW1lID0gXCJ1bnN0YWJsZV9IaXN0b3J5Um91dGVyXCI7XG52YXIgQUJTT0xVVEVfVVJMX1JFR0VYMiA9IC9eKD86W2Etel1bYS16MC05Ky4tXSo6fFxcL1xcLykvaTtcbnZhciBMaW5rID0gUmVhY3QxMC5mb3J3YXJkUmVmKFxuICBmdW5jdGlvbiBMaW5rV2l0aFJlZih7XG4gICAgb25DbGljayxcbiAgICBkaXNjb3ZlciA9IFwicmVuZGVyXCIsXG4gICAgcHJlZmV0Y2ggPSBcIm5vbmVcIixcbiAgICByZWxhdGl2ZSxcbiAgICByZWxvYWREb2N1bWVudCxcbiAgICByZXBsYWNlOiByZXBsYWNlMixcbiAgICBzdGF0ZSxcbiAgICB0YXJnZXQsXG4gICAgdG8sXG4gICAgcHJldmVudFNjcm9sbFJlc2V0LFxuICAgIHZpZXdUcmFuc2l0aW9uLFxuICAgIC4uLnJlc3RcbiAgfSwgZm9yd2FyZGVkUmVmKSB7XG4gICAgbGV0IHsgYmFzZW5hbWUgfSA9IFJlYWN0MTAudXNlQ29udGV4dChOYXZpZ2F0aW9uQ29udGV4dCk7XG4gICAgbGV0IGlzQWJzb2x1dGUgPSB0eXBlb2YgdG8gPT09IFwic3RyaW5nXCIgJiYgQUJTT0xVVEVfVVJMX1JFR0VYMi50ZXN0KHRvKTtcbiAgICBsZXQgYWJzb2x1dGVIcmVmO1xuICAgIGxldCBpc0V4dGVybmFsID0gZmFsc2U7XG4gICAgaWYgKHR5cGVvZiB0byA9PT0gXCJzdHJpbmdcIiAmJiBpc0Fic29sdXRlKSB7XG4gICAgICBhYnNvbHV0ZUhyZWYgPSB0bztcbiAgICAgIGlmIChpc0Jyb3dzZXIpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBsZXQgY3VycmVudFVybCA9IG5ldyBVUkwod2luZG93LmxvY2F0aW9uLmhyZWYpO1xuICAgICAgICAgIGxldCB0YXJnZXRVcmwgPSB0by5zdGFydHNXaXRoKFwiLy9cIikgPyBuZXcgVVJMKGN1cnJlbnRVcmwucHJvdG9jb2wgKyB0bykgOiBuZXcgVVJMKHRvKTtcbiAgICAgICAgICBsZXQgcGF0aCA9IHN0cmlwQmFzZW5hbWUodGFyZ2V0VXJsLnBhdGhuYW1lLCBiYXNlbmFtZSk7XG4gICAgICAgICAgaWYgKHRhcmdldFVybC5vcmlnaW4gPT09IGN1cnJlbnRVcmwub3JpZ2luICYmIHBhdGggIT0gbnVsbCkge1xuICAgICAgICAgICAgdG8gPSBwYXRoICsgdGFyZ2V0VXJsLnNlYXJjaCArIHRhcmdldFVybC5oYXNoO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpc0V4dGVybmFsID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICB3YXJuaW5nKFxuICAgICAgICAgICAgZmFsc2UsXG4gICAgICAgICAgICBgPExpbmsgdG89XCIke3RvfVwiPiBjb250YWlucyBhbiBpbnZhbGlkIFVSTCB3aGljaCB3aWxsIHByb2JhYmx5IGJyZWFrIHdoZW4gY2xpY2tlZCAtIHBsZWFzZSB1cGRhdGUgdG8gYSB2YWxpZCBVUkwgcGF0aC5gXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBsZXQgaHJlZiA9IHVzZUhyZWYodG8sIHsgcmVsYXRpdmUgfSk7XG4gICAgbGV0IFtzaG91bGRQcmVmZXRjaCwgcHJlZmV0Y2hSZWYsIHByZWZldGNoSGFuZGxlcnNdID0gdXNlUHJlZmV0Y2hCZWhhdmlvcihcbiAgICAgIHByZWZldGNoLFxuICAgICAgcmVzdFxuICAgICk7XG4gICAgbGV0IGludGVybmFsT25DbGljayA9IHVzZUxpbmtDbGlja0hhbmRsZXIodG8sIHtcbiAgICAgIHJlcGxhY2U6IHJlcGxhY2UyLFxuICAgICAgc3RhdGUsXG4gICAgICB0YXJnZXQsXG4gICAgICBwcmV2ZW50U2Nyb2xsUmVzZXQsXG4gICAgICByZWxhdGl2ZSxcbiAgICAgIHZpZXdUcmFuc2l0aW9uXG4gICAgfSk7XG4gICAgZnVuY3Rpb24gaGFuZGxlQ2xpY2soZXZlbnQpIHtcbiAgICAgIGlmIChvbkNsaWNrKSBvbkNsaWNrKGV2ZW50KTtcbiAgICAgIGlmICghZXZlbnQuZGVmYXVsdFByZXZlbnRlZCkge1xuICAgICAgICBpbnRlcm5hbE9uQ2xpY2soZXZlbnQpO1xuICAgICAgfVxuICAgIH1cbiAgICBsZXQgbGluayA9IChcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBqc3gtYTExeS9hbmNob3ItaGFzLWNvbnRlbnRcbiAgICAgIC8qIEBfX1BVUkVfXyAqLyBSZWFjdDEwLmNyZWF0ZUVsZW1lbnQoXG4gICAgICAgIFwiYVwiLFxuICAgICAgICB7XG4gICAgICAgICAgLi4ucmVzdCxcbiAgICAgICAgICAuLi5wcmVmZXRjaEhhbmRsZXJzLFxuICAgICAgICAgIGhyZWY6IGFic29sdXRlSHJlZiB8fCBocmVmLFxuICAgICAgICAgIG9uQ2xpY2s6IGlzRXh0ZXJuYWwgfHwgcmVsb2FkRG9jdW1lbnQgPyBvbkNsaWNrIDogaGFuZGxlQ2xpY2ssXG4gICAgICAgICAgcmVmOiBtZXJnZVJlZnMoZm9yd2FyZGVkUmVmLCBwcmVmZXRjaFJlZiksXG4gICAgICAgICAgdGFyZ2V0LFxuICAgICAgICAgIFwiZGF0YS1kaXNjb3ZlclwiOiAhaXNBYnNvbHV0ZSAmJiBkaXNjb3ZlciA9PT0gXCJyZW5kZXJcIiA/IFwidHJ1ZVwiIDogdm9pZCAwXG4gICAgICAgIH1cbiAgICAgIClcbiAgICApO1xuICAgIHJldHVybiBzaG91bGRQcmVmZXRjaCAmJiAhaXNBYnNvbHV0ZSA/IC8qIEBfX1BVUkVfXyAqLyBSZWFjdDEwLmNyZWF0ZUVsZW1lbnQoUmVhY3QxMC5GcmFnbWVudCwgbnVsbCwgbGluaywgLyogQF9fUFVSRV9fICovIFJlYWN0MTAuY3JlYXRlRWxlbWVudChQcmVmZXRjaFBhZ2VMaW5rcywgeyBwYWdlOiBocmVmIH0pKSA6IGxpbms7XG4gIH1cbik7XG5MaW5rLmRpc3BsYXlOYW1lID0gXCJMaW5rXCI7XG52YXIgTmF2TGluayA9IFJlYWN0MTAuZm9yd2FyZFJlZihcbiAgZnVuY3Rpb24gTmF2TGlua1dpdGhSZWYoe1xuICAgIFwiYXJpYS1jdXJyZW50XCI6IGFyaWFDdXJyZW50UHJvcCA9IFwicGFnZVwiLFxuICAgIGNhc2VTZW5zaXRpdmUgPSBmYWxzZSxcbiAgICBjbGFzc05hbWU6IGNsYXNzTmFtZVByb3AgPSBcIlwiLFxuICAgIGVuZCA9IGZhbHNlLFxuICAgIHN0eWxlOiBzdHlsZVByb3AsXG4gICAgdG8sXG4gICAgdmlld1RyYW5zaXRpb24sXG4gICAgY2hpbGRyZW4sXG4gICAgLi4ucmVzdFxuICB9LCByZWYpIHtcbiAgICBsZXQgcGF0aCA9IHVzZVJlc29sdmVkUGF0aCh0bywgeyByZWxhdGl2ZTogcmVzdC5yZWxhdGl2ZSB9KTtcbiAgICBsZXQgbG9jYXRpb24gPSB1c2VMb2NhdGlvbigpO1xuICAgIGxldCByb3V0ZXJTdGF0ZSA9IFJlYWN0MTAudXNlQ29udGV4dChEYXRhUm91dGVyU3RhdGVDb250ZXh0KTtcbiAgICBsZXQgeyBuYXZpZ2F0b3I6IG5hdmlnYXRvcjIsIGJhc2VuYW1lIH0gPSBSZWFjdDEwLnVzZUNvbnRleHQoTmF2aWdhdGlvbkNvbnRleHQpO1xuICAgIGxldCBpc1RyYW5zaXRpb25pbmcgPSByb3V0ZXJTdGF0ZSAhPSBudWxsICYmIC8vIENvbmRpdGlvbmFsIHVzYWdlIGlzIE9LIGhlcmUgYmVjYXVzZSB0aGUgdXNhZ2Ugb2YgYSBkYXRhIHJvdXRlciBpcyBzdGF0aWNcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaG9va3MvcnVsZXMtb2YtaG9va3NcbiAgICB1c2VWaWV3VHJhbnNpdGlvblN0YXRlKHBhdGgpICYmIHZpZXdUcmFuc2l0aW9uID09PSB0cnVlO1xuICAgIGxldCB0b1BhdGhuYW1lID0gbmF2aWdhdG9yMi5lbmNvZGVMb2NhdGlvbiA/IG5hdmlnYXRvcjIuZW5jb2RlTG9jYXRpb24ocGF0aCkucGF0aG5hbWUgOiBwYXRoLnBhdGhuYW1lO1xuICAgIGxldCBsb2NhdGlvblBhdGhuYW1lID0gbG9jYXRpb24ucGF0aG5hbWU7XG4gICAgbGV0IG5leHRMb2NhdGlvblBhdGhuYW1lID0gcm91dGVyU3RhdGUgJiYgcm91dGVyU3RhdGUubmF2aWdhdGlvbiAmJiByb3V0ZXJTdGF0ZS5uYXZpZ2F0aW9uLmxvY2F0aW9uID8gcm91dGVyU3RhdGUubmF2aWdhdGlvbi5sb2NhdGlvbi5wYXRobmFtZSA6IG51bGw7XG4gICAgaWYgKCFjYXNlU2Vuc2l0aXZlKSB7XG4gICAgICBsb2NhdGlvblBhdGhuYW1lID0gbG9jYXRpb25QYXRobmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgbmV4dExvY2F0aW9uUGF0aG5hbWUgPSBuZXh0TG9jYXRpb25QYXRobmFtZSA/IG5leHRMb2NhdGlvblBhdGhuYW1lLnRvTG93ZXJDYXNlKCkgOiBudWxsO1xuICAgICAgdG9QYXRobmFtZSA9IHRvUGF0aG5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICB9XG4gICAgaWYgKG5leHRMb2NhdGlvblBhdGhuYW1lICYmIGJhc2VuYW1lKSB7XG4gICAgICBuZXh0TG9jYXRpb25QYXRobmFtZSA9IHN0cmlwQmFzZW5hbWUobmV4dExvY2F0aW9uUGF0aG5hbWUsIGJhc2VuYW1lKSB8fCBuZXh0TG9jYXRpb25QYXRobmFtZTtcbiAgICB9XG4gICAgY29uc3QgZW5kU2xhc2hQb3NpdGlvbiA9IHRvUGF0aG5hbWUgIT09IFwiL1wiICYmIHRvUGF0aG5hbWUuZW5kc1dpdGgoXCIvXCIpID8gdG9QYXRobmFtZS5sZW5ndGggLSAxIDogdG9QYXRobmFtZS5sZW5ndGg7XG4gICAgbGV0IGlzQWN0aXZlID0gbG9jYXRpb25QYXRobmFtZSA9PT0gdG9QYXRobmFtZSB8fCAhZW5kICYmIGxvY2F0aW9uUGF0aG5hbWUuc3RhcnRzV2l0aCh0b1BhdGhuYW1lKSAmJiBsb2NhdGlvblBhdGhuYW1lLmNoYXJBdChlbmRTbGFzaFBvc2l0aW9uKSA9PT0gXCIvXCI7XG4gICAgbGV0IGlzUGVuZGluZyA9IG5leHRMb2NhdGlvblBhdGhuYW1lICE9IG51bGwgJiYgKG5leHRMb2NhdGlvblBhdGhuYW1lID09PSB0b1BhdGhuYW1lIHx8ICFlbmQgJiYgbmV4dExvY2F0aW9uUGF0aG5hbWUuc3RhcnRzV2l0aCh0b1BhdGhuYW1lKSAmJiBuZXh0TG9jYXRpb25QYXRobmFtZS5jaGFyQXQodG9QYXRobmFtZS5sZW5ndGgpID09PSBcIi9cIik7XG4gICAgbGV0IHJlbmRlclByb3BzID0ge1xuICAgICAgaXNBY3RpdmUsXG4gICAgICBpc1BlbmRpbmcsXG4gICAgICBpc1RyYW5zaXRpb25pbmdcbiAgICB9O1xuICAgIGxldCBhcmlhQ3VycmVudCA9IGlzQWN0aXZlID8gYXJpYUN1cnJlbnRQcm9wIDogdm9pZCAwO1xuICAgIGxldCBjbGFzc05hbWU7XG4gICAgaWYgKHR5cGVvZiBjbGFzc05hbWVQcm9wID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgIGNsYXNzTmFtZSA9IGNsYXNzTmFtZVByb3AocmVuZGVyUHJvcHMpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjbGFzc05hbWUgPSBbXG4gICAgICAgIGNsYXNzTmFtZVByb3AsXG4gICAgICAgIGlzQWN0aXZlID8gXCJhY3RpdmVcIiA6IG51bGwsXG4gICAgICAgIGlzUGVuZGluZyA/IFwicGVuZGluZ1wiIDogbnVsbCxcbiAgICAgICAgaXNUcmFuc2l0aW9uaW5nID8gXCJ0cmFuc2l0aW9uaW5nXCIgOiBudWxsXG4gICAgICBdLmZpbHRlcihCb29sZWFuKS5qb2luKFwiIFwiKTtcbiAgICB9XG4gICAgbGV0IHN0eWxlID0gdHlwZW9mIHN0eWxlUHJvcCA9PT0gXCJmdW5jdGlvblwiID8gc3R5bGVQcm9wKHJlbmRlclByb3BzKSA6IHN0eWxlUHJvcDtcbiAgICByZXR1cm4gLyogQF9fUFVSRV9fICovIFJlYWN0MTAuY3JlYXRlRWxlbWVudChcbiAgICAgIExpbmssXG4gICAgICB7XG4gICAgICAgIC4uLnJlc3QsXG4gICAgICAgIFwiYXJpYS1jdXJyZW50XCI6IGFyaWFDdXJyZW50LFxuICAgICAgICBjbGFzc05hbWUsXG4gICAgICAgIHJlZixcbiAgICAgICAgc3R5bGUsXG4gICAgICAgIHRvLFxuICAgICAgICB2aWV3VHJhbnNpdGlvblxuICAgICAgfSxcbiAgICAgIHR5cGVvZiBjaGlsZHJlbiA9PT0gXCJmdW5jdGlvblwiID8gY2hpbGRyZW4ocmVuZGVyUHJvcHMpIDogY2hpbGRyZW5cbiAgICApO1xuICB9XG4pO1xuTmF2TGluay5kaXNwbGF5TmFtZSA9IFwiTmF2TGlua1wiO1xudmFyIEZvcm0gPSBSZWFjdDEwLmZvcndhcmRSZWYoXG4gICh7XG4gICAgZGlzY292ZXIgPSBcInJlbmRlclwiLFxuICAgIGZldGNoZXJLZXksXG4gICAgbmF2aWdhdGUsXG4gICAgcmVsb2FkRG9jdW1lbnQsXG4gICAgcmVwbGFjZTogcmVwbGFjZTIsXG4gICAgc3RhdGUsXG4gICAgbWV0aG9kID0gZGVmYXVsdE1ldGhvZCxcbiAgICBhY3Rpb24sXG4gICAgb25TdWJtaXQsXG4gICAgcmVsYXRpdmUsXG4gICAgcHJldmVudFNjcm9sbFJlc2V0LFxuICAgIHZpZXdUcmFuc2l0aW9uLFxuICAgIC4uLnByb3BzXG4gIH0sIGZvcndhcmRlZFJlZikgPT4ge1xuICAgIGxldCBzdWJtaXQgPSB1c2VTdWJtaXQoKTtcbiAgICBsZXQgZm9ybUFjdGlvbiA9IHVzZUZvcm1BY3Rpb24oYWN0aW9uLCB7IHJlbGF0aXZlIH0pO1xuICAgIGxldCBmb3JtTWV0aG9kID0gbWV0aG9kLnRvTG93ZXJDYXNlKCkgPT09IFwiZ2V0XCIgPyBcImdldFwiIDogXCJwb3N0XCI7XG4gICAgbGV0IGlzQWJzb2x1dGUgPSB0eXBlb2YgYWN0aW9uID09PSBcInN0cmluZ1wiICYmIEFCU09MVVRFX1VSTF9SRUdFWDIudGVzdChhY3Rpb24pO1xuICAgIGxldCBzdWJtaXRIYW5kbGVyID0gKGV2ZW50KSA9PiB7XG4gICAgICBvblN1Ym1pdCAmJiBvblN1Ym1pdChldmVudCk7XG4gICAgICBpZiAoZXZlbnQuZGVmYXVsdFByZXZlbnRlZCkgcmV0dXJuO1xuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgIGxldCBzdWJtaXR0ZXIgPSBldmVudC5uYXRpdmVFdmVudC5zdWJtaXR0ZXI7XG4gICAgICBsZXQgc3VibWl0TWV0aG9kID0gc3VibWl0dGVyPy5nZXRBdHRyaWJ1dGUoXCJmb3JtbWV0aG9kXCIpIHx8IG1ldGhvZDtcbiAgICAgIHN1Ym1pdChzdWJtaXR0ZXIgfHwgZXZlbnQuY3VycmVudFRhcmdldCwge1xuICAgICAgICBmZXRjaGVyS2V5LFxuICAgICAgICBtZXRob2Q6IHN1Ym1pdE1ldGhvZCxcbiAgICAgICAgbmF2aWdhdGUsXG4gICAgICAgIHJlcGxhY2U6IHJlcGxhY2UyLFxuICAgICAgICBzdGF0ZSxcbiAgICAgICAgcmVsYXRpdmUsXG4gICAgICAgIHByZXZlbnRTY3JvbGxSZXNldCxcbiAgICAgICAgdmlld1RyYW5zaXRpb25cbiAgICAgIH0pO1xuICAgIH07XG4gICAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBSZWFjdDEwLmNyZWF0ZUVsZW1lbnQoXG4gICAgICBcImZvcm1cIixcbiAgICAgIHtcbiAgICAgICAgcmVmOiBmb3J3YXJkZWRSZWYsXG4gICAgICAgIG1ldGhvZDogZm9ybU1ldGhvZCxcbiAgICAgICAgYWN0aW9uOiBmb3JtQWN0aW9uLFxuICAgICAgICBvblN1Ym1pdDogcmVsb2FkRG9jdW1lbnQgPyBvblN1Ym1pdCA6IHN1Ym1pdEhhbmRsZXIsXG4gICAgICAgIC4uLnByb3BzLFxuICAgICAgICBcImRhdGEtZGlzY292ZXJcIjogIWlzQWJzb2x1dGUgJiYgZGlzY292ZXIgPT09IFwicmVuZGVyXCIgPyBcInRydWVcIiA6IHZvaWQgMFxuICAgICAgfVxuICAgICk7XG4gIH1cbik7XG5Gb3JtLmRpc3BsYXlOYW1lID0gXCJGb3JtXCI7XG5mdW5jdGlvbiBTY3JvbGxSZXN0b3JhdGlvbih7XG4gIGdldEtleSxcbiAgc3RvcmFnZUtleSxcbiAgLi4ucHJvcHNcbn0pIHtcbiAgbGV0IHJlbWl4Q29udGV4dCA9IFJlYWN0MTAudXNlQ29udGV4dChGcmFtZXdvcmtDb250ZXh0KTtcbiAgbGV0IHsgYmFzZW5hbWUgfSA9IFJlYWN0MTAudXNlQ29udGV4dChOYXZpZ2F0aW9uQ29udGV4dCk7XG4gIGxldCBsb2NhdGlvbiA9IHVzZUxvY2F0aW9uKCk7XG4gIGxldCBtYXRjaGVzID0gdXNlTWF0Y2hlcygpO1xuICB1c2VTY3JvbGxSZXN0b3JhdGlvbih7IGdldEtleSwgc3RvcmFnZUtleSB9KTtcbiAgbGV0IHNzcktleSA9IFJlYWN0MTAudXNlTWVtbyhcbiAgICAoKSA9PiB7XG4gICAgICBpZiAoIXJlbWl4Q29udGV4dCB8fCAhZ2V0S2V5KSByZXR1cm4gbnVsbDtcbiAgICAgIGxldCB1c2VyS2V5ID0gZ2V0U2Nyb2xsUmVzdG9yYXRpb25LZXkoXG4gICAgICAgIGxvY2F0aW9uLFxuICAgICAgICBtYXRjaGVzLFxuICAgICAgICBiYXNlbmFtZSxcbiAgICAgICAgZ2V0S2V5XG4gICAgICApO1xuICAgICAgcmV0dXJuIHVzZXJLZXkgIT09IGxvY2F0aW9uLmtleSA/IHVzZXJLZXkgOiBudWxsO1xuICAgIH0sXG4gICAgLy8gTmFoLCB3ZSBvbmx5IG5lZWQgdGhpcyB0aGUgZmlyc3QgdGltZSBmb3IgdGhlIFNTUiByZW5kZXJcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaG9va3MvZXhoYXVzdGl2ZS1kZXBzXG4gICAgW11cbiAgKTtcbiAgaWYgKCFyZW1peENvbnRleHQgfHwgcmVtaXhDb250ZXh0LmlzU3BhTW9kZSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGxldCByZXN0b3JlU2Nyb2xsID0gKChzdG9yYWdlS2V5MiwgcmVzdG9yZUtleSkgPT4ge1xuICAgIGlmICghd2luZG93Lmhpc3Rvcnkuc3RhdGUgfHwgIXdpbmRvdy5oaXN0b3J5LnN0YXRlLmtleSkge1xuICAgICAgbGV0IGtleSA9IE1hdGgucmFuZG9tKCkudG9TdHJpbmcoMzIpLnNsaWNlKDIpO1xuICAgICAgd2luZG93Lmhpc3RvcnkucmVwbGFjZVN0YXRlKHsga2V5IH0sIFwiXCIpO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgbGV0IHBvc2l0aW9ucyA9IEpTT04ucGFyc2Uoc2Vzc2lvblN0b3JhZ2UuZ2V0SXRlbShzdG9yYWdlS2V5MikgfHwgXCJ7fVwiKTtcbiAgICAgIGxldCBzdG9yZWRZID0gcG9zaXRpb25zW3Jlc3RvcmVLZXkgfHwgd2luZG93Lmhpc3Rvcnkuc3RhdGUua2V5XTtcbiAgICAgIGlmICh0eXBlb2Ygc3RvcmVkWSA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICB3aW5kb3cuc2Nyb2xsVG8oMCwgc3RvcmVkWSk7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoZXJyb3IpO1xuICAgICAgc2Vzc2lvblN0b3JhZ2UucmVtb3ZlSXRlbShzdG9yYWdlS2V5Mik7XG4gICAgfVxuICB9KS50b1N0cmluZygpO1xuICByZXR1cm4gLyogQF9fUFVSRV9fICovIFJlYWN0MTAuY3JlYXRlRWxlbWVudChcbiAgICBcInNjcmlwdFwiLFxuICAgIHtcbiAgICAgIC4uLnByb3BzLFxuICAgICAgc3VwcHJlc3NIeWRyYXRpb25XYXJuaW5nOiB0cnVlLFxuICAgICAgZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUw6IHtcbiAgICAgICAgX19odG1sOiBgKCR7cmVzdG9yZVNjcm9sbH0pKCR7SlNPTi5zdHJpbmdpZnkoXG4gICAgICAgICAgc3RvcmFnZUtleSB8fCBTQ1JPTExfUkVTVE9SQVRJT05fU1RPUkFHRV9LRVlcbiAgICAgICAgKX0sICR7SlNPTi5zdHJpbmdpZnkoc3NyS2V5KX0pYFxuICAgICAgfVxuICAgIH1cbiAgKTtcbn1cblNjcm9sbFJlc3RvcmF0aW9uLmRpc3BsYXlOYW1lID0gXCJTY3JvbGxSZXN0b3JhdGlvblwiO1xuZnVuY3Rpb24gZ2V0RGF0YVJvdXRlckNvbnNvbGVFcnJvcjIoaG9va05hbWUpIHtcbiAgcmV0dXJuIGAke2hvb2tOYW1lfSBtdXN0IGJlIHVzZWQgd2l0aGluIGEgZGF0YSByb3V0ZXIuICBTZWUgaHR0cHM6Ly9yZWFjdHJvdXRlci5jb20vZW4vbWFpbi9yb3V0ZXJzL3BpY2tpbmctYS1yb3V0ZXIuYDtcbn1cbmZ1bmN0aW9uIHVzZURhdGFSb3V0ZXJDb250ZXh0Myhob29rTmFtZSkge1xuICBsZXQgY3R4ID0gUmVhY3QxMC51c2VDb250ZXh0KERhdGFSb3V0ZXJDb250ZXh0KTtcbiAgaW52YXJpYW50KGN0eCwgZ2V0RGF0YVJvdXRlckNvbnNvbGVFcnJvcjIoaG9va05hbWUpKTtcbiAgcmV0dXJuIGN0eDtcbn1cbmZ1bmN0aW9uIHVzZURhdGFSb3V0ZXJTdGF0ZTIoaG9va05hbWUpIHtcbiAgbGV0IHN0YXRlID0gUmVhY3QxMC51c2VDb250ZXh0KERhdGFSb3V0ZXJTdGF0ZUNvbnRleHQpO1xuICBpbnZhcmlhbnQoc3RhdGUsIGdldERhdGFSb3V0ZXJDb25zb2xlRXJyb3IyKGhvb2tOYW1lKSk7XG4gIHJldHVybiBzdGF0ZTtcbn1cbmZ1bmN0aW9uIHVzZUxpbmtDbGlja0hhbmRsZXIodG8sIHtcbiAgdGFyZ2V0LFxuICByZXBsYWNlOiByZXBsYWNlUHJvcCxcbiAgc3RhdGUsXG4gIHByZXZlbnRTY3JvbGxSZXNldCxcbiAgcmVsYXRpdmUsXG4gIHZpZXdUcmFuc2l0aW9uXG59ID0ge30pIHtcbiAgbGV0IG5hdmlnYXRlID0gdXNlTmF2aWdhdGUoKTtcbiAgbGV0IGxvY2F0aW9uID0gdXNlTG9jYXRpb24oKTtcbiAgbGV0IHBhdGggPSB1c2VSZXNvbHZlZFBhdGgodG8sIHsgcmVsYXRpdmUgfSk7XG4gIHJldHVybiBSZWFjdDEwLnVzZUNhbGxiYWNrKFxuICAgIChldmVudCkgPT4ge1xuICAgICAgaWYgKHNob3VsZFByb2Nlc3NMaW5rQ2xpY2soZXZlbnQsIHRhcmdldCkpIHtcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgbGV0IHJlcGxhY2UyID0gcmVwbGFjZVByb3AgIT09IHZvaWQgMCA/IHJlcGxhY2VQcm9wIDogY3JlYXRlUGF0aChsb2NhdGlvbikgPT09IGNyZWF0ZVBhdGgocGF0aCk7XG4gICAgICAgIG5hdmlnYXRlKHRvLCB7XG4gICAgICAgICAgcmVwbGFjZTogcmVwbGFjZTIsXG4gICAgICAgICAgc3RhdGUsXG4gICAgICAgICAgcHJldmVudFNjcm9sbFJlc2V0LFxuICAgICAgICAgIHJlbGF0aXZlLFxuICAgICAgICAgIHZpZXdUcmFuc2l0aW9uXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0sXG4gICAgW1xuICAgICAgbG9jYXRpb24sXG4gICAgICBuYXZpZ2F0ZSxcbiAgICAgIHBhdGgsXG4gICAgICByZXBsYWNlUHJvcCxcbiAgICAgIHN0YXRlLFxuICAgICAgdGFyZ2V0LFxuICAgICAgdG8sXG4gICAgICBwcmV2ZW50U2Nyb2xsUmVzZXQsXG4gICAgICByZWxhdGl2ZSxcbiAgICAgIHZpZXdUcmFuc2l0aW9uXG4gICAgXVxuICApO1xufVxuZnVuY3Rpb24gdXNlU2VhcmNoUGFyYW1zKGRlZmF1bHRJbml0KSB7XG4gIHdhcm5pbmcoXG4gICAgdHlwZW9mIFVSTFNlYXJjaFBhcmFtcyAhPT0gXCJ1bmRlZmluZWRcIixcbiAgICBgWW91IGNhbm5vdCB1c2UgdGhlIFxcYHVzZVNlYXJjaFBhcmFtc1xcYCBob29rIGluIGEgYnJvd3NlciB0aGF0IGRvZXMgbm90IHN1cHBvcnQgdGhlIFVSTFNlYXJjaFBhcmFtcyBBUEkuIElmIHlvdSBuZWVkIHRvIHN1cHBvcnQgSW50ZXJuZXQgRXhwbG9yZXIgMTEsIHdlIHJlY29tbWVuZCB5b3UgbG9hZCBhIHBvbHlmaWxsIHN1Y2ggYXMgaHR0cHM6Ly9naXRodWIuY29tL3VuZ2FwL3VybC1zZWFyY2gtcGFyYW1zLmBcbiAgKTtcbiAgbGV0IGRlZmF1bHRTZWFyY2hQYXJhbXNSZWYgPSBSZWFjdDEwLnVzZVJlZihjcmVhdGVTZWFyY2hQYXJhbXMoZGVmYXVsdEluaXQpKTtcbiAgbGV0IGhhc1NldFNlYXJjaFBhcmFtc1JlZiA9IFJlYWN0MTAudXNlUmVmKGZhbHNlKTtcbiAgbGV0IGxvY2F0aW9uID0gdXNlTG9jYXRpb24oKTtcbiAgbGV0IHNlYXJjaFBhcmFtcyA9IFJlYWN0MTAudXNlTWVtbyhcbiAgICAoKSA9PiAoXG4gICAgICAvLyBPbmx5IG1lcmdlIGluIHRoZSBkZWZhdWx0cyBpZiB3ZSBoYXZlbid0IHlldCBjYWxsZWQgc2V0U2VhcmNoUGFyYW1zLlxuICAgICAgLy8gT25jZSB3ZSBjYWxsIHRoYXQgd2Ugd2FudCB0aG9zZSB0byB0YWtlIHByZWNlZGVuY2UsIG90aGVyd2lzZSB5b3UgY2FuJ3RcbiAgICAgIC8vIHJlbW92ZSBhIHBhcmFtIHdpdGggc2V0U2VhcmNoUGFyYW1zKHt9KSBpZiBpdCBoYXMgYW4gaW5pdGlhbCB2YWx1ZVxuICAgICAgZ2V0U2VhcmNoUGFyYW1zRm9yTG9jYXRpb24oXG4gICAgICAgIGxvY2F0aW9uLnNlYXJjaCxcbiAgICAgICAgaGFzU2V0U2VhcmNoUGFyYW1zUmVmLmN1cnJlbnQgPyBudWxsIDogZGVmYXVsdFNlYXJjaFBhcmFtc1JlZi5jdXJyZW50XG4gICAgICApXG4gICAgKSxcbiAgICBbbG9jYXRpb24uc2VhcmNoXVxuICApO1xuICBsZXQgbmF2aWdhdGUgPSB1c2VOYXZpZ2F0ZSgpO1xuICBsZXQgc2V0U2VhcmNoUGFyYW1zID0gUmVhY3QxMC51c2VDYWxsYmFjayhcbiAgICAobmV4dEluaXQsIG5hdmlnYXRlT3B0aW9ucykgPT4ge1xuICAgICAgY29uc3QgbmV3U2VhcmNoUGFyYW1zID0gY3JlYXRlU2VhcmNoUGFyYW1zKFxuICAgICAgICB0eXBlb2YgbmV4dEluaXQgPT09IFwiZnVuY3Rpb25cIiA/IG5leHRJbml0KHNlYXJjaFBhcmFtcykgOiBuZXh0SW5pdFxuICAgICAgKTtcbiAgICAgIGhhc1NldFNlYXJjaFBhcmFtc1JlZi5jdXJyZW50ID0gdHJ1ZTtcbiAgICAgIG5hdmlnYXRlKFwiP1wiICsgbmV3U2VhcmNoUGFyYW1zLCBuYXZpZ2F0ZU9wdGlvbnMpO1xuICAgIH0sXG4gICAgW25hdmlnYXRlLCBzZWFyY2hQYXJhbXNdXG4gICk7XG4gIHJldHVybiBbc2VhcmNoUGFyYW1zLCBzZXRTZWFyY2hQYXJhbXNdO1xufVxudmFyIGZldGNoZXJJZCA9IDA7XG52YXIgZ2V0VW5pcXVlRmV0Y2hlcklkID0gKCkgPT4gYF9fJHtTdHJpbmcoKytmZXRjaGVySWQpfV9fYDtcbmZ1bmN0aW9uIHVzZVN1Ym1pdCgpIHtcbiAgbGV0IHsgcm91dGVyIH0gPSB1c2VEYXRhUm91dGVyQ29udGV4dDMoXCJ1c2VTdWJtaXRcIiAvKiBVc2VTdWJtaXQgKi8pO1xuICBsZXQgeyBiYXNlbmFtZSB9ID0gUmVhY3QxMC51c2VDb250ZXh0KE5hdmlnYXRpb25Db250ZXh0KTtcbiAgbGV0IGN1cnJlbnRSb3V0ZUlkID0gdXNlUm91dGVJZCgpO1xuICByZXR1cm4gUmVhY3QxMC51c2VDYWxsYmFjayhcbiAgICBhc3luYyAodGFyZ2V0LCBvcHRpb25zID0ge30pID0+IHtcbiAgICAgIGxldCB7IGFjdGlvbiwgbWV0aG9kLCBlbmNUeXBlLCBmb3JtRGF0YSwgYm9keSB9ID0gZ2V0Rm9ybVN1Ym1pc3Npb25JbmZvKFxuICAgICAgICB0YXJnZXQsXG4gICAgICAgIGJhc2VuYW1lXG4gICAgICApO1xuICAgICAgaWYgKG9wdGlvbnMubmF2aWdhdGUgPT09IGZhbHNlKSB7XG4gICAgICAgIGxldCBrZXkgPSBvcHRpb25zLmZldGNoZXJLZXkgfHwgZ2V0VW5pcXVlRmV0Y2hlcklkKCk7XG4gICAgICAgIGF3YWl0IHJvdXRlci5mZXRjaChrZXksIGN1cnJlbnRSb3V0ZUlkLCBvcHRpb25zLmFjdGlvbiB8fCBhY3Rpb24sIHtcbiAgICAgICAgICBwcmV2ZW50U2Nyb2xsUmVzZXQ6IG9wdGlvbnMucHJldmVudFNjcm9sbFJlc2V0LFxuICAgICAgICAgIGZvcm1EYXRhLFxuICAgICAgICAgIGJvZHksXG4gICAgICAgICAgZm9ybU1ldGhvZDogb3B0aW9ucy5tZXRob2QgfHwgbWV0aG9kLFxuICAgICAgICAgIGZvcm1FbmNUeXBlOiBvcHRpb25zLmVuY1R5cGUgfHwgZW5jVHlwZSxcbiAgICAgICAgICBmbHVzaFN5bmM6IG9wdGlvbnMuZmx1c2hTeW5jXG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYXdhaXQgcm91dGVyLm5hdmlnYXRlKG9wdGlvbnMuYWN0aW9uIHx8IGFjdGlvbiwge1xuICAgICAgICAgIHByZXZlbnRTY3JvbGxSZXNldDogb3B0aW9ucy5wcmV2ZW50U2Nyb2xsUmVzZXQsXG4gICAgICAgICAgZm9ybURhdGEsXG4gICAgICAgICAgYm9keSxcbiAgICAgICAgICBmb3JtTWV0aG9kOiBvcHRpb25zLm1ldGhvZCB8fCBtZXRob2QsXG4gICAgICAgICAgZm9ybUVuY1R5cGU6IG9wdGlvbnMuZW5jVHlwZSB8fCBlbmNUeXBlLFxuICAgICAgICAgIHJlcGxhY2U6IG9wdGlvbnMucmVwbGFjZSxcbiAgICAgICAgICBzdGF0ZTogb3B0aW9ucy5zdGF0ZSxcbiAgICAgICAgICBmcm9tUm91dGVJZDogY3VycmVudFJvdXRlSWQsXG4gICAgICAgICAgZmx1c2hTeW5jOiBvcHRpb25zLmZsdXNoU3luYyxcbiAgICAgICAgICB2aWV3VHJhbnNpdGlvbjogb3B0aW9ucy52aWV3VHJhbnNpdGlvblxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9LFxuICAgIFtyb3V0ZXIsIGJhc2VuYW1lLCBjdXJyZW50Um91dGVJZF1cbiAgKTtcbn1cbmZ1bmN0aW9uIHVzZUZvcm1BY3Rpb24oYWN0aW9uLCB7IHJlbGF0aXZlIH0gPSB7fSkge1xuICBsZXQgeyBiYXNlbmFtZSB9ID0gUmVhY3QxMC51c2VDb250ZXh0KE5hdmlnYXRpb25Db250ZXh0KTtcbiAgbGV0IHJvdXRlQ29udGV4dCA9IFJlYWN0MTAudXNlQ29udGV4dChSb3V0ZUNvbnRleHQpO1xuICBpbnZhcmlhbnQocm91dGVDb250ZXh0LCBcInVzZUZvcm1BY3Rpb24gbXVzdCBiZSB1c2VkIGluc2lkZSBhIFJvdXRlQ29udGV4dFwiKTtcbiAgbGV0IFttYXRjaF0gPSByb3V0ZUNvbnRleHQubWF0Y2hlcy5zbGljZSgtMSk7XG4gIGxldCBwYXRoID0geyAuLi51c2VSZXNvbHZlZFBhdGgoYWN0aW9uID8gYWN0aW9uIDogXCIuXCIsIHsgcmVsYXRpdmUgfSkgfTtcbiAgbGV0IGxvY2F0aW9uID0gdXNlTG9jYXRpb24oKTtcbiAgaWYgKGFjdGlvbiA9PSBudWxsKSB7XG4gICAgcGF0aC5zZWFyY2ggPSBsb2NhdGlvbi5zZWFyY2g7XG4gICAgbGV0IHBhcmFtcyA9IG5ldyBVUkxTZWFyY2hQYXJhbXMocGF0aC5zZWFyY2gpO1xuICAgIGxldCBpbmRleFZhbHVlcyA9IHBhcmFtcy5nZXRBbGwoXCJpbmRleFwiKTtcbiAgICBsZXQgaGFzTmFrZWRJbmRleFBhcmFtID0gaW5kZXhWYWx1ZXMuc29tZSgodikgPT4gdiA9PT0gXCJcIik7XG4gICAgaWYgKGhhc05ha2VkSW5kZXhQYXJhbSkge1xuICAgICAgcGFyYW1zLmRlbGV0ZShcImluZGV4XCIpO1xuICAgICAgaW5kZXhWYWx1ZXMuZmlsdGVyKCh2KSA9PiB2KS5mb3JFYWNoKCh2KSA9PiBwYXJhbXMuYXBwZW5kKFwiaW5kZXhcIiwgdikpO1xuICAgICAgbGV0IHFzID0gcGFyYW1zLnRvU3RyaW5nKCk7XG4gICAgICBwYXRoLnNlYXJjaCA9IHFzID8gYD8ke3FzfWAgOiBcIlwiO1xuICAgIH1cbiAgfVxuICBpZiAoKCFhY3Rpb24gfHwgYWN0aW9uID09PSBcIi5cIikgJiYgbWF0Y2gucm91dGUuaW5kZXgpIHtcbiAgICBwYXRoLnNlYXJjaCA9IHBhdGguc2VhcmNoID8gcGF0aC5zZWFyY2gucmVwbGFjZSgvXlxcPy8sIFwiP2luZGV4JlwiKSA6IFwiP2luZGV4XCI7XG4gIH1cbiAgaWYgKGJhc2VuYW1lICE9PSBcIi9cIikge1xuICAgIHBhdGgucGF0aG5hbWUgPSBwYXRoLnBhdGhuYW1lID09PSBcIi9cIiA/IGJhc2VuYW1lIDogam9pblBhdGhzKFtiYXNlbmFtZSwgcGF0aC5wYXRobmFtZV0pO1xuICB9XG4gIHJldHVybiBjcmVhdGVQYXRoKHBhdGgpO1xufVxuZnVuY3Rpb24gdXNlRmV0Y2hlcih7XG4gIGtleVxufSA9IHt9KSB7XG4gIGxldCB7IHJvdXRlciB9ID0gdXNlRGF0YVJvdXRlckNvbnRleHQzKFwidXNlRmV0Y2hlclwiIC8qIFVzZUZldGNoZXIgKi8pO1xuICBsZXQgc3RhdGUgPSB1c2VEYXRhUm91dGVyU3RhdGUyKFwidXNlRmV0Y2hlclwiIC8qIFVzZUZldGNoZXIgKi8pO1xuICBsZXQgZmV0Y2hlckRhdGEgPSBSZWFjdDEwLnVzZUNvbnRleHQoRmV0Y2hlcnNDb250ZXh0KTtcbiAgbGV0IHJvdXRlID0gUmVhY3QxMC51c2VDb250ZXh0KFJvdXRlQ29udGV4dCk7XG4gIGxldCByb3V0ZUlkID0gcm91dGUubWF0Y2hlc1tyb3V0ZS5tYXRjaGVzLmxlbmd0aCAtIDFdPy5yb3V0ZS5pZDtcbiAgaW52YXJpYW50KGZldGNoZXJEYXRhLCBgdXNlRmV0Y2hlciBtdXN0IGJlIHVzZWQgaW5zaWRlIGEgRmV0Y2hlcnNDb250ZXh0YCk7XG4gIGludmFyaWFudChyb3V0ZSwgYHVzZUZldGNoZXIgbXVzdCBiZSB1c2VkIGluc2lkZSBhIFJvdXRlQ29udGV4dGApO1xuICBpbnZhcmlhbnQoXG4gICAgcm91dGVJZCAhPSBudWxsLFxuICAgIGB1c2VGZXRjaGVyIGNhbiBvbmx5IGJlIHVzZWQgb24gcm91dGVzIHRoYXQgY29udGFpbiBhIHVuaXF1ZSBcImlkXCJgXG4gICk7XG4gIGxldCBkZWZhdWx0S2V5ID0gUmVhY3QxMC51c2VJZCgpO1xuICBsZXQgW2ZldGNoZXJLZXksIHNldEZldGNoZXJLZXldID0gUmVhY3QxMC51c2VTdGF0ZShrZXkgfHwgZGVmYXVsdEtleSk7XG4gIGlmIChrZXkgJiYga2V5ICE9PSBmZXRjaGVyS2V5KSB7XG4gICAgc2V0RmV0Y2hlcktleShrZXkpO1xuICB9XG4gIFJlYWN0MTAudXNlRWZmZWN0KCgpID0+IHtcbiAgICByb3V0ZXIuZ2V0RmV0Y2hlcihmZXRjaGVyS2V5KTtcbiAgICByZXR1cm4gKCkgPT4gcm91dGVyLmRlbGV0ZUZldGNoZXIoZmV0Y2hlcktleSk7XG4gIH0sIFtyb3V0ZXIsIGZldGNoZXJLZXldKTtcbiAgbGV0IGxvYWQgPSBSZWFjdDEwLnVzZUNhbGxiYWNrKFxuICAgIGFzeW5jIChocmVmLCBvcHRzKSA9PiB7XG4gICAgICBpbnZhcmlhbnQocm91dGVJZCwgXCJObyByb3V0ZUlkIGF2YWlsYWJsZSBmb3IgZmV0Y2hlci5sb2FkKClcIik7XG4gICAgICBhd2FpdCByb3V0ZXIuZmV0Y2goZmV0Y2hlcktleSwgcm91dGVJZCwgaHJlZiwgb3B0cyk7XG4gICAgfSxcbiAgICBbZmV0Y2hlcktleSwgcm91dGVJZCwgcm91dGVyXVxuICApO1xuICBsZXQgc3VibWl0SW1wbCA9IHVzZVN1Ym1pdCgpO1xuICBsZXQgc3VibWl0ID0gUmVhY3QxMC51c2VDYWxsYmFjayhcbiAgICBhc3luYyAodGFyZ2V0LCBvcHRzKSA9PiB7XG4gICAgICBhd2FpdCBzdWJtaXRJbXBsKHRhcmdldCwge1xuICAgICAgICAuLi5vcHRzLFxuICAgICAgICBuYXZpZ2F0ZTogZmFsc2UsXG4gICAgICAgIGZldGNoZXJLZXlcbiAgICAgIH0pO1xuICAgIH0sXG4gICAgW2ZldGNoZXJLZXksIHN1Ym1pdEltcGxdXG4gICk7XG4gIGxldCBGZXRjaGVyRm9ybSA9IFJlYWN0MTAudXNlTWVtbygoKSA9PiB7XG4gICAgbGV0IEZldGNoZXJGb3JtMiA9IFJlYWN0MTAuZm9yd2FyZFJlZihcbiAgICAgIChwcm9wcywgcmVmKSA9PiB7XG4gICAgICAgIHJldHVybiAvKiBAX19QVVJFX18gKi8gUmVhY3QxMC5jcmVhdGVFbGVtZW50KEZvcm0sIHsgLi4ucHJvcHMsIG5hdmlnYXRlOiBmYWxzZSwgZmV0Y2hlcktleSwgcmVmIH0pO1xuICAgICAgfVxuICAgICk7XG4gICAgRmV0Y2hlckZvcm0yLmRpc3BsYXlOYW1lID0gXCJmZXRjaGVyLkZvcm1cIjtcbiAgICByZXR1cm4gRmV0Y2hlckZvcm0yO1xuICB9LCBbZmV0Y2hlcktleV0pO1xuICBsZXQgZmV0Y2hlciA9IHN0YXRlLmZldGNoZXJzLmdldChmZXRjaGVyS2V5KSB8fCBJRExFX0ZFVENIRVI7XG4gIGxldCBkYXRhMiA9IGZldGNoZXJEYXRhLmdldChmZXRjaGVyS2V5KTtcbiAgbGV0IGZldGNoZXJXaXRoQ29tcG9uZW50cyA9IFJlYWN0MTAudXNlTWVtbyhcbiAgICAoKSA9PiAoe1xuICAgICAgRm9ybTogRmV0Y2hlckZvcm0sXG4gICAgICBzdWJtaXQsXG4gICAgICBsb2FkLFxuICAgICAgLi4uZmV0Y2hlcixcbiAgICAgIGRhdGE6IGRhdGEyXG4gICAgfSksXG4gICAgW0ZldGNoZXJGb3JtLCBzdWJtaXQsIGxvYWQsIGZldGNoZXIsIGRhdGEyXVxuICApO1xuICByZXR1cm4gZmV0Y2hlcldpdGhDb21wb25lbnRzO1xufVxuZnVuY3Rpb24gdXNlRmV0Y2hlcnMoKSB7XG4gIGxldCBzdGF0ZSA9IHVzZURhdGFSb3V0ZXJTdGF0ZTIoXCJ1c2VGZXRjaGVyc1wiIC8qIFVzZUZldGNoZXJzICovKTtcbiAgcmV0dXJuIEFycmF5LmZyb20oc3RhdGUuZmV0Y2hlcnMuZW50cmllcygpKS5tYXAoKFtrZXksIGZldGNoZXJdKSA9PiAoe1xuICAgIC4uLmZldGNoZXIsXG4gICAga2V5XG4gIH0pKTtcbn1cbnZhciBTQ1JPTExfUkVTVE9SQVRJT05fU1RPUkFHRV9LRVkgPSBcInJlYWN0LXJvdXRlci1zY3JvbGwtcG9zaXRpb25zXCI7XG52YXIgc2F2ZWRTY3JvbGxQb3NpdGlvbnMgPSB7fTtcbmZ1bmN0aW9uIGdldFNjcm9sbFJlc3RvcmF0aW9uS2V5KGxvY2F0aW9uLCBtYXRjaGVzLCBiYXNlbmFtZSwgZ2V0S2V5KSB7XG4gIGxldCBrZXkgPSBudWxsO1xuICBpZiAoZ2V0S2V5KSB7XG4gICAgaWYgKGJhc2VuYW1lICE9PSBcIi9cIikge1xuICAgICAga2V5ID0gZ2V0S2V5KFxuICAgICAgICB7XG4gICAgICAgICAgLi4ubG9jYXRpb24sXG4gICAgICAgICAgcGF0aG5hbWU6IHN0cmlwQmFzZW5hbWUobG9jYXRpb24ucGF0aG5hbWUsIGJhc2VuYW1lKSB8fCBsb2NhdGlvbi5wYXRobmFtZVxuICAgICAgICB9LFxuICAgICAgICBtYXRjaGVzXG4gICAgICApO1xuICAgIH0gZWxzZSB7XG4gICAgICBrZXkgPSBnZXRLZXkobG9jYXRpb24sIG1hdGNoZXMpO1xuICAgIH1cbiAgfVxuICBpZiAoa2V5ID09IG51bGwpIHtcbiAgICBrZXkgPSBsb2NhdGlvbi5rZXk7XG4gIH1cbiAgcmV0dXJuIGtleTtcbn1cbmZ1bmN0aW9uIHVzZVNjcm9sbFJlc3RvcmF0aW9uKHtcbiAgZ2V0S2V5LFxuICBzdG9yYWdlS2V5XG59ID0ge30pIHtcbiAgbGV0IHsgcm91dGVyIH0gPSB1c2VEYXRhUm91dGVyQ29udGV4dDMoXCJ1c2VTY3JvbGxSZXN0b3JhdGlvblwiIC8qIFVzZVNjcm9sbFJlc3RvcmF0aW9uICovKTtcbiAgbGV0IHsgcmVzdG9yZVNjcm9sbFBvc2l0aW9uLCBwcmV2ZW50U2Nyb2xsUmVzZXQgfSA9IHVzZURhdGFSb3V0ZXJTdGF0ZTIoXG4gICAgXCJ1c2VTY3JvbGxSZXN0b3JhdGlvblwiIC8qIFVzZVNjcm9sbFJlc3RvcmF0aW9uICovXG4gICk7XG4gIGxldCB7IGJhc2VuYW1lIH0gPSBSZWFjdDEwLnVzZUNvbnRleHQoTmF2aWdhdGlvbkNvbnRleHQpO1xuICBsZXQgbG9jYXRpb24gPSB1c2VMb2NhdGlvbigpO1xuICBsZXQgbWF0Y2hlcyA9IHVzZU1hdGNoZXMoKTtcbiAgbGV0IG5hdmlnYXRpb24gPSB1c2VOYXZpZ2F0aW9uKCk7XG4gIFJlYWN0MTAudXNlRWZmZWN0KCgpID0+IHtcbiAgICB3aW5kb3cuaGlzdG9yeS5zY3JvbGxSZXN0b3JhdGlvbiA9IFwibWFudWFsXCI7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIHdpbmRvdy5oaXN0b3J5LnNjcm9sbFJlc3RvcmF0aW9uID0gXCJhdXRvXCI7XG4gICAgfTtcbiAgfSwgW10pO1xuICB1c2VQYWdlSGlkZShcbiAgICBSZWFjdDEwLnVzZUNhbGxiYWNrKCgpID0+IHtcbiAgICAgIGlmIChuYXZpZ2F0aW9uLnN0YXRlID09PSBcImlkbGVcIikge1xuICAgICAgICBsZXQga2V5ID0gZ2V0U2Nyb2xsUmVzdG9yYXRpb25LZXkobG9jYXRpb24sIG1hdGNoZXMsIGJhc2VuYW1lLCBnZXRLZXkpO1xuICAgICAgICBzYXZlZFNjcm9sbFBvc2l0aW9uc1trZXldID0gd2luZG93LnNjcm9sbFk7XG4gICAgICB9XG4gICAgICB0cnkge1xuICAgICAgICBzZXNzaW9uU3RvcmFnZS5zZXRJdGVtKFxuICAgICAgICAgIHN0b3JhZ2VLZXkgfHwgU0NST0xMX1JFU1RPUkFUSU9OX1NUT1JBR0VfS0VZLFxuICAgICAgICAgIEpTT04uc3RyaW5naWZ5KHNhdmVkU2Nyb2xsUG9zaXRpb25zKVxuICAgICAgICApO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgd2FybmluZyhcbiAgICAgICAgICBmYWxzZSxcbiAgICAgICAgICBgRmFpbGVkIHRvIHNhdmUgc2Nyb2xsIHBvc2l0aW9ucyBpbiBzZXNzaW9uU3RvcmFnZSwgPFNjcm9sbFJlc3RvcmF0aW9uIC8+IHdpbGwgbm90IHdvcmsgcHJvcGVybHkgKCR7ZXJyb3J9KS5gXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICB3aW5kb3cuaGlzdG9yeS5zY3JvbGxSZXN0b3JhdGlvbiA9IFwiYXV0b1wiO1xuICAgIH0sIFtuYXZpZ2F0aW9uLnN0YXRlLCBnZXRLZXksIGJhc2VuYW1lLCBsb2NhdGlvbiwgbWF0Y2hlcywgc3RvcmFnZUtleV0pXG4gICk7XG4gIGlmICh0eXBlb2YgZG9jdW1lbnQgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICBSZWFjdDEwLnVzZUxheW91dEVmZmVjdCgoKSA9PiB7XG4gICAgICB0cnkge1xuICAgICAgICBsZXQgc2Vzc2lvblBvc2l0aW9ucyA9IHNlc3Npb25TdG9yYWdlLmdldEl0ZW0oXG4gICAgICAgICAgc3RvcmFnZUtleSB8fCBTQ1JPTExfUkVTVE9SQVRJT05fU1RPUkFHRV9LRVlcbiAgICAgICAgKTtcbiAgICAgICAgaWYgKHNlc3Npb25Qb3NpdGlvbnMpIHtcbiAgICAgICAgICBzYXZlZFNjcm9sbFBvc2l0aW9ucyA9IEpTT04ucGFyc2Uoc2Vzc2lvblBvc2l0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIH1cbiAgICB9LCBbc3RvcmFnZUtleV0pO1xuICAgIFJlYWN0MTAudXNlTGF5b3V0RWZmZWN0KCgpID0+IHtcbiAgICAgIGxldCBkaXNhYmxlU2Nyb2xsUmVzdG9yYXRpb24gPSByb3V0ZXI/LmVuYWJsZVNjcm9sbFJlc3RvcmF0aW9uKFxuICAgICAgICBzYXZlZFNjcm9sbFBvc2l0aW9ucyxcbiAgICAgICAgKCkgPT4gd2luZG93LnNjcm9sbFksXG4gICAgICAgIGdldEtleSA/IChsb2NhdGlvbjIsIG1hdGNoZXMyKSA9PiBnZXRTY3JvbGxSZXN0b3JhdGlvbktleShsb2NhdGlvbjIsIG1hdGNoZXMyLCBiYXNlbmFtZSwgZ2V0S2V5KSA6IHZvaWQgMFxuICAgICAgKTtcbiAgICAgIHJldHVybiAoKSA9PiBkaXNhYmxlU2Nyb2xsUmVzdG9yYXRpb24gJiYgZGlzYWJsZVNjcm9sbFJlc3RvcmF0aW9uKCk7XG4gICAgfSwgW3JvdXRlciwgYmFzZW5hbWUsIGdldEtleV0pO1xuICAgIFJlYWN0MTAudXNlTGF5b3V0RWZmZWN0KCgpID0+IHtcbiAgICAgIGlmIChyZXN0b3JlU2Nyb2xsUG9zaXRpb24gPT09IGZhbHNlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2YgcmVzdG9yZVNjcm9sbFBvc2l0aW9uID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgIHdpbmRvdy5zY3JvbGxUbygwLCByZXN0b3JlU2Nyb2xsUG9zaXRpb24pO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAobG9jYXRpb24uaGFzaCkge1xuICAgICAgICBsZXQgZWwgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcbiAgICAgICAgICBkZWNvZGVVUklDb21wb25lbnQobG9jYXRpb24uaGFzaC5zbGljZSgxKSlcbiAgICAgICAgKTtcbiAgICAgICAgaWYgKGVsKSB7XG4gICAgICAgICAgZWwuc2Nyb2xsSW50b1ZpZXcoKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChwcmV2ZW50U2Nyb2xsUmVzZXQgPT09IHRydWUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgd2luZG93LnNjcm9sbFRvKDAsIDApO1xuICAgIH0sIFtsb2NhdGlvbiwgcmVzdG9yZVNjcm9sbFBvc2l0aW9uLCBwcmV2ZW50U2Nyb2xsUmVzZXRdKTtcbiAgfVxufVxuZnVuY3Rpb24gdXNlQmVmb3JlVW5sb2FkKGNhbGxiYWNrLCBvcHRpb25zKSB7XG4gIGxldCB7IGNhcHR1cmUgfSA9IG9wdGlvbnMgfHwge307XG4gIFJlYWN0MTAudXNlRWZmZWN0KCgpID0+IHtcbiAgICBsZXQgb3B0cyA9IGNhcHR1cmUgIT0gbnVsbCA/IHsgY2FwdHVyZSB9IDogdm9pZCAwO1xuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwiYmVmb3JldW5sb2FkXCIsIGNhbGxiYWNrLCBvcHRzKTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJiZWZvcmV1bmxvYWRcIiwgY2FsbGJhY2ssIG9wdHMpO1xuICAgIH07XG4gIH0sIFtjYWxsYmFjaywgY2FwdHVyZV0pO1xufVxuZnVuY3Rpb24gdXNlUGFnZUhpZGUoY2FsbGJhY2ssIG9wdGlvbnMpIHtcbiAgbGV0IHsgY2FwdHVyZSB9ID0gb3B0aW9ucyB8fCB7fTtcbiAgUmVhY3QxMC51c2VFZmZlY3QoKCkgPT4ge1xuICAgIGxldCBvcHRzID0gY2FwdHVyZSAhPSBudWxsID8geyBjYXB0dXJlIH0gOiB2b2lkIDA7XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJwYWdlaGlkZVwiLCBjYWxsYmFjaywgb3B0cyk7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwicGFnZWhpZGVcIiwgY2FsbGJhY2ssIG9wdHMpO1xuICAgIH07XG4gIH0sIFtjYWxsYmFjaywgY2FwdHVyZV0pO1xufVxuZnVuY3Rpb24gdXNlUHJvbXB0KHtcbiAgd2hlbixcbiAgbWVzc2FnZVxufSkge1xuICBsZXQgYmxvY2tlciA9IHVzZUJsb2NrZXIod2hlbik7XG4gIFJlYWN0MTAudXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAoYmxvY2tlci5zdGF0ZSA9PT0gXCJibG9ja2VkXCIpIHtcbiAgICAgIGxldCBwcm9jZWVkID0gd2luZG93LmNvbmZpcm0obWVzc2FnZSk7XG4gICAgICBpZiAocHJvY2VlZCkge1xuICAgICAgICBzZXRUaW1lb3V0KGJsb2NrZXIucHJvY2VlZCwgMCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBibG9ja2VyLnJlc2V0KCk7XG4gICAgICB9XG4gICAgfVxuICB9LCBbYmxvY2tlciwgbWVzc2FnZV0pO1xuICBSZWFjdDEwLnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKGJsb2NrZXIuc3RhdGUgPT09IFwiYmxvY2tlZFwiICYmICF3aGVuKSB7XG4gICAgICBibG9ja2VyLnJlc2V0KCk7XG4gICAgfVxuICB9LCBbYmxvY2tlciwgd2hlbl0pO1xufVxuZnVuY3Rpb24gdXNlVmlld1RyYW5zaXRpb25TdGF0ZSh0bywgb3B0cyA9IHt9KSB7XG4gIGxldCB2dENvbnRleHQgPSBSZWFjdDEwLnVzZUNvbnRleHQoVmlld1RyYW5zaXRpb25Db250ZXh0KTtcbiAgaW52YXJpYW50KFxuICAgIHZ0Q29udGV4dCAhPSBudWxsLFxuICAgIFwiYHVzZVZpZXdUcmFuc2l0aW9uU3RhdGVgIG11c3QgYmUgdXNlZCB3aXRoaW4gYHJlYWN0LXJvdXRlci1kb21gJ3MgYFJvdXRlclByb3ZpZGVyYC4gIERpZCB5b3UgYWNjaWRlbnRhbGx5IGltcG9ydCBgUm91dGVyUHJvdmlkZXJgIGZyb20gYHJlYWN0LXJvdXRlcmA/XCJcbiAgKTtcbiAgbGV0IHsgYmFzZW5hbWUgfSA9IHVzZURhdGFSb3V0ZXJDb250ZXh0MyhcbiAgICBcInVzZVZpZXdUcmFuc2l0aW9uU3RhdGVcIiAvKiB1c2VWaWV3VHJhbnNpdGlvblN0YXRlICovXG4gICk7XG4gIGxldCBwYXRoID0gdXNlUmVzb2x2ZWRQYXRoKHRvLCB7IHJlbGF0aXZlOiBvcHRzLnJlbGF0aXZlIH0pO1xuICBpZiAoIXZ0Q29udGV4dC5pc1RyYW5zaXRpb25pbmcpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgbGV0IGN1cnJlbnRQYXRoID0gc3RyaXBCYXNlbmFtZSh2dENvbnRleHQuY3VycmVudExvY2F0aW9uLnBhdGhuYW1lLCBiYXNlbmFtZSkgfHwgdnRDb250ZXh0LmN1cnJlbnRMb2NhdGlvbi5wYXRobmFtZTtcbiAgbGV0IG5leHRQYXRoID0gc3RyaXBCYXNlbmFtZSh2dENvbnRleHQubmV4dExvY2F0aW9uLnBhdGhuYW1lLCBiYXNlbmFtZSkgfHwgdnRDb250ZXh0Lm5leHRMb2NhdGlvbi5wYXRobmFtZTtcbiAgcmV0dXJuIG1hdGNoUGF0aChwYXRoLnBhdGhuYW1lLCBuZXh0UGF0aCkgIT0gbnVsbCB8fCBtYXRjaFBhdGgocGF0aC5wYXRobmFtZSwgY3VycmVudFBhdGgpICE9IG51bGw7XG59XG5cbi8vIGxpYi9kb20vc2VydmVyLnRzeFxudmFyIFJlYWN0MTEgPSBfX3RvRVNNKHJlcXVpcmUoXCJyZWFjdFwiKSk7XG5mdW5jdGlvbiBTdGF0aWNSb3V0ZXIoe1xuICBiYXNlbmFtZSxcbiAgY2hpbGRyZW4sXG4gIGxvY2F0aW9uOiBsb2NhdGlvblByb3AgPSBcIi9cIlxufSkge1xuICBpZiAodHlwZW9mIGxvY2F0aW9uUHJvcCA9PT0gXCJzdHJpbmdcIikge1xuICAgIGxvY2F0aW9uUHJvcCA9IHBhcnNlUGF0aChsb2NhdGlvblByb3ApO1xuICB9XG4gIGxldCBhY3Rpb24gPSBcIlBPUFwiIC8qIFBvcCAqLztcbiAgbGV0IGxvY2F0aW9uID0ge1xuICAgIHBhdGhuYW1lOiBsb2NhdGlvblByb3AucGF0aG5hbWUgfHwgXCIvXCIsXG4gICAgc2VhcmNoOiBsb2NhdGlvblByb3Auc2VhcmNoIHx8IFwiXCIsXG4gICAgaGFzaDogbG9jYXRpb25Qcm9wLmhhc2ggfHwgXCJcIixcbiAgICBzdGF0ZTogbG9jYXRpb25Qcm9wLnN0YXRlICE9IG51bGwgPyBsb2NhdGlvblByb3Auc3RhdGUgOiBudWxsLFxuICAgIGtleTogbG9jYXRpb25Qcm9wLmtleSB8fCBcImRlZmF1bHRcIlxuICB9O1xuICBsZXQgc3RhdGljTmF2aWdhdG9yID0gZ2V0U3RhdGVsZXNzTmF2aWdhdG9yKCk7XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8gUmVhY3QxMS5jcmVhdGVFbGVtZW50KFxuICAgIFJvdXRlcixcbiAgICB7XG4gICAgICBiYXNlbmFtZSxcbiAgICAgIGNoaWxkcmVuLFxuICAgICAgbG9jYXRpb24sXG4gICAgICBuYXZpZ2F0aW9uVHlwZTogYWN0aW9uLFxuICAgICAgbmF2aWdhdG9yOiBzdGF0aWNOYXZpZ2F0b3IsXG4gICAgICBzdGF0aWM6IHRydWVcbiAgICB9XG4gICk7XG59XG5mdW5jdGlvbiBTdGF0aWNSb3V0ZXJQcm92aWRlcih7XG4gIGNvbnRleHQsXG4gIHJvdXRlcixcbiAgaHlkcmF0ZSA9IHRydWUsXG4gIG5vbmNlXG59KSB7XG4gIGludmFyaWFudChcbiAgICByb3V0ZXIgJiYgY29udGV4dCxcbiAgICBcIllvdSBtdXN0IHByb3ZpZGUgYHJvdXRlcmAgYW5kIGBjb250ZXh0YCB0byA8U3RhdGljUm91dGVyUHJvdmlkZXI+XCJcbiAgKTtcbiAgbGV0IGRhdGFSb3V0ZXJDb250ZXh0ID0ge1xuICAgIHJvdXRlcixcbiAgICBuYXZpZ2F0b3I6IGdldFN0YXRlbGVzc05hdmlnYXRvcigpLFxuICAgIHN0YXRpYzogdHJ1ZSxcbiAgICBzdGF0aWNDb250ZXh0OiBjb250ZXh0LFxuICAgIGJhc2VuYW1lOiBjb250ZXh0LmJhc2VuYW1lIHx8IFwiL1wiXG4gIH07XG4gIGxldCBmZXRjaGVyc0NvbnRleHQgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICBsZXQgaHlkcmF0ZVNjcmlwdCA9IFwiXCI7XG4gIGlmIChoeWRyYXRlICE9PSBmYWxzZSkge1xuICAgIGxldCBkYXRhMiA9IHtcbiAgICAgIGxvYWRlckRhdGE6IGNvbnRleHQubG9hZGVyRGF0YSxcbiAgICAgIGFjdGlvbkRhdGE6IGNvbnRleHQuYWN0aW9uRGF0YSxcbiAgICAgIGVycm9yczogc2VyaWFsaXplRXJyb3JzKGNvbnRleHQuZXJyb3JzKVxuICAgIH07XG4gICAgbGV0IGpzb24gPSBodG1sRXNjYXBlKEpTT04uc3RyaW5naWZ5KEpTT04uc3RyaW5naWZ5KGRhdGEyKSkpO1xuICAgIGh5ZHJhdGVTY3JpcHQgPSBgd2luZG93Ll9fc3RhdGljUm91dGVySHlkcmF0aW9uRGF0YSA9IEpTT04ucGFyc2UoJHtqc29ufSk7YDtcbiAgfVxuICBsZXQgeyBzdGF0ZSB9ID0gZGF0YVJvdXRlckNvbnRleHQucm91dGVyO1xuICByZXR1cm4gLyogQF9fUFVSRV9fICovIFJlYWN0MTEuY3JlYXRlRWxlbWVudChSZWFjdDExLkZyYWdtZW50LCBudWxsLCAvKiBAX19QVVJFX18gKi8gUmVhY3QxMS5jcmVhdGVFbGVtZW50KERhdGFSb3V0ZXJDb250ZXh0LlByb3ZpZGVyLCB7IHZhbHVlOiBkYXRhUm91dGVyQ29udGV4dCB9LCAvKiBAX19QVVJFX18gKi8gUmVhY3QxMS5jcmVhdGVFbGVtZW50KERhdGFSb3V0ZXJTdGF0ZUNvbnRleHQuUHJvdmlkZXIsIHsgdmFsdWU6IHN0YXRlIH0sIC8qIEBfX1BVUkVfXyAqLyBSZWFjdDExLmNyZWF0ZUVsZW1lbnQoRmV0Y2hlcnNDb250ZXh0LlByb3ZpZGVyLCB7IHZhbHVlOiBmZXRjaGVyc0NvbnRleHQgfSwgLyogQF9fUFVSRV9fICovIFJlYWN0MTEuY3JlYXRlRWxlbWVudChWaWV3VHJhbnNpdGlvbkNvbnRleHQuUHJvdmlkZXIsIHsgdmFsdWU6IHsgaXNUcmFuc2l0aW9uaW5nOiBmYWxzZSB9IH0sIC8qIEBfX1BVUkVfXyAqLyBSZWFjdDExLmNyZWF0ZUVsZW1lbnQoXG4gICAgUm91dGVyLFxuICAgIHtcbiAgICAgIGJhc2VuYW1lOiBkYXRhUm91dGVyQ29udGV4dC5iYXNlbmFtZSxcbiAgICAgIGxvY2F0aW9uOiBzdGF0ZS5sb2NhdGlvbixcbiAgICAgIG5hdmlnYXRpb25UeXBlOiBzdGF0ZS5oaXN0b3J5QWN0aW9uLFxuICAgICAgbmF2aWdhdG9yOiBkYXRhUm91dGVyQ29udGV4dC5uYXZpZ2F0b3IsXG4gICAgICBzdGF0aWM6IGRhdGFSb3V0ZXJDb250ZXh0LnN0YXRpY1xuICAgIH0sXG4gICAgLyogQF9fUFVSRV9fICovIFJlYWN0MTEuY3JlYXRlRWxlbWVudChcbiAgICAgIERhdGFSb3V0ZXMyLFxuICAgICAge1xuICAgICAgICByb3V0ZXM6IHJvdXRlci5yb3V0ZXMsXG4gICAgICAgIGZ1dHVyZTogcm91dGVyLmZ1dHVyZSxcbiAgICAgICAgc3RhdGVcbiAgICAgIH1cbiAgICApXG4gICkpKSkpLCBoeWRyYXRlU2NyaXB0ID8gLyogQF9fUFVSRV9fICovIFJlYWN0MTEuY3JlYXRlRWxlbWVudChcbiAgICBcInNjcmlwdFwiLFxuICAgIHtcbiAgICAgIHN1cHByZXNzSHlkcmF0aW9uV2FybmluZzogdHJ1ZSxcbiAgICAgIG5vbmNlLFxuICAgICAgZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUw6IHsgX19odG1sOiBoeWRyYXRlU2NyaXB0IH1cbiAgICB9XG4gICkgOiBudWxsKTtcbn1cbmZ1bmN0aW9uIERhdGFSb3V0ZXMyKHtcbiAgcm91dGVzLFxuICBmdXR1cmUsXG4gIHN0YXRlXG59KSB7XG4gIHJldHVybiB1c2VSb3V0ZXNJbXBsKHJvdXRlcywgdm9pZCAwLCBzdGF0ZSwgZnV0dXJlKTtcbn1cbmZ1bmN0aW9uIHNlcmlhbGl6ZUVycm9ycyhlcnJvcnMpIHtcbiAgaWYgKCFlcnJvcnMpIHJldHVybiBudWxsO1xuICBsZXQgZW50cmllcyA9IE9iamVjdC5lbnRyaWVzKGVycm9ycyk7XG4gIGxldCBzZXJpYWxpemVkID0ge307XG4gIGZvciAobGV0IFtrZXksIHZhbF0gb2YgZW50cmllcykge1xuICAgIGlmIChpc1JvdXRlRXJyb3JSZXNwb25zZSh2YWwpKSB7XG4gICAgICBzZXJpYWxpemVkW2tleV0gPSB7IC4uLnZhbCwgX190eXBlOiBcIlJvdXRlRXJyb3JSZXNwb25zZVwiIH07XG4gICAgfSBlbHNlIGlmICh2YWwgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgc2VyaWFsaXplZFtrZXldID0ge1xuICAgICAgICBtZXNzYWdlOiB2YWwubWVzc2FnZSxcbiAgICAgICAgX190eXBlOiBcIkVycm9yXCIsXG4gICAgICAgIC8vIElmIHRoaXMgaXMgYSBzdWJjbGFzcyAoaS5lLiwgUmVmZXJlbmNlRXJyb3IpLCBzZW5kIHVwIHRoZSB0eXBlIHNvIHdlXG4gICAgICAgIC8vIGNhbiByZS1jcmVhdGUgdGhlIHNhbWUgdHlwZSBkdXJpbmcgaHlkcmF0aW9uLlxuICAgICAgICAuLi52YWwubmFtZSAhPT0gXCJFcnJvclwiID8ge1xuICAgICAgICAgIF9fc3ViVHlwZTogdmFsLm5hbWVcbiAgICAgICAgfSA6IHt9XG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICBzZXJpYWxpemVkW2tleV0gPSB2YWw7XG4gICAgfVxuICB9XG4gIHJldHVybiBzZXJpYWxpemVkO1xufVxuZnVuY3Rpb24gZ2V0U3RhdGVsZXNzTmF2aWdhdG9yKCkge1xuICByZXR1cm4ge1xuICAgIGNyZWF0ZUhyZWYsXG4gICAgZW5jb2RlTG9jYXRpb24sXG4gICAgcHVzaCh0bykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgWW91IGNhbm5vdCB1c2UgbmF2aWdhdG9yLnB1c2goKSBvbiB0aGUgc2VydmVyIGJlY2F1c2UgaXQgaXMgYSBzdGF0ZWxlc3MgZW52aXJvbm1lbnQuIFRoaXMgZXJyb3Igd2FzIHByb2JhYmx5IHRyaWdnZXJlZCB3aGVuIHlvdSBkaWQgYSBcXGBuYXZpZ2F0ZSgke0pTT04uc3RyaW5naWZ5KHRvKX0pXFxgIHNvbWV3aGVyZSBpbiB5b3VyIGFwcC5gXG4gICAgICApO1xuICAgIH0sXG4gICAgcmVwbGFjZSh0bykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgWW91IGNhbm5vdCB1c2UgbmF2aWdhdG9yLnJlcGxhY2UoKSBvbiB0aGUgc2VydmVyIGJlY2F1c2UgaXQgaXMgYSBzdGF0ZWxlc3MgZW52aXJvbm1lbnQuIFRoaXMgZXJyb3Igd2FzIHByb2JhYmx5IHRyaWdnZXJlZCB3aGVuIHlvdSBkaWQgYSBcXGBuYXZpZ2F0ZSgke0pTT04uc3RyaW5naWZ5KHRvKX0sIHsgcmVwbGFjZTogdHJ1ZSB9KVxcYCBzb21ld2hlcmUgaW4geW91ciBhcHAuYFxuICAgICAgKTtcbiAgICB9LFxuICAgIGdvKGRlbHRhKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGBZb3UgY2Fubm90IHVzZSBuYXZpZ2F0b3IuZ28oKSBvbiB0aGUgc2VydmVyIGJlY2F1c2UgaXQgaXMgYSBzdGF0ZWxlc3MgZW52aXJvbm1lbnQuIFRoaXMgZXJyb3Igd2FzIHByb2JhYmx5IHRyaWdnZXJlZCB3aGVuIHlvdSBkaWQgYSBcXGBuYXZpZ2F0ZSgke2RlbHRhfSlcXGAgc29tZXdoZXJlIGluIHlvdXIgYXBwLmBcbiAgICAgICk7XG4gICAgfSxcbiAgICBiYWNrKCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgWW91IGNhbm5vdCB1c2UgbmF2aWdhdG9yLmJhY2soKSBvbiB0aGUgc2VydmVyIGJlY2F1c2UgaXQgaXMgYSBzdGF0ZWxlc3MgZW52aXJvbm1lbnQuYFxuICAgICAgKTtcbiAgICB9LFxuICAgIGZvcndhcmQoKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGBZb3UgY2Fubm90IHVzZSBuYXZpZ2F0b3IuZm9yd2FyZCgpIG9uIHRoZSBzZXJ2ZXIgYmVjYXVzZSBpdCBpcyBhIHN0YXRlbGVzcyBlbnZpcm9ubWVudC5gXG4gICAgICApO1xuICAgIH1cbiAgfTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVN0YXRpY0hhbmRsZXIyKHJvdXRlcywgb3B0cykge1xuICByZXR1cm4gY3JlYXRlU3RhdGljSGFuZGxlcihyb3V0ZXMsIHtcbiAgICAuLi5vcHRzLFxuICAgIG1hcFJvdXRlUHJvcGVydGllc1xuICB9KTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVN0YXRpY1JvdXRlcihyb3V0ZXMsIGNvbnRleHQsIG9wdHMgPSB7fSkge1xuICBsZXQgbWFuaWZlc3QgPSB7fTtcbiAgbGV0IGRhdGFSb3V0ZXMgPSBjb252ZXJ0Um91dGVzVG9EYXRhUm91dGVzKFxuICAgIHJvdXRlcyxcbiAgICBtYXBSb3V0ZVByb3BlcnRpZXMsXG4gICAgdm9pZCAwLFxuICAgIG1hbmlmZXN0XG4gICk7XG4gIGxldCBtYXRjaGVzID0gY29udGV4dC5tYXRjaGVzLm1hcCgobWF0Y2gpID0+IHtcbiAgICBsZXQgcm91dGUgPSBtYW5pZmVzdFttYXRjaC5yb3V0ZS5pZF0gfHwgbWF0Y2gucm91dGU7XG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLm1hdGNoLFxuICAgICAgcm91dGVcbiAgICB9O1xuICB9KTtcbiAgbGV0IG1zZyA9IChtZXRob2QpID0+IGBZb3UgY2Fubm90IHVzZSByb3V0ZXIuJHttZXRob2R9KCkgb24gdGhlIHNlcnZlciBiZWNhdXNlIGl0IGlzIGEgc3RhdGVsZXNzIGVudmlyb25tZW50YDtcbiAgcmV0dXJuIHtcbiAgICBnZXQgYmFzZW5hbWUoKSB7XG4gICAgICByZXR1cm4gY29udGV4dC5iYXNlbmFtZTtcbiAgICB9LFxuICAgIGdldCBmdXR1cmUoKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICAuLi5vcHRzPy5mdXR1cmVcbiAgICAgIH07XG4gICAgfSxcbiAgICBnZXQgc3RhdGUoKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBoaXN0b3J5QWN0aW9uOiBcIlBPUFwiIC8qIFBvcCAqLyxcbiAgICAgICAgbG9jYXRpb246IGNvbnRleHQubG9jYXRpb24sXG4gICAgICAgIG1hdGNoZXMsXG4gICAgICAgIGxvYWRlckRhdGE6IGNvbnRleHQubG9hZGVyRGF0YSxcbiAgICAgICAgYWN0aW9uRGF0YTogY29udGV4dC5hY3Rpb25EYXRhLFxuICAgICAgICBlcnJvcnM6IGNvbnRleHQuZXJyb3JzLFxuICAgICAgICBpbml0aWFsaXplZDogdHJ1ZSxcbiAgICAgICAgbmF2aWdhdGlvbjogSURMRV9OQVZJR0FUSU9OLFxuICAgICAgICByZXN0b3JlU2Nyb2xsUG9zaXRpb246IG51bGwsXG4gICAgICAgIHByZXZlbnRTY3JvbGxSZXNldDogZmFsc2UsXG4gICAgICAgIHJldmFsaWRhdGlvbjogXCJpZGxlXCIsXG4gICAgICAgIGZldGNoZXJzOiAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpLFxuICAgICAgICBibG9ja2VyczogLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKVxuICAgICAgfTtcbiAgICB9LFxuICAgIGdldCByb3V0ZXMoKSB7XG4gICAgICByZXR1cm4gZGF0YVJvdXRlcztcbiAgICB9LFxuICAgIGdldCB3aW5kb3coKSB7XG4gICAgICByZXR1cm4gdm9pZCAwO1xuICAgIH0sXG4gICAgaW5pdGlhbGl6ZSgpIHtcbiAgICAgIHRocm93IG1zZyhcImluaXRpYWxpemVcIik7XG4gICAgfSxcbiAgICBzdWJzY3JpYmUoKSB7XG4gICAgICB0aHJvdyBtc2coXCJzdWJzY3JpYmVcIik7XG4gICAgfSxcbiAgICBlbmFibGVTY3JvbGxSZXN0b3JhdGlvbigpIHtcbiAgICAgIHRocm93IG1zZyhcImVuYWJsZVNjcm9sbFJlc3RvcmF0aW9uXCIpO1xuICAgIH0sXG4gICAgbmF2aWdhdGUoKSB7XG4gICAgICB0aHJvdyBtc2coXCJuYXZpZ2F0ZVwiKTtcbiAgICB9LFxuICAgIGZldGNoKCkge1xuICAgICAgdGhyb3cgbXNnKFwiZmV0Y2hcIik7XG4gICAgfSxcbiAgICByZXZhbGlkYXRlKCkge1xuICAgICAgdGhyb3cgbXNnKFwicmV2YWxpZGF0ZVwiKTtcbiAgICB9LFxuICAgIGNyZWF0ZUhyZWYsXG4gICAgZW5jb2RlTG9jYXRpb24sXG4gICAgZ2V0RmV0Y2hlcigpIHtcbiAgICAgIHJldHVybiBJRExFX0ZFVENIRVI7XG4gICAgfSxcbiAgICBkZWxldGVGZXRjaGVyKCkge1xuICAgICAgdGhyb3cgbXNnKFwiZGVsZXRlRmV0Y2hlclwiKTtcbiAgICB9LFxuICAgIGRpc3Bvc2UoKSB7XG4gICAgICB0aHJvdyBtc2coXCJkaXNwb3NlXCIpO1xuICAgIH0sXG4gICAgZ2V0QmxvY2tlcigpIHtcbiAgICAgIHJldHVybiBJRExFX0JMT0NLRVI7XG4gICAgfSxcbiAgICBkZWxldGVCbG9ja2VyKCkge1xuICAgICAgdGhyb3cgbXNnKFwiZGVsZXRlQmxvY2tlclwiKTtcbiAgICB9LFxuICAgIHBhdGNoUm91dGVzKCkge1xuICAgICAgdGhyb3cgbXNnKFwicGF0Y2hSb3V0ZXNcIik7XG4gICAgfSxcbiAgICBfaW50ZXJuYWxGZXRjaENvbnRyb2xsZXJzOiAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpLFxuICAgIF9pbnRlcm5hbFNldFJvdXRlcygpIHtcbiAgICAgIHRocm93IG1zZyhcIl9pbnRlcm5hbFNldFJvdXRlc1wiKTtcbiAgICB9XG4gIH07XG59XG5mdW5jdGlvbiBjcmVhdGVIcmVmKHRvKSB7XG4gIHJldHVybiB0eXBlb2YgdG8gPT09IFwic3RyaW5nXCIgPyB0byA6IGNyZWF0ZVBhdGgodG8pO1xufVxuZnVuY3Rpb24gZW5jb2RlTG9jYXRpb24odG8pIHtcbiAgbGV0IGhyZWYgPSB0eXBlb2YgdG8gPT09IFwic3RyaW5nXCIgPyB0byA6IGNyZWF0ZVBhdGgodG8pO1xuICBocmVmID0gaHJlZi5yZXBsYWNlKC8gJC8sIFwiJTIwXCIpO1xuICBsZXQgZW5jb2RlZCA9IEFCU09MVVRFX1VSTF9SRUdFWDMudGVzdChocmVmKSA/IG5ldyBVUkwoaHJlZikgOiBuZXcgVVJMKGhyZWYsIFwiaHR0cDovL2xvY2FsaG9zdFwiKTtcbiAgcmV0dXJuIHtcbiAgICBwYXRobmFtZTogZW5jb2RlZC5wYXRobmFtZSxcbiAgICBzZWFyY2g6IGVuY29kZWQuc2VhcmNoLFxuICAgIGhhc2g6IGVuY29kZWQuaGFzaFxuICB9O1xufVxudmFyIEFCU09MVVRFX1VSTF9SRUdFWDMgPSAvXig/OlthLXpdW2EtejAtOSsuLV0qOnxcXC9cXC8pL2k7XG52YXIgRVNDQVBFX0xPT0tVUDIgPSB7XG4gIFwiJlwiOiBcIlxcXFx1MDAyNlwiLFxuICBcIj5cIjogXCJcXFxcdTAwM2VcIixcbiAgXCI8XCI6IFwiXFxcXHUwMDNjXCIsXG4gIFwiXFx1MjAyOFwiOiBcIlxcXFx1MjAyOFwiLFxuICBcIlxcdTIwMjlcIjogXCJcXFxcdTIwMjlcIlxufTtcbnZhciBFU0NBUEVfUkVHRVgyID0gL1smPjxcXHUyMDI4XFx1MjAyOV0vZztcbmZ1bmN0aW9uIGh0bWxFc2NhcGUoc3RyKSB7XG4gIHJldHVybiBzdHIucmVwbGFjZShFU0NBUEVfUkVHRVgyLCAobWF0Y2gpID0+IEVTQ0FQRV9MT09LVVAyW21hdGNoXSk7XG59XG5cbi8vIGxpYi9kb20vc3NyL3NlcnZlci50c3hcbnZhciBSZWFjdDEyID0gX190b0VTTShyZXF1aXJlKFwicmVhY3RcIikpO1xuZnVuY3Rpb24gU2VydmVyUm91dGVyKHtcbiAgY29udGV4dCxcbiAgdXJsLFxuICBub25jZVxufSkge1xuICBpZiAodHlwZW9mIHVybCA9PT0gXCJzdHJpbmdcIikge1xuICAgIHVybCA9IG5ldyBVUkwodXJsKTtcbiAgfVxuICBsZXQgeyBtYW5pZmVzdCwgcm91dGVNb2R1bGVzLCBjcml0aWNhbENzcywgc2VydmVySGFuZG9mZlN0cmluZyB9ID0gY29udGV4dDtcbiAgbGV0IHJvdXRlcyA9IGNyZWF0ZVNlcnZlclJvdXRlcyhcbiAgICBtYW5pZmVzdC5yb3V0ZXMsXG4gICAgcm91dGVNb2R1bGVzLFxuICAgIGNvbnRleHQuZnV0dXJlLFxuICAgIGNvbnRleHQuaXNTcGFNb2RlXG4gICk7XG4gIGNvbnRleHQuc3RhdGljSGFuZGxlckNvbnRleHQubG9hZGVyRGF0YSA9IHtcbiAgICAuLi5jb250ZXh0LnN0YXRpY0hhbmRsZXJDb250ZXh0LmxvYWRlckRhdGFcbiAgfTtcbiAgZm9yIChsZXQgbWF0Y2ggb2YgY29udGV4dC5zdGF0aWNIYW5kbGVyQ29udGV4dC5tYXRjaGVzKSB7XG4gICAgbGV0IHJvdXRlSWQgPSBtYXRjaC5yb3V0ZS5pZDtcbiAgICBsZXQgcm91dGUgPSByb3V0ZU1vZHVsZXNbcm91dGVJZF07XG4gICAgbGV0IG1hbmlmZXN0Um91dGUgPSBjb250ZXh0Lm1hbmlmZXN0LnJvdXRlc1tyb3V0ZUlkXTtcbiAgICBpZiAocm91dGUgJiYgbWFuaWZlc3RSb3V0ZSAmJiBzaG91bGRIeWRyYXRlUm91dGVMb2FkZXIobWFuaWZlc3RSb3V0ZSwgcm91dGUsIGNvbnRleHQuaXNTcGFNb2RlKSAmJiAocm91dGUuSHlkcmF0ZUZhbGxiYWNrIHx8ICFtYW5pZmVzdFJvdXRlLmhhc0xvYWRlcikpIHtcbiAgICAgIGRlbGV0ZSBjb250ZXh0LnN0YXRpY0hhbmRsZXJDb250ZXh0LmxvYWRlckRhdGFbcm91dGVJZF07XG4gICAgfVxuICB9XG4gIGxldCByb3V0ZXIgPSBjcmVhdGVTdGF0aWNSb3V0ZXIocm91dGVzLCBjb250ZXh0LnN0YXRpY0hhbmRsZXJDb250ZXh0KTtcbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBSZWFjdDEyLmNyZWF0ZUVsZW1lbnQoUmVhY3QxMi5GcmFnbWVudCwgbnVsbCwgLyogQF9fUFVSRV9fICovIFJlYWN0MTIuY3JlYXRlRWxlbWVudChcbiAgICBGcmFtZXdvcmtDb250ZXh0LlByb3ZpZGVyLFxuICAgIHtcbiAgICAgIHZhbHVlOiB7XG4gICAgICAgIG1hbmlmZXN0LFxuICAgICAgICByb3V0ZU1vZHVsZXMsXG4gICAgICAgIGNyaXRpY2FsQ3NzLFxuICAgICAgICBzZXJ2ZXJIYW5kb2ZmU3RyaW5nLFxuICAgICAgICBmdXR1cmU6IGNvbnRleHQuZnV0dXJlLFxuICAgICAgICBpc1NwYU1vZGU6IGNvbnRleHQuaXNTcGFNb2RlLFxuICAgICAgICBzZXJpYWxpemVFcnJvcjogY29udGV4dC5zZXJpYWxpemVFcnJvcixcbiAgICAgICAgcmVuZGVyTWV0YTogY29udGV4dC5yZW5kZXJNZXRhXG4gICAgICB9XG4gICAgfSxcbiAgICAvKiBAX19QVVJFX18gKi8gUmVhY3QxMi5jcmVhdGVFbGVtZW50KFJlbWl4RXJyb3JCb3VuZGFyeSwgeyBsb2NhdGlvbjogcm91dGVyLnN0YXRlLmxvY2F0aW9uIH0sIC8qIEBfX1BVUkVfXyAqLyBSZWFjdDEyLmNyZWF0ZUVsZW1lbnQoXG4gICAgICBTdGF0aWNSb3V0ZXJQcm92aWRlcixcbiAgICAgIHtcbiAgICAgICAgcm91dGVyLFxuICAgICAgICBjb250ZXh0OiBjb250ZXh0LnN0YXRpY0hhbmRsZXJDb250ZXh0LFxuICAgICAgICBoeWRyYXRlOiBmYWxzZVxuICAgICAgfVxuICAgICkpXG4gICksIGNvbnRleHQuc2VydmVySGFuZG9mZlN0cmVhbSA/IC8qIEBfX1BVUkVfXyAqLyBSZWFjdDEyLmNyZWF0ZUVsZW1lbnQoUmVhY3QxMi5TdXNwZW5zZSwgbnVsbCwgLyogQF9fUFVSRV9fICovIFJlYWN0MTIuY3JlYXRlRWxlbWVudChcbiAgICBTdHJlYW1UcmFuc2ZlcixcbiAgICB7XG4gICAgICBjb250ZXh0LFxuICAgICAgaWRlbnRpZmllcjogMCxcbiAgICAgIHJlYWRlcjogY29udGV4dC5zZXJ2ZXJIYW5kb2ZmU3RyZWFtLmdldFJlYWRlcigpLFxuICAgICAgdGV4dERlY29kZXI6IG5ldyBUZXh0RGVjb2RlcigpLFxuICAgICAgbm9uY2VcbiAgICB9XG4gICkpIDogbnVsbCk7XG59XG5cbi8vIGxpYi9kb20vc3NyL3JvdXRlcy10ZXN0LXN0dWIudHN4XG52YXIgUmVhY3QxMyA9IF9fdG9FU00ocmVxdWlyZShcInJlYWN0XCIpKTtcbmZ1bmN0aW9uIGNyZWF0ZVJvdXRlc1N0dWIocm91dGVzLCBjb250ZXh0ID0ge30pIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIFJvdXRlc1Rlc3RTdHViKHtcbiAgICBpbml0aWFsRW50cmllcyxcbiAgICBpbml0aWFsSW5kZXgsXG4gICAgaHlkcmF0aW9uRGF0YSxcbiAgICBmdXR1cmVcbiAgfSkge1xuICAgIGxldCByb3V0ZXJSZWYgPSBSZWFjdDEzLnVzZVJlZigpO1xuICAgIGxldCByZW1peENvbnRleHRSZWYgPSBSZWFjdDEzLnVzZVJlZigpO1xuICAgIGlmIChyb3V0ZXJSZWYuY3VycmVudCA9PSBudWxsKSB7XG4gICAgICByZW1peENvbnRleHRSZWYuY3VycmVudCA9IHtcbiAgICAgICAgZnV0dXJlOiB7fSxcbiAgICAgICAgbWFuaWZlc3Q6IHtcbiAgICAgICAgICByb3V0ZXM6IHt9LFxuICAgICAgICAgIGVudHJ5OiB7IGltcG9ydHM6IFtdLCBtb2R1bGU6IFwiXCIgfSxcbiAgICAgICAgICB1cmw6IFwiXCIsXG4gICAgICAgICAgdmVyc2lvbjogXCJcIlxuICAgICAgICB9LFxuICAgICAgICByb3V0ZU1vZHVsZXM6IHt9LFxuICAgICAgICBpc1NwYU1vZGU6IGZhbHNlXG4gICAgICB9O1xuICAgICAgbGV0IHBhdGNoZWQgPSBwcm9jZXNzUm91dGVzKFxuICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yIGxvYWRlci9hY3Rpb24gY29udGV4dCB0eXBlcyBkb24ndCBtYXRjaCA6L1xuICAgICAgICBjb252ZXJ0Um91dGVzVG9EYXRhUm91dGVzKHJvdXRlcywgKHIpID0+IHIpLFxuICAgICAgICBjb250ZXh0LFxuICAgICAgICByZW1peENvbnRleHRSZWYuY3VycmVudC5tYW5pZmVzdCxcbiAgICAgICAgcmVtaXhDb250ZXh0UmVmLmN1cnJlbnQucm91dGVNb2R1bGVzXG4gICAgICApO1xuICAgICAgcm91dGVyUmVmLmN1cnJlbnQgPSBjcmVhdGVNZW1vcnlSb3V0ZXIocGF0Y2hlZCwge1xuICAgICAgICBpbml0aWFsRW50cmllcyxcbiAgICAgICAgaW5pdGlhbEluZGV4LFxuICAgICAgICBoeWRyYXRpb25EYXRhXG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBSZWFjdDEzLmNyZWF0ZUVsZW1lbnQoRnJhbWV3b3JrQ29udGV4dC5Qcm92aWRlciwgeyB2YWx1ZTogcmVtaXhDb250ZXh0UmVmLmN1cnJlbnQgfSwgLyogQF9fUFVSRV9fICovIFJlYWN0MTMuY3JlYXRlRWxlbWVudChSb3V0ZXJQcm92aWRlciwgeyByb3V0ZXI6IHJvdXRlclJlZi5jdXJyZW50IH0pKTtcbiAgfTtcbn1cbmZ1bmN0aW9uIHByb2Nlc3NSb3V0ZXMocm91dGVzLCBjb250ZXh0LCBtYW5pZmVzdCwgcm91dGVNb2R1bGVzLCBwYXJlbnRJZCkge1xuICByZXR1cm4gcm91dGVzLm1hcCgocm91dGUpID0+IHtcbiAgICBpZiAoIXJvdXRlLmlkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIFwiRXhwZWN0ZWQgYSByb3V0ZS5pZCBpbiBAcmVtaXgtcnVuL3Rlc3RpbmcgcHJvY2Vzc1JvdXRlcygpIGZ1bmN0aW9uXCJcbiAgICAgICk7XG4gICAgfVxuICAgIGxldCB7IGxvYWRlciwgYWN0aW9uIH0gPSByb3V0ZTtcbiAgICBsZXQgbmV3Um91dGUgPSB7XG4gICAgICBpZDogcm91dGUuaWQsXG4gICAgICBwYXRoOiByb3V0ZS5wYXRoLFxuICAgICAgaW5kZXg6IHJvdXRlLmluZGV4LFxuICAgICAgQ29tcG9uZW50OiByb3V0ZS5Db21wb25lbnQsXG4gICAgICBIeWRyYXRlRmFsbGJhY2s6IHJvdXRlLkh5ZHJhdGVGYWxsYmFjayxcbiAgICAgIEVycm9yQm91bmRhcnk6IHJvdXRlLkVycm9yQm91bmRhcnksXG4gICAgICBhY3Rpb246IGFjdGlvbiA/IChhcmdzKSA9PiBhY3Rpb24oeyAuLi5hcmdzLCBjb250ZXh0IH0pIDogdm9pZCAwLFxuICAgICAgbG9hZGVyOiBsb2FkZXIgPyAoYXJncykgPT4gbG9hZGVyKHsgLi4uYXJncywgY29udGV4dCB9KSA6IHZvaWQgMCxcbiAgICAgIGhhbmRsZTogcm91dGUuaGFuZGxlLFxuICAgICAgc2hvdWxkUmV2YWxpZGF0ZTogcm91dGUuc2hvdWxkUmV2YWxpZGF0ZVxuICAgIH07XG4gICAgbGV0IGVudHJ5Um91dGUgPSB7XG4gICAgICBpZDogcm91dGUuaWQsXG4gICAgICBwYXRoOiByb3V0ZS5wYXRoLFxuICAgICAgaW5kZXg6IHJvdXRlLmluZGV4LFxuICAgICAgcGFyZW50SWQsXG4gICAgICBoYXNBY3Rpb246IHJvdXRlLmFjdGlvbiAhPSBudWxsLFxuICAgICAgaGFzTG9hZGVyOiByb3V0ZS5sb2FkZXIgIT0gbnVsbCxcbiAgICAgIC8vIFdoZW4gdGVzdGluZyByb3V0ZXMsIHlvdSBzaG91bGQganVzdCBiZSBzdHViYmluZyBsb2FkZXIvYWN0aW9uLCBub3RcbiAgICAgIC8vIHRyeWluZyB0byByZS1pbXBsZW1lbnQgdGhlIGZ1bGwgbG9hZGVyL2NsaWVudExvYWRlci9TU1IvaHlkcmF0aW9uIGZsb3cuXG4gICAgICAvLyBUaGF0IGlzIGJldHRlciB0ZXN0ZWQgdmlhIEUyRSB0ZXN0cy5cbiAgICAgIGhhc0NsaWVudEFjdGlvbjogZmFsc2UsXG4gICAgICBoYXNDbGllbnRMb2FkZXI6IGZhbHNlLFxuICAgICAgaGFzRXJyb3JCb3VuZGFyeTogcm91dGUuRXJyb3JCb3VuZGFyeSAhPSBudWxsLFxuICAgICAgbW9kdWxlOiBcImJ1aWxkL3N0dWItcGF0aC10by1tb2R1bGUuanNcIlxuICAgICAgLy8gYW55IG5lZWQgZm9yIHRoaXM/XG4gICAgfTtcbiAgICBtYW5pZmVzdC5yb3V0ZXNbbmV3Um91dGUuaWRdID0gZW50cnlSb3V0ZTtcbiAgICByb3V0ZU1vZHVsZXNbcm91dGUuaWRdID0ge1xuICAgICAgZGVmYXVsdDogcm91dGUuQ29tcG9uZW50IHx8IE91dGxldCxcbiAgICAgIEVycm9yQm91bmRhcnk6IHJvdXRlLkVycm9yQm91bmRhcnkgfHwgdm9pZCAwLFxuICAgICAgaGFuZGxlOiByb3V0ZS5oYW5kbGUsXG4gICAgICBsaW5rczogcm91dGUubGlua3MsXG4gICAgICBtZXRhOiByb3V0ZS5tZXRhLFxuICAgICAgc2hvdWxkUmV2YWxpZGF0ZTogcm91dGUuc2hvdWxkUmV2YWxpZGF0ZVxuICAgIH07XG4gICAgaWYgKHJvdXRlLmNoaWxkcmVuKSB7XG4gICAgICBuZXdSb3V0ZS5jaGlsZHJlbiA9IHByb2Nlc3NSb3V0ZXMoXG4gICAgICAgIHJvdXRlLmNoaWxkcmVuLFxuICAgICAgICBjb250ZXh0LFxuICAgICAgICBtYW5pZmVzdCxcbiAgICAgICAgcm91dGVNb2R1bGVzLFxuICAgICAgICBuZXdSb3V0ZS5pZFxuICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ld1JvdXRlO1xuICB9KTtcbn1cblxuLy8gbGliL3NlcnZlci1ydW50aW1lL2Nvb2tpZXMudHNcbnZhciBpbXBvcnRfY29va2llID0gcmVxdWlyZShcImNvb2tpZVwiKTtcblxuLy8gbGliL3NlcnZlci1ydW50aW1lL2NyeXB0by50c1xudmFyIGVuY29kZXIgPSBuZXcgVGV4dEVuY29kZXIoKTtcbnZhciBzaWduID0gYXN5bmMgKHZhbHVlLCBzZWNyZXQpID0+IHtcbiAgbGV0IGRhdGEyID0gZW5jb2Rlci5lbmNvZGUodmFsdWUpO1xuICBsZXQga2V5ID0gYXdhaXQgY3JlYXRlS2V5MihzZWNyZXQsIFtcInNpZ25cIl0pO1xuICBsZXQgc2lnbmF0dXJlID0gYXdhaXQgY3J5cHRvLnN1YnRsZS5zaWduKFwiSE1BQ1wiLCBrZXksIGRhdGEyKTtcbiAgbGV0IGhhc2ggPSBidG9hKFN0cmluZy5mcm9tQ2hhckNvZGUoLi4ubmV3IFVpbnQ4QXJyYXkoc2lnbmF0dXJlKSkpLnJlcGxhY2UoXG4gICAgLz0rJC8sXG4gICAgXCJcIlxuICApO1xuICByZXR1cm4gdmFsdWUgKyBcIi5cIiArIGhhc2g7XG59O1xudmFyIHVuc2lnbiA9IGFzeW5jIChjb29raWUsIHNlY3JldCkgPT4ge1xuICBsZXQgaW5kZXggPSBjb29raWUubGFzdEluZGV4T2YoXCIuXCIpO1xuICBsZXQgdmFsdWUgPSBjb29raWUuc2xpY2UoMCwgaW5kZXgpO1xuICBsZXQgaGFzaCA9IGNvb2tpZS5zbGljZShpbmRleCArIDEpO1xuICBsZXQgZGF0YTIgPSBlbmNvZGVyLmVuY29kZSh2YWx1ZSk7XG4gIGxldCBrZXkgPSBhd2FpdCBjcmVhdGVLZXkyKHNlY3JldCwgW1widmVyaWZ5XCJdKTtcbiAgbGV0IHNpZ25hdHVyZSA9IGJ5dGVTdHJpbmdUb1VpbnQ4QXJyYXkoYXRvYihoYXNoKSk7XG4gIGxldCB2YWxpZCA9IGF3YWl0IGNyeXB0by5zdWJ0bGUudmVyaWZ5KFwiSE1BQ1wiLCBrZXksIHNpZ25hdHVyZSwgZGF0YTIpO1xuICByZXR1cm4gdmFsaWQgPyB2YWx1ZSA6IGZhbHNlO1xufTtcbnZhciBjcmVhdGVLZXkyID0gYXN5bmMgKHNlY3JldCwgdXNhZ2VzKSA9PiBjcnlwdG8uc3VidGxlLmltcG9ydEtleShcbiAgXCJyYXdcIixcbiAgZW5jb2Rlci5lbmNvZGUoc2VjcmV0KSxcbiAgeyBuYW1lOiBcIkhNQUNcIiwgaGFzaDogXCJTSEEtMjU2XCIgfSxcbiAgZmFsc2UsXG4gIHVzYWdlc1xuKTtcbmZ1bmN0aW9uIGJ5dGVTdHJpbmdUb1VpbnQ4QXJyYXkoYnl0ZVN0cmluZykge1xuICBsZXQgYXJyYXkgPSBuZXcgVWludDhBcnJheShieXRlU3RyaW5nLmxlbmd0aCk7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgYnl0ZVN0cmluZy5sZW5ndGg7IGkrKykge1xuICAgIGFycmF5W2ldID0gYnl0ZVN0cmluZy5jaGFyQ29kZUF0KGkpO1xuICB9XG4gIHJldHVybiBhcnJheTtcbn1cblxuLy8gbGliL3NlcnZlci1ydW50aW1lL2Nvb2tpZXMudHNcbnZhciBjcmVhdGVDb29raWUgPSAobmFtZSwgY29va2llT3B0aW9ucyA9IHt9KSA9PiB7XG4gIGxldCB7IHNlY3JldHMgPSBbXSwgLi4ub3B0aW9ucyB9ID0ge1xuICAgIHBhdGg6IFwiL1wiLFxuICAgIHNhbWVTaXRlOiBcImxheFwiLFxuICAgIC4uLmNvb2tpZU9wdGlvbnNcbiAgfTtcbiAgd2Fybk9uY2VBYm91dEV4cGlyZXNDb29raWUobmFtZSwgb3B0aW9ucy5leHBpcmVzKTtcbiAgcmV0dXJuIHtcbiAgICBnZXQgbmFtZSgpIHtcbiAgICAgIHJldHVybiBuYW1lO1xuICAgIH0sXG4gICAgZ2V0IGlzU2lnbmVkKCkge1xuICAgICAgcmV0dXJuIHNlY3JldHMubGVuZ3RoID4gMDtcbiAgICB9LFxuICAgIGdldCBleHBpcmVzKCkge1xuICAgICAgcmV0dXJuIHR5cGVvZiBvcHRpb25zLm1heEFnZSAhPT0gXCJ1bmRlZmluZWRcIiA/IG5ldyBEYXRlKERhdGUubm93KCkgKyBvcHRpb25zLm1heEFnZSAqIDFlMykgOiBvcHRpb25zLmV4cGlyZXM7XG4gICAgfSxcbiAgICBhc3luYyBwYXJzZShjb29raWVIZWFkZXIsIHBhcnNlT3B0aW9ucykge1xuICAgICAgaWYgKCFjb29raWVIZWFkZXIpIHJldHVybiBudWxsO1xuICAgICAgbGV0IGNvb2tpZXMgPSAoMCwgaW1wb3J0X2Nvb2tpZS5wYXJzZSkoY29va2llSGVhZGVyLCB7IC4uLm9wdGlvbnMsIC4uLnBhcnNlT3B0aW9ucyB9KTtcbiAgICAgIGlmIChuYW1lIGluIGNvb2tpZXMpIHtcbiAgICAgICAgbGV0IHZhbHVlID0gY29va2llc1tuYW1lXTtcbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIiAmJiB2YWx1ZSAhPT0gXCJcIikge1xuICAgICAgICAgIGxldCBkZWNvZGVkID0gYXdhaXQgZGVjb2RlQ29va2llVmFsdWUodmFsdWUsIHNlY3JldHMpO1xuICAgICAgICAgIHJldHVybiBkZWNvZGVkO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBcIlwiO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICB9LFxuICAgIGFzeW5jIHNlcmlhbGl6ZSh2YWx1ZSwgc2VyaWFsaXplT3B0aW9ucykge1xuICAgICAgcmV0dXJuICgwLCBpbXBvcnRfY29va2llLnNlcmlhbGl6ZSkoXG4gICAgICAgIG5hbWUsXG4gICAgICAgIHZhbHVlID09PSBcIlwiID8gXCJcIiA6IGF3YWl0IGVuY29kZUNvb2tpZVZhbHVlKHZhbHVlLCBzZWNyZXRzKSxcbiAgICAgICAge1xuICAgICAgICAgIC4uLm9wdGlvbnMsXG4gICAgICAgICAgLi4uc2VyaWFsaXplT3B0aW9uc1xuICAgICAgICB9XG4gICAgICApO1xuICAgIH1cbiAgfTtcbn07XG52YXIgaXNDb29raWUgPSAob2JqZWN0KSA9PiB7XG4gIHJldHVybiBvYmplY3QgIT0gbnVsbCAmJiB0eXBlb2Ygb2JqZWN0Lm5hbWUgPT09IFwic3RyaW5nXCIgJiYgdHlwZW9mIG9iamVjdC5pc1NpZ25lZCA9PT0gXCJib29sZWFuXCIgJiYgdHlwZW9mIG9iamVjdC5wYXJzZSA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBvYmplY3Quc2VyaWFsaXplID09PSBcImZ1bmN0aW9uXCI7XG59O1xuYXN5bmMgZnVuY3Rpb24gZW5jb2RlQ29va2llVmFsdWUodmFsdWUsIHNlY3JldHMpIHtcbiAgbGV0IGVuY29kZWQgPSBlbmNvZGVEYXRhKHZhbHVlKTtcbiAgaWYgKHNlY3JldHMubGVuZ3RoID4gMCkge1xuICAgIGVuY29kZWQgPSBhd2FpdCBzaWduKGVuY29kZWQsIHNlY3JldHNbMF0pO1xuICB9XG4gIHJldHVybiBlbmNvZGVkO1xufVxuYXN5bmMgZnVuY3Rpb24gZGVjb2RlQ29va2llVmFsdWUodmFsdWUsIHNlY3JldHMpIHtcbiAgaWYgKHNlY3JldHMubGVuZ3RoID4gMCkge1xuICAgIGZvciAobGV0IHNlY3JldCBvZiBzZWNyZXRzKSB7XG4gICAgICBsZXQgdW5zaWduZWRWYWx1ZSA9IGF3YWl0IHVuc2lnbih2YWx1ZSwgc2VjcmV0KTtcbiAgICAgIGlmICh1bnNpZ25lZFZhbHVlICE9PSBmYWxzZSkge1xuICAgICAgICByZXR1cm4gZGVjb2RlRGF0YSh1bnNpZ25lZFZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgcmV0dXJuIGRlY29kZURhdGEodmFsdWUpO1xufVxuZnVuY3Rpb24gZW5jb2RlRGF0YSh2YWx1ZSkge1xuICByZXR1cm4gYnRvYShteVVuZXNjYXBlKGVuY29kZVVSSUNvbXBvbmVudChKU09OLnN0cmluZ2lmeSh2YWx1ZSkpKSk7XG59XG5mdW5jdGlvbiBkZWNvZGVEYXRhKHZhbHVlKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIEpTT04ucGFyc2UoZGVjb2RlVVJJQ29tcG9uZW50KG15RXNjYXBlKGF0b2IodmFsdWUpKSkpO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIHJldHVybiB7fTtcbiAgfVxufVxuZnVuY3Rpb24gbXlFc2NhcGUodmFsdWUpIHtcbiAgbGV0IHN0ciA9IHZhbHVlLnRvU3RyaW5nKCk7XG4gIGxldCByZXN1bHQgPSBcIlwiO1xuICBsZXQgaW5kZXggPSAwO1xuICBsZXQgY2hyLCBjb2RlO1xuICB3aGlsZSAoaW5kZXggPCBzdHIubGVuZ3RoKSB7XG4gICAgY2hyID0gc3RyLmNoYXJBdChpbmRleCsrKTtcbiAgICBpZiAoL1tcXHcqK1xcLS4vQF0vLmV4ZWMoY2hyKSkge1xuICAgICAgcmVzdWx0ICs9IGNocjtcbiAgICB9IGVsc2Uge1xuICAgICAgY29kZSA9IGNoci5jaGFyQ29kZUF0KDApO1xuICAgICAgaWYgKGNvZGUgPCAyNTYpIHtcbiAgICAgICAgcmVzdWx0ICs9IFwiJVwiICsgaGV4KGNvZGUsIDIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVzdWx0ICs9IFwiJXVcIiArIGhleChjb2RlLCA0KS50b1VwcGVyQ2FzZSgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gaGV4KGNvZGUsIGxlbmd0aCkge1xuICBsZXQgcmVzdWx0ID0gY29kZS50b1N0cmluZygxNik7XG4gIHdoaWxlIChyZXN1bHQubGVuZ3RoIDwgbGVuZ3RoKSByZXN1bHQgPSBcIjBcIiArIHJlc3VsdDtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIG15VW5lc2NhcGUodmFsdWUpIHtcbiAgbGV0IHN0ciA9IHZhbHVlLnRvU3RyaW5nKCk7XG4gIGxldCByZXN1bHQgPSBcIlwiO1xuICBsZXQgaW5kZXggPSAwO1xuICBsZXQgY2hyLCBwYXJ0O1xuICB3aGlsZSAoaW5kZXggPCBzdHIubGVuZ3RoKSB7XG4gICAgY2hyID0gc3RyLmNoYXJBdChpbmRleCsrKTtcbiAgICBpZiAoY2hyID09PSBcIiVcIikge1xuICAgICAgaWYgKHN0ci5jaGFyQXQoaW5kZXgpID09PSBcInVcIikge1xuICAgICAgICBwYXJ0ID0gc3RyLnNsaWNlKGluZGV4ICsgMSwgaW5kZXggKyA1KTtcbiAgICAgICAgaWYgKC9eW1xcZGEtZl17NH0kL2kuZXhlYyhwYXJ0KSkge1xuICAgICAgICAgIHJlc3VsdCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKHBhcnNlSW50KHBhcnQsIDE2KSk7XG4gICAgICAgICAgaW5kZXggKz0gNTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGFydCA9IHN0ci5zbGljZShpbmRleCwgaW5kZXggKyAyKTtcbiAgICAgICAgaWYgKC9eW1xcZGEtZl17Mn0kL2kuZXhlYyhwYXJ0KSkge1xuICAgICAgICAgIHJlc3VsdCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKHBhcnNlSW50KHBhcnQsIDE2KSk7XG4gICAgICAgICAgaW5kZXggKz0gMjtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXN1bHQgKz0gY2hyO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiB3YXJuT25jZUFib3V0RXhwaXJlc0Nvb2tpZShuYW1lLCBleHBpcmVzKSB7XG4gIHdhcm5PbmNlKFxuICAgICFleHBpcmVzLFxuICAgIGBUaGUgXCIke25hbWV9XCIgY29va2llIGhhcyBhbiBcImV4cGlyZXNcIiBwcm9wZXJ0eSBzZXQuIFRoaXMgd2lsbCBjYXVzZSB0aGUgZXhwaXJlcyB2YWx1ZSB0byBub3QgYmUgdXBkYXRlZCB3aGVuIHRoZSBzZXNzaW9uIGlzIGNvbW1pdHRlZC4gSW5zdGVhZCwgeW91IHNob3VsZCBzZXQgdGhlIGV4cGlyZXMgdmFsdWUgd2hlbiBzZXJpYWxpemluZyB0aGUgY29va2llLiBZb3UgY2FuIHVzZSBcXGBjb21taXRTZXNzaW9uKHNlc3Npb24sIHsgZXhwaXJlcyB9KVxcYCBpZiB1c2luZyBhIHNlc3Npb24gc3RvcmFnZSBvYmplY3QsIG9yIFxcYGNvb2tpZS5zZXJpYWxpemUoXCJ2YWx1ZVwiLCB7IGV4cGlyZXMgfSlcXGAgaWYgeW91J3JlIHVzaW5nIHRoZSBjb29raWUgZGlyZWN0bHkuYFxuICApO1xufVxuXG4vLyBsaWIvc2VydmVyLXJ1bnRpbWUvZW50cnkudHNcbmZ1bmN0aW9uIGNyZWF0ZUVudHJ5Um91dGVNb2R1bGVzKG1hbmlmZXN0KSB7XG4gIHJldHVybiBPYmplY3Qua2V5cyhtYW5pZmVzdCkucmVkdWNlKChtZW1vMiwgcm91dGVJZCkgPT4ge1xuICAgIGxldCByb3V0ZSA9IG1hbmlmZXN0W3JvdXRlSWRdO1xuICAgIGlmIChyb3V0ZSkge1xuICAgICAgbWVtbzJbcm91dGVJZF0gPSByb3V0ZS5tb2R1bGU7XG4gICAgfVxuICAgIHJldHVybiBtZW1vMjtcbiAgfSwge30pO1xufVxuXG4vLyBsaWIvc2VydmVyLXJ1bnRpbWUvbW9kZS50c1xudmFyIFNlcnZlck1vZGUgPSAvKiBAX19QVVJFX18gKi8gKChTZXJ2ZXJNb2RlMikgPT4ge1xuICBTZXJ2ZXJNb2RlMltcIkRldmVsb3BtZW50XCJdID0gXCJkZXZlbG9wbWVudFwiO1xuICBTZXJ2ZXJNb2RlMltcIlByb2R1Y3Rpb25cIl0gPSBcInByb2R1Y3Rpb25cIjtcbiAgU2VydmVyTW9kZTJbXCJUZXN0XCJdID0gXCJ0ZXN0XCI7XG4gIHJldHVybiBTZXJ2ZXJNb2RlMjtcbn0pKFNlcnZlck1vZGUgfHwge30pO1xuZnVuY3Rpb24gaXNTZXJ2ZXJNb2RlKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSA9PT0gXCJkZXZlbG9wbWVudFwiIC8qIERldmVsb3BtZW50ICovIHx8IHZhbHVlID09PSBcInByb2R1Y3Rpb25cIiAvKiBQcm9kdWN0aW9uICovIHx8IHZhbHVlID09PSBcInRlc3RcIiAvKiBUZXN0ICovO1xufVxuXG4vLyBsaWIvc2VydmVyLXJ1bnRpbWUvZXJyb3JzLnRzXG5mdW5jdGlvbiBzYW5pdGl6ZUVycm9yKGVycm9yLCBzZXJ2ZXJNb2RlKSB7XG4gIGlmIChlcnJvciBpbnN0YW5jZW9mIEVycm9yICYmIHNlcnZlck1vZGUgIT09IFwiZGV2ZWxvcG1lbnRcIiAvKiBEZXZlbG9wbWVudCAqLykge1xuICAgIGxldCBzYW5pdGl6ZWQgPSBuZXcgRXJyb3IoXCJVbmV4cGVjdGVkIFNlcnZlciBFcnJvclwiKTtcbiAgICBzYW5pdGl6ZWQuc3RhY2sgPSB2b2lkIDA7XG4gICAgcmV0dXJuIHNhbml0aXplZDtcbiAgfVxuICByZXR1cm4gZXJyb3I7XG59XG5mdW5jdGlvbiBzYW5pdGl6ZUVycm9ycyhlcnJvcnMsIHNlcnZlck1vZGUpIHtcbiAgcmV0dXJuIE9iamVjdC5lbnRyaWVzKGVycm9ycykucmVkdWNlKChhY2MsIFtyb3V0ZUlkLCBlcnJvcl0pID0+IHtcbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihhY2MsIHsgW3JvdXRlSWRdOiBzYW5pdGl6ZUVycm9yKGVycm9yLCBzZXJ2ZXJNb2RlKSB9KTtcbiAgfSwge30pO1xufVxuZnVuY3Rpb24gc2VyaWFsaXplRXJyb3IoZXJyb3IsIHNlcnZlck1vZGUpIHtcbiAgbGV0IHNhbml0aXplZCA9IHNhbml0aXplRXJyb3IoZXJyb3IsIHNlcnZlck1vZGUpO1xuICByZXR1cm4ge1xuICAgIG1lc3NhZ2U6IHNhbml0aXplZC5tZXNzYWdlLFxuICAgIHN0YWNrOiBzYW5pdGl6ZWQuc3RhY2tcbiAgfTtcbn1cbmZ1bmN0aW9uIHNlcmlhbGl6ZUVycm9yczIoZXJyb3JzLCBzZXJ2ZXJNb2RlKSB7XG4gIGlmICghZXJyb3JzKSByZXR1cm4gbnVsbDtcbiAgbGV0IGVudHJpZXMgPSBPYmplY3QuZW50cmllcyhlcnJvcnMpO1xuICBsZXQgc2VyaWFsaXplZCA9IHt9O1xuICBmb3IgKGxldCBba2V5LCB2YWxdIG9mIGVudHJpZXMpIHtcbiAgICBpZiAoaXNSb3V0ZUVycm9yUmVzcG9uc2UodmFsKSkge1xuICAgICAgc2VyaWFsaXplZFtrZXldID0geyAuLi52YWwsIF9fdHlwZTogXCJSb3V0ZUVycm9yUmVzcG9uc2VcIiB9O1xuICAgIH0gZWxzZSBpZiAodmFsIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgIGxldCBzYW5pdGl6ZWQgPSBzYW5pdGl6ZUVycm9yKHZhbCwgc2VydmVyTW9kZSk7XG4gICAgICBzZXJpYWxpemVkW2tleV0gPSB7XG4gICAgICAgIG1lc3NhZ2U6IHNhbml0aXplZC5tZXNzYWdlLFxuICAgICAgICBzdGFjazogc2FuaXRpemVkLnN0YWNrLFxuICAgICAgICBfX3R5cGU6IFwiRXJyb3JcIixcbiAgICAgICAgLy8gSWYgdGhpcyBpcyBhIHN1YmNsYXNzIChpLmUuLCBSZWZlcmVuY2VFcnJvciksIHNlbmQgdXAgdGhlIHR5cGUgc28gd2VcbiAgICAgICAgLy8gY2FuIHJlLWNyZWF0ZSB0aGUgc2FtZSB0eXBlIGR1cmluZyBoeWRyYXRpb24uICBUaGlzIHdpbGwgb25seSBhcHBseVxuICAgICAgICAvLyBpbiBkZXYgbW9kZSBzaW5jZSBhbGwgcHJvZHVjdGlvbiBlcnJvcnMgYXJlIHNhbml0aXplZCB0byBub3JtYWxcbiAgICAgICAgLy8gRXJyb3IgaW5zdGFuY2VzXG4gICAgICAgIC4uLnNhbml0aXplZC5uYW1lICE9PSBcIkVycm9yXCIgPyB7XG4gICAgICAgICAgX19zdWJUeXBlOiBzYW5pdGl6ZWQubmFtZVxuICAgICAgICB9IDoge31cbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIHNlcmlhbGl6ZWRba2V5XSA9IHZhbDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHNlcmlhbGl6ZWQ7XG59XG5cbi8vIGxpYi9zZXJ2ZXItcnVudGltZS9yb3V0ZU1hdGNoaW5nLnRzXG5mdW5jdGlvbiBtYXRjaFNlcnZlclJvdXRlcyhyb3V0ZXMsIHBhdGhuYW1lLCBiYXNlbmFtZSkge1xuICBsZXQgbWF0Y2hlcyA9IG1hdGNoUm91dGVzKFxuICAgIHJvdXRlcyxcbiAgICBwYXRobmFtZSxcbiAgICBiYXNlbmFtZVxuICApO1xuICBpZiAoIW1hdGNoZXMpIHJldHVybiBudWxsO1xuICByZXR1cm4gbWF0Y2hlcy5tYXAoKG1hdGNoKSA9PiAoe1xuICAgIHBhcmFtczogbWF0Y2gucGFyYW1zLFxuICAgIHBhdGhuYW1lOiBtYXRjaC5wYXRobmFtZSxcbiAgICByb3V0ZTogbWF0Y2gucm91dGVcbiAgfSkpO1xufVxuXG4vLyBsaWIvc2VydmVyLXJ1bnRpbWUvZGF0YS50c1xuYXN5bmMgZnVuY3Rpb24gY2FsbFJvdXRlSGFuZGxlcihoYW5kbGVyLCBhcmdzKSB7XG4gIGxldCByZXN1bHQgPSBhd2FpdCBoYW5kbGVyKHtcbiAgICByZXF1ZXN0OiBzdHJpcFJvdXRlc1BhcmFtKHN0cmlwSW5kZXhQYXJhbTIoYXJncy5yZXF1ZXN0KSksXG4gICAgcGFyYW1zOiBhcmdzLnBhcmFtcyxcbiAgICBjb250ZXh0OiBhcmdzLmNvbnRleHRcbiAgfSk7XG4gIGlmIChpc0RhdGFXaXRoUmVzcG9uc2VJbml0KHJlc3VsdCkgJiYgcmVzdWx0LmluaXQgJiYgcmVzdWx0LmluaXQuc3RhdHVzICYmIGlzUmVkaXJlY3RTdGF0dXNDb2RlKHJlc3VsdC5pbml0LnN0YXR1cykpIHtcbiAgICB0aHJvdyBuZXcgUmVzcG9uc2UobnVsbCwgcmVzdWx0LmluaXQpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBzdHJpcEluZGV4UGFyYW0yKHJlcXVlc3QpIHtcbiAgbGV0IHVybCA9IG5ldyBVUkwocmVxdWVzdC51cmwpO1xuICBsZXQgaW5kZXhWYWx1ZXMgPSB1cmwuc2VhcmNoUGFyYW1zLmdldEFsbChcImluZGV4XCIpO1xuICB1cmwuc2VhcmNoUGFyYW1zLmRlbGV0ZShcImluZGV4XCIpO1xuICBsZXQgaW5kZXhWYWx1ZXNUb0tlZXAgPSBbXTtcbiAgZm9yIChsZXQgaW5kZXhWYWx1ZSBvZiBpbmRleFZhbHVlcykge1xuICAgIGlmIChpbmRleFZhbHVlKSB7XG4gICAgICBpbmRleFZhbHVlc1RvS2VlcC5wdXNoKGluZGV4VmFsdWUpO1xuICAgIH1cbiAgfVxuICBmb3IgKGxldCB0b0tlZXAgb2YgaW5kZXhWYWx1ZXNUb0tlZXApIHtcbiAgICB1cmwuc2VhcmNoUGFyYW1zLmFwcGVuZChcImluZGV4XCIsIHRvS2VlcCk7XG4gIH1cbiAgbGV0IGluaXQgPSB7XG4gICAgbWV0aG9kOiByZXF1ZXN0Lm1ldGhvZCxcbiAgICBib2R5OiByZXF1ZXN0LmJvZHksXG4gICAgaGVhZGVyczogcmVxdWVzdC5oZWFkZXJzLFxuICAgIHNpZ25hbDogcmVxdWVzdC5zaWduYWxcbiAgfTtcbiAgaWYgKGluaXQuYm9keSkge1xuICAgIGluaXQuZHVwbGV4ID0gXCJoYWxmXCI7XG4gIH1cbiAgcmV0dXJuIG5ldyBSZXF1ZXN0KHVybC5ocmVmLCBpbml0KTtcbn1cbmZ1bmN0aW9uIHN0cmlwUm91dGVzUGFyYW0ocmVxdWVzdCkge1xuICBsZXQgdXJsID0gbmV3IFVSTChyZXF1ZXN0LnVybCk7XG4gIHVybC5zZWFyY2hQYXJhbXMuZGVsZXRlKFwiX3JvdXRlc1wiKTtcbiAgbGV0IGluaXQgPSB7XG4gICAgbWV0aG9kOiByZXF1ZXN0Lm1ldGhvZCxcbiAgICBib2R5OiByZXF1ZXN0LmJvZHksXG4gICAgaGVhZGVyczogcmVxdWVzdC5oZWFkZXJzLFxuICAgIHNpZ25hbDogcmVxdWVzdC5zaWduYWxcbiAgfTtcbiAgaWYgKGluaXQuYm9keSkge1xuICAgIGluaXQuZHVwbGV4ID0gXCJoYWxmXCI7XG4gIH1cbiAgcmV0dXJuIG5ldyBSZXF1ZXN0KHVybC5ocmVmLCBpbml0KTtcbn1cblxuLy8gbGliL3NlcnZlci1ydW50aW1lL2ludmFyaWFudC50c1xuZnVuY3Rpb24gaW52YXJpYW50Myh2YWx1ZSwgbWVzc2FnZSkge1xuICBpZiAodmFsdWUgPT09IGZhbHNlIHx8IHZhbHVlID09PSBudWxsIHx8IHR5cGVvZiB2YWx1ZSA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICBcIlRoZSBmb2xsb3dpbmcgZXJyb3IgaXMgYSBidWcgaW4gUmVhY3QgUm91dGVyOyBwbGVhc2Ugb3BlbiBhbiBpc3N1ZSEgaHR0cHM6Ly9naXRodWIuY29tL3JlbWl4LXJ1bi9yZWFjdC1yb3V0ZXIvaXNzdWVzL25ldy9jaG9vc2VcIlxuICAgICk7XG4gICAgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UpO1xuICB9XG59XG5cbi8vIGxpYi9zZXJ2ZXItcnVudGltZS9yb3V0ZXMudHNcbmZ1bmN0aW9uIGdyb3VwUm91dGVzQnlQYXJlbnRJZDIobWFuaWZlc3QpIHtcbiAgbGV0IHJvdXRlcyA9IHt9O1xuICBPYmplY3QudmFsdWVzKG1hbmlmZXN0KS5mb3JFYWNoKChyb3V0ZSkgPT4ge1xuICAgIGlmIChyb3V0ZSkge1xuICAgICAgbGV0IHBhcmVudElkID0gcm91dGUucGFyZW50SWQgfHwgXCJcIjtcbiAgICAgIGlmICghcm91dGVzW3BhcmVudElkXSkge1xuICAgICAgICByb3V0ZXNbcGFyZW50SWRdID0gW107XG4gICAgICB9XG4gICAgICByb3V0ZXNbcGFyZW50SWRdLnB1c2gocm91dGUpO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiByb3V0ZXM7XG59XG5mdW5jdGlvbiBjcmVhdGVSb3V0ZXMobWFuaWZlc3QsIHBhcmVudElkID0gXCJcIiwgcm91dGVzQnlQYXJlbnRJZCA9IGdyb3VwUm91dGVzQnlQYXJlbnRJZDIobWFuaWZlc3QpKSB7XG4gIHJldHVybiAocm91dGVzQnlQYXJlbnRJZFtwYXJlbnRJZF0gfHwgW10pLm1hcCgocm91dGUpID0+ICh7XG4gICAgLi4ucm91dGUsXG4gICAgY2hpbGRyZW46IGNyZWF0ZVJvdXRlcyhtYW5pZmVzdCwgcm91dGUuaWQsIHJvdXRlc0J5UGFyZW50SWQpXG4gIH0pKTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVN0YXRpY0hhbmRsZXJEYXRhUm91dGVzKG1hbmlmZXN0LCBmdXR1cmUsIHBhcmVudElkID0gXCJcIiwgcm91dGVzQnlQYXJlbnRJZCA9IGdyb3VwUm91dGVzQnlQYXJlbnRJZDIobWFuaWZlc3QpKSB7XG4gIHJldHVybiAocm91dGVzQnlQYXJlbnRJZFtwYXJlbnRJZF0gfHwgW10pLm1hcCgocm91dGUpID0+IHtcbiAgICBsZXQgY29tbW9uUm91dGUgPSB7XG4gICAgICAvLyBBbHdheXMgaW5jbHVkZSByb290IGR1ZSB0byBkZWZhdWx0IGJvdW5kYXJpZXNcbiAgICAgIGhhc0Vycm9yQm91bmRhcnk6IHJvdXRlLmlkID09PSBcInJvb3RcIiB8fCByb3V0ZS5tb2R1bGUuRXJyb3JCb3VuZGFyeSAhPSBudWxsLFxuICAgICAgaWQ6IHJvdXRlLmlkLFxuICAgICAgcGF0aDogcm91dGUucGF0aCxcbiAgICAgIC8vIE5lZWQgdG8gdXNlIFJSJ3MgdmVyc2lvbiBpbiB0aGUgcGFyYW0gdHlwZWQgaGVyZSB0byBwZXJtaXQgdGhlIG9wdGlvbmFsXG4gICAgICAvLyBjb250ZXh0IGV2ZW4gdGhvdWdoIHdlIGtub3cgaXQnbGwgYWx3YXlzIGJlIHByb3ZpZGVkIGluIHJlbWl4XG4gICAgICBsb2FkZXI6IHJvdXRlLm1vZHVsZS5sb2FkZXIgPyBhc3luYyAoYXJncykgPT4ge1xuICAgICAgICBpZiAoYXJncy5yZXF1ZXN0LmhlYWRlcnMuaGFzKFwiWC1SZWFjdC1Sb3V0ZXItUHJlcmVuZGVyLURhdGFcIikpIHtcbiAgICAgICAgICBjb25zdCBwcmVSZW5kZXJlZERhdGEgPSBhcmdzLnJlcXVlc3QuaGVhZGVycy5nZXQoXG4gICAgICAgICAgICBcIlgtUmVhY3QtUm91dGVyLVByZXJlbmRlci1EYXRhXCJcbiAgICAgICAgICApO1xuICAgICAgICAgIGxldCBlbmNvZGVkID0gcHJlUmVuZGVyZWREYXRhID8gZGVjb2RlVVJJKHByZVJlbmRlcmVkRGF0YSkgOiBwcmVSZW5kZXJlZERhdGE7XG4gICAgICAgICAgaW52YXJpYW50MyhlbmNvZGVkLCBcIk1pc3NpbmcgcHJlcmVuZGVyZWQgZGF0YSBmb3Igcm91dGVcIik7XG4gICAgICAgICAgbGV0IHVpbnQ4YXJyYXkgPSBuZXcgVGV4dEVuY29kZXIoKS5lbmNvZGUoZW5jb2RlZCk7XG4gICAgICAgICAgbGV0IHN0cmVhbSA9IG5ldyBSZWFkYWJsZVN0cmVhbSh7XG4gICAgICAgICAgICBzdGFydChjb250cm9sbGVyKSB7XG4gICAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZSh1aW50OGFycmF5KTtcbiAgICAgICAgICAgICAgY29udHJvbGxlci5jbG9zZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGxldCBkZWNvZGVkID0gYXdhaXQgZGVjb2RlVmlhVHVyYm9TdHJlYW0oc3RyZWFtLCBnbG9iYWwpO1xuICAgICAgICAgIGxldCBkYXRhMiA9IGRlY29kZWQudmFsdWU7XG4gICAgICAgICAgaW52YXJpYW50MyhcbiAgICAgICAgICAgIGRhdGEyICYmIHJvdXRlLmlkIGluIGRhdGEyLFxuICAgICAgICAgICAgXCJVbmFibGUgdG8gZGVjb2RlIHByZXJlbmRlcmVkIGRhdGFcIlxuICAgICAgICAgICk7XG4gICAgICAgICAgbGV0IHJlc3VsdCA9IGRhdGEyW3JvdXRlLmlkXTtcbiAgICAgICAgICBpbnZhcmlhbnQzKFwiZGF0YVwiIGluIHJlc3VsdCwgXCJVbmFibGUgdG8gcHJvY2VzcyBwcmVyZW5kZXJlZCBkYXRhXCIpO1xuICAgICAgICAgIHJldHVybiByZXN1bHQuZGF0YTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgdmFsID0gYXdhaXQgY2FsbFJvdXRlSGFuZGxlcihyb3V0ZS5tb2R1bGUubG9hZGVyLCBhcmdzKTtcbiAgICAgICAgcmV0dXJuIHZhbDtcbiAgICAgIH0gOiB2b2lkIDAsXG4gICAgICBhY3Rpb246IHJvdXRlLm1vZHVsZS5hY3Rpb24gPyAoYXJncykgPT4gY2FsbFJvdXRlSGFuZGxlcihyb3V0ZS5tb2R1bGUuYWN0aW9uLCBhcmdzKSA6IHZvaWQgMCxcbiAgICAgIGhhbmRsZTogcm91dGUubW9kdWxlLmhhbmRsZVxuICAgIH07XG4gICAgcmV0dXJuIHJvdXRlLmluZGV4ID8ge1xuICAgICAgaW5kZXg6IHRydWUsXG4gICAgICAuLi5jb21tb25Sb3V0ZVxuICAgIH0gOiB7XG4gICAgICBjYXNlU2Vuc2l0aXZlOiByb3V0ZS5jYXNlU2Vuc2l0aXZlLFxuICAgICAgY2hpbGRyZW46IGNyZWF0ZVN0YXRpY0hhbmRsZXJEYXRhUm91dGVzKFxuICAgICAgICBtYW5pZmVzdCxcbiAgICAgICAgZnV0dXJlLFxuICAgICAgICByb3V0ZS5pZCxcbiAgICAgICAgcm91dGVzQnlQYXJlbnRJZFxuICAgICAgKSxcbiAgICAgIC4uLmNvbW1vblJvdXRlXG4gICAgfTtcbiAgfSk7XG59XG5cbi8vIGxpYi9zZXJ2ZXItcnVudGltZS9tYXJrdXAudHNcbnZhciBFU0NBUEVfTE9PS1VQMyA9IHtcbiAgXCImXCI6IFwiXFxcXHUwMDI2XCIsXG4gIFwiPlwiOiBcIlxcXFx1MDAzZVwiLFxuICBcIjxcIjogXCJcXFxcdTAwM2NcIixcbiAgXCJcXHUyMDI4XCI6IFwiXFxcXHUyMDI4XCIsXG4gIFwiXFx1MjAyOVwiOiBcIlxcXFx1MjAyOVwiXG59O1xudmFyIEVTQ0FQRV9SRUdFWDMgPSAvWyY+PFxcdTIwMjhcXHUyMDI5XS9nO1xuZnVuY3Rpb24gZXNjYXBlSHRtbDIoaHRtbCkge1xuICByZXR1cm4gaHRtbC5yZXBsYWNlKEVTQ0FQRV9SRUdFWDMsIChtYXRjaCkgPT4gRVNDQVBFX0xPT0tVUDNbbWF0Y2hdKTtcbn1cblxuLy8gbGliL3NlcnZlci1ydW50aW1lL3NlcnZlckhhbmRvZmYudHNcbmZ1bmN0aW9uIGNyZWF0ZVNlcnZlckhhbmRvZmZTdHJpbmcoc2VydmVySGFuZG9mZikge1xuICByZXR1cm4gZXNjYXBlSHRtbDIoSlNPTi5zdHJpbmdpZnkoc2VydmVySGFuZG9mZikpO1xufVxuXG4vLyBsaWIvc2VydmVyLXJ1bnRpbWUvZGV2LnRzXG52YXIgZ2xvYmFsRGV2U2VydmVySG9va3NLZXkgPSBcIl9fcmVhY3RSb3V0ZXJEZXZTZXJ2ZXJIb29rc1wiO1xuZnVuY3Rpb24gc2V0RGV2U2VydmVySG9va3MoZGV2U2VydmVySG9va3MpIHtcbiAgZ2xvYmFsVGhpc1tnbG9iYWxEZXZTZXJ2ZXJIb29rc0tleV0gPSBkZXZTZXJ2ZXJIb29rcztcbn1cbmZ1bmN0aW9uIGdldERldlNlcnZlckhvb2tzKCkge1xuICByZXR1cm4gZ2xvYmFsVGhpc1tnbG9iYWxEZXZTZXJ2ZXJIb29rc0tleV07XG59XG5cbi8vIGxpYi9zZXJ2ZXItcnVudGltZS9zaW5nbGUtZmV0Y2gudHNcbnZhciBpbXBvcnRfdHVyYm9fc3RyZWFtMiA9IHJlcXVpcmUoXCJ0dXJiby1zdHJlYW1cIik7XG5cbi8vIGxpYi9zZXJ2ZXItcnVudGltZS9oZWFkZXJzLnRzXG52YXIgaW1wb3J0X3NldF9jb29raWVfcGFyc2VyID0gcmVxdWlyZShcInNldC1jb29raWUtcGFyc2VyXCIpO1xuZnVuY3Rpb24gZ2V0RG9jdW1lbnRIZWFkZXJzKGJ1aWxkLCBjb250ZXh0KSB7XG4gIGxldCBib3VuZGFyeUlkeCA9IGNvbnRleHQuZXJyb3JzID8gY29udGV4dC5tYXRjaGVzLmZpbmRJbmRleCgobSkgPT4gY29udGV4dC5lcnJvcnNbbS5yb3V0ZS5pZF0pIDogLTE7XG4gIGxldCBtYXRjaGVzID0gYm91bmRhcnlJZHggPj0gMCA/IGNvbnRleHQubWF0Y2hlcy5zbGljZSgwLCBib3VuZGFyeUlkeCArIDEpIDogY29udGV4dC5tYXRjaGVzO1xuICBsZXQgZXJyb3JIZWFkZXJzO1xuICBpZiAoYm91bmRhcnlJZHggPj0gMCkge1xuICAgIGxldCB7IGFjdGlvbkhlYWRlcnMsIGFjdGlvbkRhdGEsIGxvYWRlckhlYWRlcnMsIGxvYWRlckRhdGEgfSA9IGNvbnRleHQ7XG4gICAgY29udGV4dC5tYXRjaGVzLnNsaWNlKGJvdW5kYXJ5SWR4KS5zb21lKChtYXRjaCkgPT4ge1xuICAgICAgbGV0IGlkID0gbWF0Y2gucm91dGUuaWQ7XG4gICAgICBpZiAoYWN0aW9uSGVhZGVyc1tpZF0gJiYgKCFhY3Rpb25EYXRhIHx8ICFhY3Rpb25EYXRhLmhhc093blByb3BlcnR5KGlkKSkpIHtcbiAgICAgICAgZXJyb3JIZWFkZXJzID0gYWN0aW9uSGVhZGVyc1tpZF07XG4gICAgICB9IGVsc2UgaWYgKGxvYWRlckhlYWRlcnNbaWRdICYmICFsb2FkZXJEYXRhLmhhc093blByb3BlcnR5KGlkKSkge1xuICAgICAgICBlcnJvckhlYWRlcnMgPSBsb2FkZXJIZWFkZXJzW2lkXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBlcnJvckhlYWRlcnMgIT0gbnVsbDtcbiAgICB9KTtcbiAgfVxuICByZXR1cm4gbWF0Y2hlcy5yZWR1Y2UoKHBhcmVudEhlYWRlcnMsIG1hdGNoLCBpZHgpID0+IHtcbiAgICBsZXQgeyBpZCB9ID0gbWF0Y2gucm91dGU7XG4gICAgbGV0IHJvdXRlID0gYnVpbGQucm91dGVzW2lkXTtcbiAgICBpbnZhcmlhbnQzKHJvdXRlLCBgUm91dGUgd2l0aCBpZCBcIiR7aWR9XCIgbm90IGZvdW5kIGluIGJ1aWxkYCk7XG4gICAgbGV0IHJvdXRlTW9kdWxlID0gcm91dGUubW9kdWxlO1xuICAgIGxldCBsb2FkZXJIZWFkZXJzID0gY29udGV4dC5sb2FkZXJIZWFkZXJzW2lkXSB8fCBuZXcgSGVhZGVycygpO1xuICAgIGxldCBhY3Rpb25IZWFkZXJzID0gY29udGV4dC5hY3Rpb25IZWFkZXJzW2lkXSB8fCBuZXcgSGVhZGVycygpO1xuICAgIGxldCBpbmNsdWRlRXJyb3JIZWFkZXJzID0gZXJyb3JIZWFkZXJzICE9IG51bGwgJiYgaWR4ID09PSBtYXRjaGVzLmxlbmd0aCAtIDE7XG4gICAgbGV0IGluY2x1ZGVFcnJvckNvb2tpZXMgPSBpbmNsdWRlRXJyb3JIZWFkZXJzICYmIGVycm9ySGVhZGVycyAhPT0gbG9hZGVySGVhZGVycyAmJiBlcnJvckhlYWRlcnMgIT09IGFjdGlvbkhlYWRlcnM7XG4gICAgaWYgKHJvdXRlTW9kdWxlLmhlYWRlcnMgPT0gbnVsbCkge1xuICAgICAgbGV0IGhlYWRlcnMyID0gbmV3IEhlYWRlcnMocGFyZW50SGVhZGVycyk7XG4gICAgICBpZiAoaW5jbHVkZUVycm9yQ29va2llcykge1xuICAgICAgICBwcmVwZW5kQ29va2llcyhlcnJvckhlYWRlcnMsIGhlYWRlcnMyKTtcbiAgICAgIH1cbiAgICAgIHByZXBlbmRDb29raWVzKGFjdGlvbkhlYWRlcnMsIGhlYWRlcnMyKTtcbiAgICAgIHByZXBlbmRDb29raWVzKGxvYWRlckhlYWRlcnMsIGhlYWRlcnMyKTtcbiAgICAgIHJldHVybiBoZWFkZXJzMjtcbiAgICB9XG4gICAgbGV0IGhlYWRlcnMgPSBuZXcgSGVhZGVycyhcbiAgICAgIHJvdXRlTW9kdWxlLmhlYWRlcnMgPyB0eXBlb2Ygcm91dGVNb2R1bGUuaGVhZGVycyA9PT0gXCJmdW5jdGlvblwiID8gcm91dGVNb2R1bGUuaGVhZGVycyh7XG4gICAgICAgIGxvYWRlckhlYWRlcnMsXG4gICAgICAgIHBhcmVudEhlYWRlcnMsXG4gICAgICAgIGFjdGlvbkhlYWRlcnMsXG4gICAgICAgIGVycm9ySGVhZGVyczogaW5jbHVkZUVycm9ySGVhZGVycyA/IGVycm9ySGVhZGVycyA6IHZvaWQgMFxuICAgICAgfSkgOiByb3V0ZU1vZHVsZS5oZWFkZXJzIDogdm9pZCAwXG4gICAgKTtcbiAgICBpZiAoaW5jbHVkZUVycm9yQ29va2llcykge1xuICAgICAgcHJlcGVuZENvb2tpZXMoZXJyb3JIZWFkZXJzLCBoZWFkZXJzKTtcbiAgICB9XG4gICAgcHJlcGVuZENvb2tpZXMoYWN0aW9uSGVhZGVycywgaGVhZGVycyk7XG4gICAgcHJlcGVuZENvb2tpZXMobG9hZGVySGVhZGVycywgaGVhZGVycyk7XG4gICAgcHJlcGVuZENvb2tpZXMocGFyZW50SGVhZGVycywgaGVhZGVycyk7XG4gICAgcmV0dXJuIGhlYWRlcnM7XG4gIH0sIG5ldyBIZWFkZXJzKCkpO1xufVxuZnVuY3Rpb24gcHJlcGVuZENvb2tpZXMocGFyZW50SGVhZGVycywgY2hpbGRIZWFkZXJzKSB7XG4gIGxldCBwYXJlbnRTZXRDb29raWVTdHJpbmcgPSBwYXJlbnRIZWFkZXJzLmdldChcIlNldC1Db29raWVcIik7XG4gIGlmIChwYXJlbnRTZXRDb29raWVTdHJpbmcpIHtcbiAgICBsZXQgY29va2llcyA9ICgwLCBpbXBvcnRfc2V0X2Nvb2tpZV9wYXJzZXIuc3BsaXRDb29raWVzU3RyaW5nKShwYXJlbnRTZXRDb29raWVTdHJpbmcpO1xuICAgIGNvb2tpZXMuZm9yRWFjaCgoY29va2llKSA9PiB7XG4gICAgICBjaGlsZEhlYWRlcnMuYXBwZW5kKFwiU2V0LUNvb2tpZVwiLCBjb29raWUpO1xuICAgIH0pO1xuICB9XG59XG5cbi8vIGxpYi9zZXJ2ZXItcnVudGltZS9zaW5nbGUtZmV0Y2gudHNcbnZhciBTSU5HTEVfRkVUQ0hfUkVESVJFQ1RfU1RBVFVTID0gMjAyO1xuZnVuY3Rpb24gZ2V0U2luZ2xlRmV0Y2hEYXRhU3RyYXRlZ3kyKHtcbiAgaXNBY3Rpb25EYXRhUmVxdWVzdCxcbiAgbG9hZFJvdXRlSWRzXG59ID0ge30pIHtcbiAgcmV0dXJuIGFzeW5jICh7IHJlcXVlc3QsIG1hdGNoZXMgfSkgPT4ge1xuICAgIGlmIChpc0FjdGlvbkRhdGFSZXF1ZXN0ICYmIHJlcXVlc3QubWV0aG9kID09PSBcIkdFVFwiKSB7XG4gICAgICByZXR1cm4ge307XG4gICAgfVxuICAgIGxldCBtYXRjaGVzVG9Mb2FkID0gbG9hZFJvdXRlSWRzID8gbWF0Y2hlcy5maWx0ZXIoKG0pID0+IGxvYWRSb3V0ZUlkcy5pbmNsdWRlcyhtLnJvdXRlLmlkKSkgOiBtYXRjaGVzO1xuICAgIGxldCByZXN1bHRzID0gYXdhaXQgUHJvbWlzZS5hbGwoXG4gICAgICBtYXRjaGVzVG9Mb2FkLm1hcCgobWF0Y2gpID0+IG1hdGNoLnJlc29sdmUoKSlcbiAgICApO1xuICAgIHJldHVybiByZXN1bHRzLnJlZHVjZShcbiAgICAgIChhY2MsIHJlc3VsdCwgaSkgPT4gT2JqZWN0LmFzc2lnbihhY2MsIHsgW21hdGNoZXNUb0xvYWRbaV0ucm91dGUuaWRdOiByZXN1bHQgfSksXG4gICAgICB7fVxuICAgICk7XG4gIH07XG59XG5hc3luYyBmdW5jdGlvbiBzaW5nbGVGZXRjaEFjdGlvbihidWlsZCwgc2VydmVyTW9kZSwgc3RhdGljSGFuZGxlciwgcmVxdWVzdCwgaGFuZGxlclVybCwgbG9hZENvbnRleHQsIGhhbmRsZUVycm9yKSB7XG4gIHRyeSB7XG4gICAgbGV0IGhhbmRsZXJSZXF1ZXN0ID0gbmV3IFJlcXVlc3QoaGFuZGxlclVybCwge1xuICAgICAgbWV0aG9kOiByZXF1ZXN0Lm1ldGhvZCxcbiAgICAgIGJvZHk6IHJlcXVlc3QuYm9keSxcbiAgICAgIGhlYWRlcnM6IHJlcXVlc3QuaGVhZGVycyxcbiAgICAgIHNpZ25hbDogcmVxdWVzdC5zaWduYWwsXG4gICAgICAuLi5yZXF1ZXN0LmJvZHkgPyB7IGR1cGxleDogXCJoYWxmXCIgfSA6IHZvaWQgMFxuICAgIH0pO1xuICAgIGxldCByZXN1bHQgPSBhd2FpdCBzdGF0aWNIYW5kbGVyLnF1ZXJ5KGhhbmRsZXJSZXF1ZXN0LCB7XG4gICAgICByZXF1ZXN0Q29udGV4dDogbG9hZENvbnRleHQsXG4gICAgICBza2lwTG9hZGVyRXJyb3JCdWJibGluZzogdHJ1ZSxcbiAgICAgIGRhdGFTdHJhdGVneTogZ2V0U2luZ2xlRmV0Y2hEYXRhU3RyYXRlZ3kyKHtcbiAgICAgICAgaXNBY3Rpb25EYXRhUmVxdWVzdDogdHJ1ZVxuICAgICAgfSlcbiAgICB9KTtcbiAgICBpZiAoaXNSZXNwb25zZShyZXN1bHQpKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICByZXN1bHQ6IGdldFNpbmdsZUZldGNoUmVkaXJlY3QoXG4gICAgICAgICAgcmVzdWx0LnN0YXR1cyxcbiAgICAgICAgICByZXN1bHQuaGVhZGVycyxcbiAgICAgICAgICBidWlsZC5iYXNlbmFtZVxuICAgICAgICApLFxuICAgICAgICBoZWFkZXJzOiByZXN1bHQuaGVhZGVycyxcbiAgICAgICAgc3RhdHVzOiBTSU5HTEVfRkVUQ0hfUkVESVJFQ1RfU1RBVFVTXG4gICAgICB9O1xuICAgIH1cbiAgICBsZXQgY29udGV4dCA9IHJlc3VsdDtcbiAgICBsZXQgaGVhZGVycyA9IGdldERvY3VtZW50SGVhZGVycyhidWlsZCwgY29udGV4dCk7XG4gICAgaWYgKGlzUmVkaXJlY3RTdGF0dXNDb2RlKGNvbnRleHQuc3RhdHVzQ29kZSkgJiYgaGVhZGVycy5oYXMoXCJMb2NhdGlvblwiKSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcmVzdWx0OiBnZXRTaW5nbGVGZXRjaFJlZGlyZWN0KFxuICAgICAgICAgIGNvbnRleHQuc3RhdHVzQ29kZSxcbiAgICAgICAgICBoZWFkZXJzLFxuICAgICAgICAgIGJ1aWxkLmJhc2VuYW1lXG4gICAgICAgICksXG4gICAgICAgIGhlYWRlcnMsXG4gICAgICAgIHN0YXR1czogU0lOR0xFX0ZFVENIX1JFRElSRUNUX1NUQVRVU1xuICAgICAgfTtcbiAgICB9XG4gICAgaWYgKGNvbnRleHQuZXJyb3JzKSB7XG4gICAgICBPYmplY3QudmFsdWVzKGNvbnRleHQuZXJyb3JzKS5mb3JFYWNoKChlcnIpID0+IHtcbiAgICAgICAgaWYgKCFpc1JvdXRlRXJyb3JSZXNwb25zZShlcnIpIHx8IGVyci5lcnJvcikge1xuICAgICAgICAgIGhhbmRsZUVycm9yKGVycik7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgY29udGV4dC5lcnJvcnMgPSBzYW5pdGl6ZUVycm9ycyhjb250ZXh0LmVycm9ycywgc2VydmVyTW9kZSk7XG4gICAgfVxuICAgIGxldCBzaW5nbGVGZXRjaFJlc3VsdDtcbiAgICBpZiAoY29udGV4dC5lcnJvcnMpIHtcbiAgICAgIHNpbmdsZUZldGNoUmVzdWx0ID0geyBlcnJvcjogT2JqZWN0LnZhbHVlcyhjb250ZXh0LmVycm9ycylbMF0gfTtcbiAgICB9IGVsc2Uge1xuICAgICAgc2luZ2xlRmV0Y2hSZXN1bHQgPSB7IGRhdGE6IE9iamVjdC52YWx1ZXMoY29udGV4dC5hY3Rpb25EYXRhIHx8IHt9KVswXSB9O1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgcmVzdWx0OiBzaW5nbGVGZXRjaFJlc3VsdCxcbiAgICAgIGhlYWRlcnMsXG4gICAgICBzdGF0dXM6IGNvbnRleHQuc3RhdHVzQ29kZVxuICAgIH07XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgaGFuZGxlRXJyb3IoZXJyb3IpO1xuICAgIHJldHVybiB7XG4gICAgICByZXN1bHQ6IHsgZXJyb3IgfSxcbiAgICAgIGhlYWRlcnM6IG5ldyBIZWFkZXJzKCksXG4gICAgICBzdGF0dXM6IDUwMFxuICAgIH07XG4gIH1cbn1cbmFzeW5jIGZ1bmN0aW9uIHNpbmdsZUZldGNoTG9hZGVycyhidWlsZCwgc2VydmVyTW9kZSwgc3RhdGljSGFuZGxlciwgcmVxdWVzdCwgaGFuZGxlclVybCwgbG9hZENvbnRleHQsIGhhbmRsZUVycm9yKSB7XG4gIHRyeSB7XG4gICAgbGV0IGhhbmRsZXJSZXF1ZXN0ID0gbmV3IFJlcXVlc3QoaGFuZGxlclVybCwge1xuICAgICAgaGVhZGVyczogcmVxdWVzdC5oZWFkZXJzLFxuICAgICAgc2lnbmFsOiByZXF1ZXN0LnNpZ25hbFxuICAgIH0pO1xuICAgIGxldCBsb2FkUm91dGVJZHMgPSBuZXcgVVJMKHJlcXVlc3QudXJsKS5zZWFyY2hQYXJhbXMuZ2V0KFwiX3JvdXRlc1wiKT8uc3BsaXQoXCIsXCIpIHx8IHZvaWQgMDtcbiAgICBsZXQgcmVzdWx0ID0gYXdhaXQgc3RhdGljSGFuZGxlci5xdWVyeShoYW5kbGVyUmVxdWVzdCwge1xuICAgICAgcmVxdWVzdENvbnRleHQ6IGxvYWRDb250ZXh0LFxuICAgICAgc2tpcExvYWRlckVycm9yQnViYmxpbmc6IHRydWUsXG4gICAgICBkYXRhU3RyYXRlZ3k6IGdldFNpbmdsZUZldGNoRGF0YVN0cmF0ZWd5Mih7XG4gICAgICAgIGxvYWRSb3V0ZUlkc1xuICAgICAgfSlcbiAgICB9KTtcbiAgICBpZiAoaXNSZXNwb25zZShyZXN1bHQpKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICByZXN1bHQ6IHtcbiAgICAgICAgICBbU2luZ2xlRmV0Y2hSZWRpcmVjdFN5bWJvbF06IGdldFNpbmdsZUZldGNoUmVkaXJlY3QoXG4gICAgICAgICAgICByZXN1bHQuc3RhdHVzLFxuICAgICAgICAgICAgcmVzdWx0LmhlYWRlcnMsXG4gICAgICAgICAgICBidWlsZC5iYXNlbmFtZVxuICAgICAgICAgIClcbiAgICAgICAgfSxcbiAgICAgICAgaGVhZGVyczogcmVzdWx0LmhlYWRlcnMsXG4gICAgICAgIHN0YXR1czogU0lOR0xFX0ZFVENIX1JFRElSRUNUX1NUQVRVU1xuICAgICAgfTtcbiAgICB9XG4gICAgbGV0IGNvbnRleHQgPSByZXN1bHQ7XG4gICAgbGV0IGhlYWRlcnMgPSBnZXREb2N1bWVudEhlYWRlcnMoYnVpbGQsIGNvbnRleHQpO1xuICAgIGlmIChpc1JlZGlyZWN0U3RhdHVzQ29kZShjb250ZXh0LnN0YXR1c0NvZGUpICYmIGhlYWRlcnMuaGFzKFwiTG9jYXRpb25cIikpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHJlc3VsdDoge1xuICAgICAgICAgIFtTaW5nbGVGZXRjaFJlZGlyZWN0U3ltYm9sXTogZ2V0U2luZ2xlRmV0Y2hSZWRpcmVjdChcbiAgICAgICAgICAgIGNvbnRleHQuc3RhdHVzQ29kZSxcbiAgICAgICAgICAgIGhlYWRlcnMsXG4gICAgICAgICAgICBidWlsZC5iYXNlbmFtZVxuICAgICAgICAgIClcbiAgICAgICAgfSxcbiAgICAgICAgaGVhZGVycyxcbiAgICAgICAgc3RhdHVzOiBTSU5HTEVfRkVUQ0hfUkVESVJFQ1RfU1RBVFVTXG4gICAgICB9O1xuICAgIH1cbiAgICBpZiAoY29udGV4dC5lcnJvcnMpIHtcbiAgICAgIE9iamVjdC52YWx1ZXMoY29udGV4dC5lcnJvcnMpLmZvckVhY2goKGVycikgPT4ge1xuICAgICAgICBpZiAoIWlzUm91dGVFcnJvclJlc3BvbnNlKGVycikgfHwgZXJyLmVycm9yKSB7XG4gICAgICAgICAgaGFuZGxlRXJyb3IoZXJyKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBjb250ZXh0LmVycm9ycyA9IHNhbml0aXplRXJyb3JzKGNvbnRleHQuZXJyb3JzLCBzZXJ2ZXJNb2RlKTtcbiAgICB9XG4gICAgbGV0IHJlc3VsdHMgPSB7fTtcbiAgICBsZXQgbG9hZGVkTWF0Y2hlcyA9IGxvYWRSb3V0ZUlkcyA/IGNvbnRleHQubWF0Y2hlcy5maWx0ZXIoXG4gICAgICAobSkgPT4gbS5yb3V0ZS5sb2FkZXIgJiYgbG9hZFJvdXRlSWRzLmluY2x1ZGVzKG0ucm91dGUuaWQpXG4gICAgKSA6IGNvbnRleHQubWF0Y2hlcztcbiAgICBsb2FkZWRNYXRjaGVzLmZvckVhY2goKG0pID0+IHtcbiAgICAgIGxldCB7IGlkIH0gPSBtLnJvdXRlO1xuICAgICAgaWYgKGNvbnRleHQuZXJyb3JzICYmIGNvbnRleHQuZXJyb3JzLmhhc093blByb3BlcnR5KGlkKSkge1xuICAgICAgICByZXN1bHRzW2lkXSA9IHsgZXJyb3I6IGNvbnRleHQuZXJyb3JzW2lkXSB9O1xuICAgICAgfSBlbHNlIGlmIChjb250ZXh0LmxvYWRlckRhdGEuaGFzT3duUHJvcGVydHkoaWQpKSB7XG4gICAgICAgIHJlc3VsdHNbaWRdID0geyBkYXRhOiBjb250ZXh0LmxvYWRlckRhdGFbaWRdIH07XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHJlc3VsdDogcmVzdWx0cyxcbiAgICAgIGhlYWRlcnMsXG4gICAgICBzdGF0dXM6IGNvbnRleHQuc3RhdHVzQ29kZVxuICAgIH07XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgaGFuZGxlRXJyb3IoZXJyb3IpO1xuICAgIHJldHVybiB7XG4gICAgICByZXN1bHQ6IHsgcm9vdDogeyBlcnJvciB9IH0sXG4gICAgICBoZWFkZXJzOiBuZXcgSGVhZGVycygpLFxuICAgICAgc3RhdHVzOiA1MDBcbiAgICB9O1xuICB9XG59XG5mdW5jdGlvbiBnZXRTaW5nbGVGZXRjaFJlZGlyZWN0KHN0YXR1cywgaGVhZGVycywgYmFzZW5hbWUpIHtcbiAgbGV0IHJlZGlyZWN0MiA9IGhlYWRlcnMuZ2V0KFwiTG9jYXRpb25cIik7XG4gIGlmIChiYXNlbmFtZSkge1xuICAgIHJlZGlyZWN0MiA9IHN0cmlwQmFzZW5hbWUocmVkaXJlY3QyLCBiYXNlbmFtZSkgfHwgcmVkaXJlY3QyO1xuICB9XG4gIHJldHVybiB7XG4gICAgcmVkaXJlY3Q6IHJlZGlyZWN0MixcbiAgICBzdGF0dXMsXG4gICAgcmV2YWxpZGF0ZTogKFxuICAgICAgLy8gVGVjaG5pY2FsbHkgWC1SZW1peC1SZXZhbGlkYXRlIGlzbid0IG5lZWRlZCBoZXJlIC0gdGhhdCB3YXMgYW4gaW1wbGVtZW50YXRpb25cbiAgICAgIC8vIGRldGFpbCBvZiA/X2RhdGEgcmVxdWVzdHMgYXMgb3VyIHdheSB0byB0ZWxsIHRoZSBmcm9udCBlbmQgdG8gcmV2YWxpZGF0ZSB3aGVuXG4gICAgICAvLyB3ZSBkaWRuJ3QgaGF2ZSBhIHJlc3BvbnNlIGJvZHkgdG8gaW5jbHVkZSB0aGF0IGluZm9ybWF0aW9uIGluLlxuICAgICAgLy8gV2l0aCBzaW5nbGUgZmV0Y2gsIHdlIHRlbGwgdGhlIGZyb250IGVuZCB2aWEgdGhpcyByZXZhbGlkYXRlIGJvb2xlYW4gZmllbGQuXG4gICAgICAvLyBIb3dldmVyLCB3ZSdyZSByZXNwZWN0aW5nIGl0IGZvciBub3cgYmVjYXVzZSBpdCBtYXkgYmUgc29tZXRoaW5nIGZvbGtzIGhhdmVcbiAgICAgIC8vIHVzZWQgaW4gdGhlaXIgb3duIHJlc3BvbnNlc1xuICAgICAgLy8gVE9ETyh2Myk6IENvbnNpZGVyIHJlbW92aW5nIG9yIG1ha2luZyB0aGlzIG9mZmljaWFsIHB1YmxpYyBBUElcbiAgICAgIGhlYWRlcnMuaGFzKFwiWC1SZW1peC1SZXZhbGlkYXRlXCIpIHx8IGhlYWRlcnMuaGFzKFwiU2V0LUNvb2tpZVwiKVxuICAgICksXG4gICAgcmVsb2FkOiBoZWFkZXJzLmhhcyhcIlgtUmVtaXgtUmVsb2FkLURvY3VtZW50XCIpLFxuICAgIHJlcGxhY2U6IGhlYWRlcnMuaGFzKFwiWC1SZW1peC1SZXBsYWNlXCIpXG4gIH07XG59XG5mdW5jdGlvbiBlbmNvZGVWaWFUdXJib1N0cmVhbShkYXRhMiwgcmVxdWVzdFNpZ25hbCwgc3RyZWFtVGltZW91dCwgc2VydmVyTW9kZSkge1xuICBsZXQgY29udHJvbGxlciA9IG5ldyBBYm9ydENvbnRyb2xsZXIoKTtcbiAgbGV0IHRpbWVvdXRJZCA9IHNldFRpbWVvdXQoXG4gICAgKCkgPT4gY29udHJvbGxlci5hYm9ydChuZXcgRXJyb3IoXCJTZXJ2ZXIgVGltZW91dFwiKSksXG4gICAgdHlwZW9mIHN0cmVhbVRpbWVvdXQgPT09IFwibnVtYmVyXCIgPyBzdHJlYW1UaW1lb3V0IDogNDk1MFxuICApO1xuICByZXF1ZXN0U2lnbmFsLmFkZEV2ZW50TGlzdGVuZXIoXCJhYm9ydFwiLCAoKSA9PiBjbGVhclRpbWVvdXQodGltZW91dElkKSk7XG4gIHJldHVybiAoMCwgaW1wb3J0X3R1cmJvX3N0cmVhbTIuZW5jb2RlKShkYXRhMiwge1xuICAgIHNpZ25hbDogY29udHJvbGxlci5zaWduYWwsXG4gICAgcGx1Z2luczogW1xuICAgICAgKHZhbHVlKSA9PiB7XG4gICAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgICAgbGV0IHsgbmFtZSwgbWVzc2FnZSwgc3RhY2sgfSA9IHNlcnZlck1vZGUgPT09IFwicHJvZHVjdGlvblwiIC8qIFByb2R1Y3Rpb24gKi8gPyBzYW5pdGl6ZUVycm9yKHZhbHVlLCBzZXJ2ZXJNb2RlKSA6IHZhbHVlO1xuICAgICAgICAgIHJldHVybiBbXCJTYW5pdGl6ZWRFcnJvclwiLCBuYW1lLCBtZXNzYWdlLCBzdGFja107XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgRXJyb3JSZXNwb25zZUltcGwpIHtcbiAgICAgICAgICBsZXQgeyBkYXRhOiBkYXRhMywgc3RhdHVzLCBzdGF0dXNUZXh0IH0gPSB2YWx1ZTtcbiAgICAgICAgICByZXR1cm4gW1wiRXJyb3JSZXNwb25zZVwiLCBkYXRhMywgc3RhdHVzLCBzdGF0dXNUZXh0XTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodmFsdWUgJiYgdHlwZW9mIHZhbHVlID09PSBcIm9iamVjdFwiICYmIFNpbmdsZUZldGNoUmVkaXJlY3RTeW1ib2wgaW4gdmFsdWUpIHtcbiAgICAgICAgICByZXR1cm4gW1wiU2luZ2xlRmV0Y2hSZWRpcmVjdFwiLCB2YWx1ZVtTaW5nbGVGZXRjaFJlZGlyZWN0U3ltYm9sXV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICBdLFxuICAgIHBvc3RQbHVnaW5zOiBbXG4gICAgICAodmFsdWUpID0+IHtcbiAgICAgICAgaWYgKCF2YWx1ZSkgcmV0dXJuO1xuICAgICAgICBpZiAodHlwZW9mIHZhbHVlICE9PSBcIm9iamVjdFwiKSByZXR1cm47XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgXCJTaW5nbGVGZXRjaENsYXNzSW5zdGFuY2VcIixcbiAgICAgICAgICBPYmplY3QuZnJvbUVudHJpZXMoT2JqZWN0LmVudHJpZXModmFsdWUpKVxuICAgICAgICBdO1xuICAgICAgfSxcbiAgICAgICgpID0+IFtcIlNpbmdsZUZldGNoRmFsbGJhY2tcIl1cbiAgICBdXG4gIH0pO1xufVxuXG4vLyBsaWIvc2VydmVyLXJ1bnRpbWUvc2VydmVyLnRzXG5mdW5jdGlvbiBkZXJpdmUoYnVpbGQsIG1vZGUpIHtcbiAgbGV0IHJvdXRlcyA9IGNyZWF0ZVJvdXRlcyhidWlsZC5yb3V0ZXMpO1xuICBsZXQgZGF0YVJvdXRlcyA9IGNyZWF0ZVN0YXRpY0hhbmRsZXJEYXRhUm91dGVzKGJ1aWxkLnJvdXRlcywgYnVpbGQuZnV0dXJlKTtcbiAgbGV0IHNlcnZlck1vZGUgPSBpc1NlcnZlck1vZGUobW9kZSkgPyBtb2RlIDogXCJwcm9kdWN0aW9uXCIgLyogUHJvZHVjdGlvbiAqLztcbiAgbGV0IHN0YXRpY0hhbmRsZXIgPSBjcmVhdGVTdGF0aWNIYW5kbGVyKGRhdGFSb3V0ZXMsIHtcbiAgICBiYXNlbmFtZTogYnVpbGQuYmFzZW5hbWVcbiAgfSk7XG4gIGxldCBlcnJvckhhbmRsZXIgPSBidWlsZC5lbnRyeS5tb2R1bGUuaGFuZGxlRXJyb3IgfHwgKChlcnJvciwgeyByZXF1ZXN0IH0pID0+IHtcbiAgICBpZiAoc2VydmVyTW9kZSAhPT0gXCJ0ZXN0XCIgLyogVGVzdCAqLyAmJiAhcmVxdWVzdC5zaWduYWwuYWJvcnRlZCkge1xuICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvciBUaGlzIGlzIFwicHJpdmF0ZVwiIGZyb20gdXNlcnMgYnV0IGludGVuZGVkIGZvciBpbnRlcm5hbCB1c2VcbiAgICAgICAgaXNSb3V0ZUVycm9yUmVzcG9uc2UoZXJyb3IpICYmIGVycm9yLmVycm9yID8gZXJyb3IuZXJyb3IgOiBlcnJvclxuICAgICAgKTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4ge1xuICAgIHJvdXRlcyxcbiAgICBkYXRhUm91dGVzLFxuICAgIHNlcnZlck1vZGUsXG4gICAgc3RhdGljSGFuZGxlcixcbiAgICBlcnJvckhhbmRsZXJcbiAgfTtcbn1cbnZhciBjcmVhdGVSZXF1ZXN0SGFuZGxlciA9IChidWlsZCwgbW9kZSkgPT4ge1xuICBsZXQgX2J1aWxkO1xuICBsZXQgcm91dGVzO1xuICBsZXQgc2VydmVyTW9kZTtcbiAgbGV0IHN0YXRpY0hhbmRsZXI7XG4gIGxldCBlcnJvckhhbmRsZXI7XG4gIHJldHVybiBhc3luYyBmdW5jdGlvbiByZXF1ZXN0SGFuZGxlcihyZXF1ZXN0LCBsb2FkQ29udGV4dCA9IHt9KSB7XG4gICAgX2J1aWxkID0gdHlwZW9mIGJ1aWxkID09PSBcImZ1bmN0aW9uXCIgPyBhd2FpdCBidWlsZCgpIDogYnVpbGQ7XG4gICAgaWYgKHR5cGVvZiBidWlsZCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICBsZXQgZGVyaXZlZCA9IGRlcml2ZShfYnVpbGQsIG1vZGUpO1xuICAgICAgcm91dGVzID0gZGVyaXZlZC5yb3V0ZXM7XG4gICAgICBzZXJ2ZXJNb2RlID0gZGVyaXZlZC5zZXJ2ZXJNb2RlO1xuICAgICAgc3RhdGljSGFuZGxlciA9IGRlcml2ZWQuc3RhdGljSGFuZGxlcjtcbiAgICAgIGVycm9ySGFuZGxlciA9IGRlcml2ZWQuZXJyb3JIYW5kbGVyO1xuICAgIH0gZWxzZSBpZiAoIXJvdXRlcyB8fCAhc2VydmVyTW9kZSB8fCAhc3RhdGljSGFuZGxlciB8fCAhZXJyb3JIYW5kbGVyKSB7XG4gICAgICBsZXQgZGVyaXZlZCA9IGRlcml2ZShfYnVpbGQsIG1vZGUpO1xuICAgICAgcm91dGVzID0gZGVyaXZlZC5yb3V0ZXM7XG4gICAgICBzZXJ2ZXJNb2RlID0gZGVyaXZlZC5zZXJ2ZXJNb2RlO1xuICAgICAgc3RhdGljSGFuZGxlciA9IGRlcml2ZWQuc3RhdGljSGFuZGxlcjtcbiAgICAgIGVycm9ySGFuZGxlciA9IGRlcml2ZWQuZXJyb3JIYW5kbGVyO1xuICAgIH1cbiAgICBsZXQgdXJsID0gbmV3IFVSTChyZXF1ZXN0LnVybCk7XG4gICAgbGV0IHBhcmFtcyA9IHt9O1xuICAgIGxldCBoYW5kbGVFcnJvciA9IChlcnJvcikgPT4ge1xuICAgICAgaWYgKG1vZGUgPT09IFwiZGV2ZWxvcG1lbnRcIiAvKiBEZXZlbG9wbWVudCAqLykge1xuICAgICAgICBnZXREZXZTZXJ2ZXJIb29rcygpPy5wcm9jZXNzUmVxdWVzdEVycm9yPy4oZXJyb3IpO1xuICAgICAgfVxuICAgICAgZXJyb3JIYW5kbGVyKGVycm9yLCB7XG4gICAgICAgIGNvbnRleHQ6IGxvYWRDb250ZXh0LFxuICAgICAgICBwYXJhbXMsXG4gICAgICAgIHJlcXVlc3RcbiAgICAgIH0pO1xuICAgIH07XG4gICAgbGV0IG1hbmlmZXN0VXJsID0gYCR7X2J1aWxkLmJhc2VuYW1lID8/IFwiL1wifS9fX21hbmlmZXN0YC5yZXBsYWNlKFxuICAgICAgL1xcLysvZyxcbiAgICAgIFwiL1wiXG4gICAgKTtcbiAgICBpZiAodXJsLnBhdGhuYW1lID09PSBtYW5pZmVzdFVybCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgbGV0IHJlcyA9IGF3YWl0IGhhbmRsZU1hbmlmZXN0UmVxdWVzdChfYnVpbGQsIHJvdXRlcywgdXJsKTtcbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgaGFuZGxlRXJyb3IoZSk7XG4gICAgICAgIHJldHVybiBuZXcgUmVzcG9uc2UoXCJVbmtub3duIFNlcnZlciBFcnJvclwiLCB7IHN0YXR1czogNTAwIH0pO1xuICAgICAgfVxuICAgIH1cbiAgICBsZXQgbWF0Y2hlcyA9IG1hdGNoU2VydmVyUm91dGVzKHJvdXRlcywgdXJsLnBhdGhuYW1lLCBfYnVpbGQuYmFzZW5hbWUpO1xuICAgIGlmIChtYXRjaGVzICYmIG1hdGNoZXMubGVuZ3RoID4gMCkge1xuICAgICAgT2JqZWN0LmFzc2lnbihwYXJhbXMsIG1hdGNoZXNbMF0ucGFyYW1zKTtcbiAgICB9XG4gICAgbGV0IHJlc3BvbnNlO1xuICAgIGlmICh1cmwucGF0aG5hbWUuZW5kc1dpdGgoXCIuZGF0YVwiKSkge1xuICAgICAgbGV0IGhhbmRsZXJVcmwgPSBuZXcgVVJMKHJlcXVlc3QudXJsKTtcbiAgICAgIGhhbmRsZXJVcmwucGF0aG5hbWUgPSBoYW5kbGVyVXJsLnBhdGhuYW1lLnJlcGxhY2UoL1xcLmRhdGEkLywgXCJcIikucmVwbGFjZSgvXlxcL19yb290JC8sIFwiL1wiKTtcbiAgICAgIGxldCBzaW5nbGVGZXRjaE1hdGNoZXMgPSBtYXRjaFNlcnZlclJvdXRlcyhcbiAgICAgICAgcm91dGVzLFxuICAgICAgICBoYW5kbGVyVXJsLnBhdGhuYW1lLFxuICAgICAgICBfYnVpbGQuYmFzZW5hbWVcbiAgICAgICk7XG4gICAgICByZXNwb25zZSA9IGF3YWl0IGhhbmRsZVNpbmdsZUZldGNoUmVxdWVzdChcbiAgICAgICAgc2VydmVyTW9kZSxcbiAgICAgICAgX2J1aWxkLFxuICAgICAgICBzdGF0aWNIYW5kbGVyLFxuICAgICAgICByZXF1ZXN0LFxuICAgICAgICBoYW5kbGVyVXJsLFxuICAgICAgICBsb2FkQ29udGV4dCxcbiAgICAgICAgaGFuZGxlRXJyb3JcbiAgICAgICk7XG4gICAgICBpZiAoX2J1aWxkLmVudHJ5Lm1vZHVsZS5oYW5kbGVEYXRhUmVxdWVzdCkge1xuICAgICAgICByZXNwb25zZSA9IGF3YWl0IF9idWlsZC5lbnRyeS5tb2R1bGUuaGFuZGxlRGF0YVJlcXVlc3QocmVzcG9uc2UsIHtcbiAgICAgICAgICBjb250ZXh0OiBsb2FkQ29udGV4dCxcbiAgICAgICAgICBwYXJhbXM6IHNpbmdsZUZldGNoTWF0Y2hlcyA/IHNpbmdsZUZldGNoTWF0Y2hlc1swXS5wYXJhbXMgOiB7fSxcbiAgICAgICAgICByZXF1ZXN0XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoaXNSZWRpcmVjdFJlc3BvbnNlKHJlc3BvbnNlKSkge1xuICAgICAgICAgIGxldCByZXN1bHQgPSBnZXRTaW5nbGVGZXRjaFJlZGlyZWN0KFxuICAgICAgICAgICAgcmVzcG9uc2Uuc3RhdHVzLFxuICAgICAgICAgICAgcmVzcG9uc2UuaGVhZGVycyxcbiAgICAgICAgICAgIF9idWlsZC5iYXNlbmFtZVxuICAgICAgICAgICk7XG4gICAgICAgICAgaWYgKHJlcXVlc3QubWV0aG9kID09PSBcIkdFVFwiKSB7XG4gICAgICAgICAgICByZXN1bHQgPSB7XG4gICAgICAgICAgICAgIFtTaW5nbGVGZXRjaFJlZGlyZWN0U3ltYm9sXTogcmVzdWx0XG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH1cbiAgICAgICAgICBsZXQgaGVhZGVycyA9IG5ldyBIZWFkZXJzKHJlc3BvbnNlLmhlYWRlcnMpO1xuICAgICAgICAgIGhlYWRlcnMuc2V0KFwiQ29udGVudC1UeXBlXCIsIFwidGV4dC94LXNjcmlwdFwiKTtcbiAgICAgICAgICByZXR1cm4gbmV3IFJlc3BvbnNlKFxuICAgICAgICAgICAgZW5jb2RlVmlhVHVyYm9TdHJlYW0oXG4gICAgICAgICAgICAgIHJlc3VsdCxcbiAgICAgICAgICAgICAgcmVxdWVzdC5zaWduYWwsXG4gICAgICAgICAgICAgIF9idWlsZC5lbnRyeS5tb2R1bGUuc3RyZWFtVGltZW91dCxcbiAgICAgICAgICAgICAgc2VydmVyTW9kZVxuICAgICAgICAgICAgKSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgc3RhdHVzOiBTSU5HTEVfRkVUQ0hfUkVESVJFQ1RfU1RBVFVTLFxuICAgICAgICAgICAgICBoZWFkZXJzXG4gICAgICAgICAgICB9XG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAobWF0Y2hlcyAmJiBtYXRjaGVzW21hdGNoZXMubGVuZ3RoIC0gMV0ucm91dGUubW9kdWxlLmRlZmF1bHQgPT0gbnVsbCAmJiBtYXRjaGVzW21hdGNoZXMubGVuZ3RoIC0gMV0ucm91dGUubW9kdWxlLkVycm9yQm91bmRhcnkgPT0gbnVsbCkge1xuICAgICAgcmVzcG9uc2UgPSBhd2FpdCBoYW5kbGVSZXNvdXJjZVJlcXVlc3QoXG4gICAgICAgIHNlcnZlck1vZGUsXG4gICAgICAgIHN0YXRpY0hhbmRsZXIsXG4gICAgICAgIG1hdGNoZXMuc2xpY2UoLTEpWzBdLnJvdXRlLmlkLFxuICAgICAgICByZXF1ZXN0LFxuICAgICAgICBsb2FkQ29udGV4dCxcbiAgICAgICAgaGFuZGxlRXJyb3JcbiAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxldCBjcml0aWNhbENzcyA9IG1vZGUgPT09IFwiZGV2ZWxvcG1lbnRcIiAvKiBEZXZlbG9wbWVudCAqLyA/IGF3YWl0IGdldERldlNlcnZlckhvb2tzKCk/LmdldENyaXRpY2FsQ3NzPy4oX2J1aWxkLCB1cmwucGF0aG5hbWUpIDogdm9pZCAwO1xuICAgICAgcmVzcG9uc2UgPSBhd2FpdCBoYW5kbGVEb2N1bWVudFJlcXVlc3QoXG4gICAgICAgIHNlcnZlck1vZGUsXG4gICAgICAgIF9idWlsZCxcbiAgICAgICAgc3RhdGljSGFuZGxlcixcbiAgICAgICAgcmVxdWVzdCxcbiAgICAgICAgbG9hZENvbnRleHQsXG4gICAgICAgIGhhbmRsZUVycm9yLFxuICAgICAgICBjcml0aWNhbENzc1xuICAgICAgKTtcbiAgICB9XG4gICAgaWYgKHJlcXVlc3QubWV0aG9kID09PSBcIkhFQURcIikge1xuICAgICAgcmV0dXJuIG5ldyBSZXNwb25zZShudWxsLCB7XG4gICAgICAgIGhlYWRlcnM6IHJlc3BvbnNlLmhlYWRlcnMsXG4gICAgICAgIHN0YXR1czogcmVzcG9uc2Uuc3RhdHVzLFxuICAgICAgICBzdGF0dXNUZXh0OiByZXNwb25zZS5zdGF0dXNUZXh0XG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3BvbnNlO1xuICB9O1xufTtcbmFzeW5jIGZ1bmN0aW9uIGhhbmRsZU1hbmlmZXN0UmVxdWVzdChidWlsZCwgcm91dGVzLCB1cmwpIHtcbiAgbGV0IHBhdGNoZXMgPSB7fTtcbiAgaWYgKHVybC5zZWFyY2hQYXJhbXMuaGFzKFwicFwiKSkge1xuICAgIGZvciAobGV0IHBhdGggb2YgdXJsLnNlYXJjaFBhcmFtcy5nZXRBbGwoXCJwXCIpKSB7XG4gICAgICBsZXQgbWF0Y2hlcyA9IG1hdGNoU2VydmVyUm91dGVzKHJvdXRlcywgcGF0aCwgYnVpbGQuYmFzZW5hbWUpO1xuICAgICAgaWYgKG1hdGNoZXMpIHtcbiAgICAgICAgZm9yIChsZXQgbWF0Y2ggb2YgbWF0Y2hlcykge1xuICAgICAgICAgIGxldCByb3V0ZUlkID0gbWF0Y2gucm91dGUuaWQ7XG4gICAgICAgICAgbGV0IHJvdXRlID0gYnVpbGQuYXNzZXRzLnJvdXRlc1tyb3V0ZUlkXTtcbiAgICAgICAgICBpZiAocm91dGUpIHtcbiAgICAgICAgICAgIHBhdGNoZXNbcm91dGVJZF0gPSByb3V0ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIFJlc3BvbnNlLmpzb24ocGF0Y2hlcywge1xuICAgICAgaGVhZGVyczoge1xuICAgICAgICBcIkNhY2hlLUNvbnRyb2xcIjogXCJwdWJsaWMsIG1heC1hZ2U9MzE1MzYwMDAsIGltbXV0YWJsZVwiXG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIG5ldyBSZXNwb25zZShcIkludmFsaWQgUmVxdWVzdFwiLCB7IHN0YXR1czogNDAwIH0pO1xufVxuYXN5bmMgZnVuY3Rpb24gaGFuZGxlU2luZ2xlRmV0Y2hSZXF1ZXN0KHNlcnZlck1vZGUsIGJ1aWxkLCBzdGF0aWNIYW5kbGVyLCByZXF1ZXN0LCBoYW5kbGVyVXJsLCBsb2FkQ29udGV4dCwgaGFuZGxlRXJyb3IpIHtcbiAgbGV0IHsgcmVzdWx0LCBoZWFkZXJzLCBzdGF0dXMgfSA9IHJlcXVlc3QubWV0aG9kICE9PSBcIkdFVFwiID8gYXdhaXQgc2luZ2xlRmV0Y2hBY3Rpb24oXG4gICAgYnVpbGQsXG4gICAgc2VydmVyTW9kZSxcbiAgICBzdGF0aWNIYW5kbGVyLFxuICAgIHJlcXVlc3QsXG4gICAgaGFuZGxlclVybCxcbiAgICBsb2FkQ29udGV4dCxcbiAgICBoYW5kbGVFcnJvclxuICApIDogYXdhaXQgc2luZ2xlRmV0Y2hMb2FkZXJzKFxuICAgIGJ1aWxkLFxuICAgIHNlcnZlck1vZGUsXG4gICAgc3RhdGljSGFuZGxlcixcbiAgICByZXF1ZXN0LFxuICAgIGhhbmRsZXJVcmwsXG4gICAgbG9hZENvbnRleHQsXG4gICAgaGFuZGxlRXJyb3JcbiAgKTtcbiAgbGV0IHJlc3VsdEhlYWRlcnMgPSBuZXcgSGVhZGVycyhoZWFkZXJzKTtcbiAgcmVzdWx0SGVhZGVycy5zZXQoXCJYLVJlbWl4LVJlc3BvbnNlXCIsIFwieWVzXCIpO1xuICBpZiAoc3RhdHVzID09PSAzMDQpIHtcbiAgICByZXR1cm4gbmV3IFJlc3BvbnNlKG51bGwsIHsgc3RhdHVzOiAzMDQsIGhlYWRlcnM6IHJlc3VsdEhlYWRlcnMgfSk7XG4gIH1cbiAgcmVzdWx0SGVhZGVycy5zZXQoXCJDb250ZW50LVR5cGVcIiwgXCJ0ZXh0L3gtc2NyaXB0XCIpO1xuICByZXR1cm4gbmV3IFJlc3BvbnNlKFxuICAgIGVuY29kZVZpYVR1cmJvU3RyZWFtKFxuICAgICAgcmVzdWx0LFxuICAgICAgcmVxdWVzdC5zaWduYWwsXG4gICAgICBidWlsZC5lbnRyeS5tb2R1bGUuc3RyZWFtVGltZW91dCxcbiAgICAgIHNlcnZlck1vZGVcbiAgICApLFxuICAgIHtcbiAgICAgIHN0YXR1czogc3RhdHVzIHx8IDIwMCxcbiAgICAgIGhlYWRlcnM6IHJlc3VsdEhlYWRlcnNcbiAgICB9XG4gICk7XG59XG5hc3luYyBmdW5jdGlvbiBoYW5kbGVEb2N1bWVudFJlcXVlc3Qoc2VydmVyTW9kZSwgYnVpbGQsIHN0YXRpY0hhbmRsZXIsIHJlcXVlc3QsIGxvYWRDb250ZXh0LCBoYW5kbGVFcnJvciwgY3JpdGljYWxDc3MpIHtcbiAgbGV0IGNvbnRleHQ7XG4gIHRyeSB7XG4gICAgY29udGV4dCA9IGF3YWl0IHN0YXRpY0hhbmRsZXIucXVlcnkocmVxdWVzdCwge1xuICAgICAgcmVxdWVzdENvbnRleHQ6IGxvYWRDb250ZXh0XG4gICAgfSk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgaGFuZGxlRXJyb3IoZXJyb3IpO1xuICAgIHJldHVybiBuZXcgUmVzcG9uc2UobnVsbCwgeyBzdGF0dXM6IDUwMCB9KTtcbiAgfVxuICBpZiAoaXNSZXNwb25zZShjb250ZXh0KSkge1xuICAgIHJldHVybiBjb250ZXh0O1xuICB9XG4gIGxldCBoZWFkZXJzID0gZ2V0RG9jdW1lbnRIZWFkZXJzKGJ1aWxkLCBjb250ZXh0KTtcbiAgaWYgKGNvbnRleHQuc3RhdHVzQ29kZSA9PT0gMzA0KSB7XG4gICAgcmV0dXJuIG5ldyBSZXNwb25zZShudWxsLCB7IHN0YXR1czogMzA0LCBoZWFkZXJzIH0pO1xuICB9XG4gIGlmIChjb250ZXh0LmVycm9ycykge1xuICAgIE9iamVjdC52YWx1ZXMoY29udGV4dC5lcnJvcnMpLmZvckVhY2goKGVycikgPT4ge1xuICAgICAgaWYgKCFpc1JvdXRlRXJyb3JSZXNwb25zZShlcnIpIHx8IGVyci5lcnJvcikge1xuICAgICAgICBoYW5kbGVFcnJvcihlcnIpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGNvbnRleHQuZXJyb3JzID0gc2FuaXRpemVFcnJvcnMoY29udGV4dC5lcnJvcnMsIHNlcnZlck1vZGUpO1xuICB9XG4gIGxldCBzdGF0ZSA9IHtcbiAgICBsb2FkZXJEYXRhOiBjb250ZXh0LmxvYWRlckRhdGEsXG4gICAgYWN0aW9uRGF0YTogY29udGV4dC5hY3Rpb25EYXRhLFxuICAgIGVycm9yczogc2VyaWFsaXplRXJyb3JzMihjb250ZXh0LmVycm9ycywgc2VydmVyTW9kZSlcbiAgfTtcbiAgbGV0IGVudHJ5Q29udGV4dCA9IHtcbiAgICBtYW5pZmVzdDogYnVpbGQuYXNzZXRzLFxuICAgIHJvdXRlTW9kdWxlczogY3JlYXRlRW50cnlSb3V0ZU1vZHVsZXMoYnVpbGQucm91dGVzKSxcbiAgICBzdGF0aWNIYW5kbGVyQ29udGV4dDogY29udGV4dCxcbiAgICBjcml0aWNhbENzcyxcbiAgICBzZXJ2ZXJIYW5kb2ZmU3RyaW5nOiBjcmVhdGVTZXJ2ZXJIYW5kb2ZmU3RyaW5nKHtcbiAgICAgIGJhc2VuYW1lOiBidWlsZC5iYXNlbmFtZSxcbiAgICAgIGNyaXRpY2FsQ3NzLFxuICAgICAgZnV0dXJlOiBidWlsZC5mdXR1cmUsXG4gICAgICBpc1NwYU1vZGU6IGJ1aWxkLmlzU3BhTW9kZVxuICAgIH0pLFxuICAgIHNlcnZlckhhbmRvZmZTdHJlYW06IGVuY29kZVZpYVR1cmJvU3RyZWFtKFxuICAgICAgc3RhdGUsXG4gICAgICByZXF1ZXN0LnNpZ25hbCxcbiAgICAgIGJ1aWxkLmVudHJ5Lm1vZHVsZS5zdHJlYW1UaW1lb3V0LFxuICAgICAgc2VydmVyTW9kZVxuICAgICksXG4gICAgcmVuZGVyTWV0YToge30sXG4gICAgZnV0dXJlOiBidWlsZC5mdXR1cmUsXG4gICAgaXNTcGFNb2RlOiBidWlsZC5pc1NwYU1vZGUsXG4gICAgc2VyaWFsaXplRXJyb3I6IChlcnIpID0+IHNlcmlhbGl6ZUVycm9yKGVyciwgc2VydmVyTW9kZSlcbiAgfTtcbiAgbGV0IGhhbmRsZURvY3VtZW50UmVxdWVzdEZ1bmN0aW9uID0gYnVpbGQuZW50cnkubW9kdWxlLmRlZmF1bHQ7XG4gIHRyeSB7XG4gICAgcmV0dXJuIGF3YWl0IGhhbmRsZURvY3VtZW50UmVxdWVzdEZ1bmN0aW9uKFxuICAgICAgcmVxdWVzdCxcbiAgICAgIGNvbnRleHQuc3RhdHVzQ29kZSxcbiAgICAgIGhlYWRlcnMsXG4gICAgICBlbnRyeUNvbnRleHQsXG4gICAgICBsb2FkQ29udGV4dFxuICAgICk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgaGFuZGxlRXJyb3IoZXJyb3IpO1xuICAgIGxldCBlcnJvckZvclNlY29uZFJlbmRlciA9IGVycm9yO1xuICAgIGlmIChpc1Jlc3BvbnNlKGVycm9yKSkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgbGV0IGRhdGEyID0gYXdhaXQgdW53cmFwUmVzcG9uc2UoZXJyb3IpO1xuICAgICAgICBlcnJvckZvclNlY29uZFJlbmRlciA9IG5ldyBFcnJvclJlc3BvbnNlSW1wbChcbiAgICAgICAgICBlcnJvci5zdGF0dXMsXG4gICAgICAgICAgZXJyb3Iuc3RhdHVzVGV4dCxcbiAgICAgICAgICBkYXRhMlxuICAgICAgICApO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgfVxuICAgIH1cbiAgICBjb250ZXh0ID0gZ2V0U3RhdGljQ29udGV4dEZyb21FcnJvcihcbiAgICAgIHN0YXRpY0hhbmRsZXIuZGF0YVJvdXRlcyxcbiAgICAgIGNvbnRleHQsXG4gICAgICBlcnJvckZvclNlY29uZFJlbmRlclxuICAgICk7XG4gICAgaWYgKGNvbnRleHQuZXJyb3JzKSB7XG4gICAgICBjb250ZXh0LmVycm9ycyA9IHNhbml0aXplRXJyb3JzKGNvbnRleHQuZXJyb3JzLCBzZXJ2ZXJNb2RlKTtcbiAgICB9XG4gICAgbGV0IHN0YXRlMiA9IHtcbiAgICAgIGxvYWRlckRhdGE6IGNvbnRleHQubG9hZGVyRGF0YSxcbiAgICAgIGFjdGlvbkRhdGE6IGNvbnRleHQuYWN0aW9uRGF0YSxcbiAgICAgIGVycm9yczogc2VyaWFsaXplRXJyb3JzMihjb250ZXh0LmVycm9ycywgc2VydmVyTW9kZSlcbiAgICB9O1xuICAgIGVudHJ5Q29udGV4dCA9IHtcbiAgICAgIC4uLmVudHJ5Q29udGV4dCxcbiAgICAgIHN0YXRpY0hhbmRsZXJDb250ZXh0OiBjb250ZXh0LFxuICAgICAgc2VydmVySGFuZG9mZlN0cmluZzogY3JlYXRlU2VydmVySGFuZG9mZlN0cmluZyh7XG4gICAgICAgIGJhc2VuYW1lOiBidWlsZC5iYXNlbmFtZSxcbiAgICAgICAgZnV0dXJlOiBidWlsZC5mdXR1cmUsXG4gICAgICAgIGlzU3BhTW9kZTogYnVpbGQuaXNTcGFNb2RlXG4gICAgICB9KSxcbiAgICAgIHNlcnZlckhhbmRvZmZTdHJlYW06IGVuY29kZVZpYVR1cmJvU3RyZWFtKFxuICAgICAgICBzdGF0ZTIsXG4gICAgICAgIHJlcXVlc3Quc2lnbmFsLFxuICAgICAgICBidWlsZC5lbnRyeS5tb2R1bGUuc3RyZWFtVGltZW91dCxcbiAgICAgICAgc2VydmVyTW9kZVxuICAgICAgKSxcbiAgICAgIHJlbmRlck1ldGE6IHt9XG4gICAgfTtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIGF3YWl0IGhhbmRsZURvY3VtZW50UmVxdWVzdEZ1bmN0aW9uKFxuICAgICAgICByZXF1ZXN0LFxuICAgICAgICBjb250ZXh0LnN0YXR1c0NvZGUsXG4gICAgICAgIGhlYWRlcnMsXG4gICAgICAgIGVudHJ5Q29udGV4dCxcbiAgICAgICAgbG9hZENvbnRleHRcbiAgICAgICk7XG4gICAgfSBjYXRjaCAoZXJyb3IyKSB7XG4gICAgICBoYW5kbGVFcnJvcihlcnJvcjIpO1xuICAgICAgcmV0dXJuIHJldHVybkxhc3RSZXNvcnRFcnJvclJlc3BvbnNlKGVycm9yMiwgc2VydmVyTW9kZSk7XG4gICAgfVxuICB9XG59XG5hc3luYyBmdW5jdGlvbiBoYW5kbGVSZXNvdXJjZVJlcXVlc3Qoc2VydmVyTW9kZSwgc3RhdGljSGFuZGxlciwgcm91dGVJZCwgcmVxdWVzdCwgbG9hZENvbnRleHQsIGhhbmRsZUVycm9yKSB7XG4gIHRyeSB7XG4gICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgc3RhdGljSGFuZGxlci5xdWVyeVJvdXRlKHJlcXVlc3QsIHtcbiAgICAgIHJvdXRlSWQsXG4gICAgICByZXF1ZXN0Q29udGV4dDogbG9hZENvbnRleHRcbiAgICB9KTtcbiAgICBpbnZhcmlhbnQzKFxuICAgICAgaXNSZXNwb25zZShyZXNwb25zZSksXG4gICAgICBcIkV4cGVjdGVkIGEgUmVzcG9uc2UgdG8gYmUgcmV0dXJuZWQgZnJvbSByZXNvdXJjZSByb3V0ZSBoYW5kbGVyXCJcbiAgICApO1xuICAgIHJldHVybiByZXNwb25zZTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBpZiAoaXNSZXNwb25zZShlcnJvcikpIHtcbiAgICAgIGVycm9yLmhlYWRlcnMuc2V0KFwiWC1SZW1peC1DYXRjaFwiLCBcInllc1wiKTtcbiAgICAgIHJldHVybiBlcnJvcjtcbiAgICB9XG4gICAgaWYgKGlzUm91dGVFcnJvclJlc3BvbnNlKGVycm9yKSkge1xuICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgIGhhbmRsZUVycm9yKGVycm9yKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBlcnJvclJlc3BvbnNlVG9Kc29uKGVycm9yLCBzZXJ2ZXJNb2RlKTtcbiAgICB9XG4gICAgaGFuZGxlRXJyb3IoZXJyb3IpO1xuICAgIHJldHVybiByZXR1cm5MYXN0UmVzb3J0RXJyb3JSZXNwb25zZShlcnJvciwgc2VydmVyTW9kZSk7XG4gIH1cbn1cbmZ1bmN0aW9uIGVycm9yUmVzcG9uc2VUb0pzb24oZXJyb3JSZXNwb25zZSwgc2VydmVyTW9kZSkge1xuICByZXR1cm4gUmVzcG9uc2UuanNvbihcbiAgICBzZXJpYWxpemVFcnJvcihcbiAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgVGhpcyBpcyBcInByaXZhdGVcIiBmcm9tIHVzZXJzIGJ1dCBpbnRlbmRlZCBmb3IgaW50ZXJuYWwgdXNlXG4gICAgICBlcnJvclJlc3BvbnNlLmVycm9yIHx8IG5ldyBFcnJvcihcIlVuZXhwZWN0ZWQgU2VydmVyIEVycm9yXCIpLFxuICAgICAgc2VydmVyTW9kZVxuICAgICksXG4gICAge1xuICAgICAgc3RhdHVzOiBlcnJvclJlc3BvbnNlLnN0YXR1cyxcbiAgICAgIHN0YXR1c1RleHQ6IGVycm9yUmVzcG9uc2Uuc3RhdHVzVGV4dCxcbiAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgXCJYLVJlbWl4LUVycm9yXCI6IFwieWVzXCJcbiAgICAgIH1cbiAgICB9XG4gICk7XG59XG5mdW5jdGlvbiByZXR1cm5MYXN0UmVzb3J0RXJyb3JSZXNwb25zZShlcnJvciwgc2VydmVyTW9kZSkge1xuICBsZXQgbWVzc2FnZSA9IFwiVW5leHBlY3RlZCBTZXJ2ZXIgRXJyb3JcIjtcbiAgaWYgKHNlcnZlck1vZGUgIT09IFwicHJvZHVjdGlvblwiIC8qIFByb2R1Y3Rpb24gKi8pIHtcbiAgICBtZXNzYWdlICs9IGBcblxuJHtTdHJpbmcoZXJyb3IpfWA7XG4gIH1cbiAgcmV0dXJuIG5ldyBSZXNwb25zZShtZXNzYWdlLCB7XG4gICAgc3RhdHVzOiA1MDAsXG4gICAgaGVhZGVyczoge1xuICAgICAgXCJDb250ZW50LVR5cGVcIjogXCJ0ZXh0L3BsYWluXCJcbiAgICB9XG4gIH0pO1xufVxuZnVuY3Rpb24gdW53cmFwUmVzcG9uc2UocmVzcG9uc2UpIHtcbiAgbGV0IGNvbnRlbnRUeXBlID0gcmVzcG9uc2UuaGVhZGVycy5nZXQoXCJDb250ZW50LVR5cGVcIik7XG4gIHJldHVybiBjb250ZW50VHlwZSAmJiAvXFxiYXBwbGljYXRpb25cXC9qc29uXFxiLy50ZXN0KGNvbnRlbnRUeXBlKSA/IHJlc3BvbnNlLmJvZHkgPT0gbnVsbCA/IG51bGwgOiByZXNwb25zZS5qc29uKCkgOiByZXNwb25zZS50ZXh0KCk7XG59XG5cbi8vIGxpYi9zZXJ2ZXItcnVudGltZS9zZXNzaW9ucy50c1xuZnVuY3Rpb24gZmxhc2gobmFtZSkge1xuICByZXR1cm4gYF9fZmxhc2hfJHtuYW1lfV9fYDtcbn1cbnZhciBjcmVhdGVTZXNzaW9uID0gKGluaXRpYWxEYXRhID0ge30sIGlkID0gXCJcIikgPT4ge1xuICBsZXQgbWFwID0gbmV3IE1hcChPYmplY3QuZW50cmllcyhpbml0aWFsRGF0YSkpO1xuICByZXR1cm4ge1xuICAgIGdldCBpZCgpIHtcbiAgICAgIHJldHVybiBpZDtcbiAgICB9LFxuICAgIGdldCBkYXRhKCkge1xuICAgICAgcmV0dXJuIE9iamVjdC5mcm9tRW50cmllcyhtYXApO1xuICAgIH0sXG4gICAgaGFzKG5hbWUpIHtcbiAgICAgIHJldHVybiBtYXAuaGFzKG5hbWUpIHx8IG1hcC5oYXMoZmxhc2gobmFtZSkpO1xuICAgIH0sXG4gICAgZ2V0KG5hbWUpIHtcbiAgICAgIGlmIChtYXAuaGFzKG5hbWUpKSByZXR1cm4gbWFwLmdldChuYW1lKTtcbiAgICAgIGxldCBmbGFzaE5hbWUgPSBmbGFzaChuYW1lKTtcbiAgICAgIGlmIChtYXAuaGFzKGZsYXNoTmFtZSkpIHtcbiAgICAgICAgbGV0IHZhbHVlID0gbWFwLmdldChmbGFzaE5hbWUpO1xuICAgICAgICBtYXAuZGVsZXRlKGZsYXNoTmFtZSk7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB2b2lkIDA7XG4gICAgfSxcbiAgICBzZXQobmFtZSwgdmFsdWUpIHtcbiAgICAgIG1hcC5zZXQobmFtZSwgdmFsdWUpO1xuICAgIH0sXG4gICAgZmxhc2gobmFtZSwgdmFsdWUpIHtcbiAgICAgIG1hcC5zZXQoZmxhc2gobmFtZSksIHZhbHVlKTtcbiAgICB9LFxuICAgIHVuc2V0KG5hbWUpIHtcbiAgICAgIG1hcC5kZWxldGUobmFtZSk7XG4gICAgfVxuICB9O1xufTtcbnZhciBpc1Nlc3Npb24gPSAob2JqZWN0KSA9PiB7XG4gIHJldHVybiBvYmplY3QgIT0gbnVsbCAmJiB0eXBlb2Ygb2JqZWN0LmlkID09PSBcInN0cmluZ1wiICYmIHR5cGVvZiBvYmplY3QuZGF0YSAhPT0gXCJ1bmRlZmluZWRcIiAmJiB0eXBlb2Ygb2JqZWN0LmhhcyA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBvYmplY3QuZ2V0ID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIG9iamVjdC5zZXQgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2Ygb2JqZWN0LmZsYXNoID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIG9iamVjdC51bnNldCA9PT0gXCJmdW5jdGlvblwiO1xufTtcbmZ1bmN0aW9uIGNyZWF0ZVNlc3Npb25TdG9yYWdlKHtcbiAgY29va2llOiBjb29raWVBcmcsXG4gIGNyZWF0ZURhdGEsXG4gIHJlYWREYXRhLFxuICB1cGRhdGVEYXRhLFxuICBkZWxldGVEYXRhXG59KSB7XG4gIGxldCBjb29raWUgPSBpc0Nvb2tpZShjb29raWVBcmcpID8gY29va2llQXJnIDogY3JlYXRlQ29va2llKGNvb2tpZUFyZz8ubmFtZSB8fCBcIl9fc2Vzc2lvblwiLCBjb29raWVBcmcpO1xuICB3YXJuT25jZUFib3V0U2lnbmluZ1Nlc3Npb25Db29raWUoY29va2llKTtcbiAgcmV0dXJuIHtcbiAgICBhc3luYyBnZXRTZXNzaW9uKGNvb2tpZUhlYWRlciwgb3B0aW9ucykge1xuICAgICAgbGV0IGlkID0gY29va2llSGVhZGVyICYmIGF3YWl0IGNvb2tpZS5wYXJzZShjb29raWVIZWFkZXIsIG9wdGlvbnMpO1xuICAgICAgbGV0IGRhdGEyID0gaWQgJiYgYXdhaXQgcmVhZERhdGEoaWQpO1xuICAgICAgcmV0dXJuIGNyZWF0ZVNlc3Npb24oZGF0YTIgfHwge30sIGlkIHx8IFwiXCIpO1xuICAgIH0sXG4gICAgYXN5bmMgY29tbWl0U2Vzc2lvbihzZXNzaW9uLCBvcHRpb25zKSB7XG4gICAgICBsZXQgeyBpZCwgZGF0YTogZGF0YTIgfSA9IHNlc3Npb247XG4gICAgICBsZXQgZXhwaXJlcyA9IG9wdGlvbnM/Lm1heEFnZSAhPSBudWxsID8gbmV3IERhdGUoRGF0ZS5ub3coKSArIG9wdGlvbnMubWF4QWdlICogMWUzKSA6IG9wdGlvbnM/LmV4cGlyZXMgIT0gbnVsbCA/IG9wdGlvbnMuZXhwaXJlcyA6IGNvb2tpZS5leHBpcmVzO1xuICAgICAgaWYgKGlkKSB7XG4gICAgICAgIGF3YWl0IHVwZGF0ZURhdGEoaWQsIGRhdGEyLCBleHBpcmVzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlkID0gYXdhaXQgY3JlYXRlRGF0YShkYXRhMiwgZXhwaXJlcyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gY29va2llLnNlcmlhbGl6ZShpZCwgb3B0aW9ucyk7XG4gICAgfSxcbiAgICBhc3luYyBkZXN0cm95U2Vzc2lvbihzZXNzaW9uLCBvcHRpb25zKSB7XG4gICAgICBhd2FpdCBkZWxldGVEYXRhKHNlc3Npb24uaWQpO1xuICAgICAgcmV0dXJuIGNvb2tpZS5zZXJpYWxpemUoXCJcIiwge1xuICAgICAgICAuLi5vcHRpb25zLFxuICAgICAgICBtYXhBZ2U6IHZvaWQgMCxcbiAgICAgICAgZXhwaXJlczogLyogQF9fUFVSRV9fICovIG5ldyBEYXRlKDApXG4gICAgICB9KTtcbiAgICB9XG4gIH07XG59XG5mdW5jdGlvbiB3YXJuT25jZUFib3V0U2lnbmluZ1Nlc3Npb25Db29raWUoY29va2llKSB7XG4gIHdhcm5PbmNlKFxuICAgIGNvb2tpZS5pc1NpZ25lZCxcbiAgICBgVGhlIFwiJHtjb29raWUubmFtZX1cIiBjb29raWUgaXMgbm90IHNpZ25lZCwgYnV0IHNlc3Npb24gY29va2llcyBzaG91bGQgYmUgc2lnbmVkIHRvIHByZXZlbnQgdGFtcGVyaW5nIG9uIHRoZSBjbGllbnQgYmVmb3JlIHRoZXkgYXJlIHNlbnQgYmFjayB0byB0aGUgc2VydmVyLiBTZWUgaHR0cHM6Ly9yZW1peC5ydW4vdXRpbHMvY29va2llcyNzaWduaW5nLWNvb2tpZXMgZm9yIG1vcmUgaW5mb3JtYXRpb24uYFxuICApO1xufVxuXG4vLyBsaWIvc2VydmVyLXJ1bnRpbWUvc2Vzc2lvbnMvY29va2llU3RvcmFnZS50c1xuZnVuY3Rpb24gY3JlYXRlQ29va2llU2Vzc2lvblN0b3JhZ2UoeyBjb29raWU6IGNvb2tpZUFyZyB9ID0ge30pIHtcbiAgbGV0IGNvb2tpZSA9IGlzQ29va2llKGNvb2tpZUFyZykgPyBjb29raWVBcmcgOiBjcmVhdGVDb29raWUoY29va2llQXJnPy5uYW1lIHx8IFwiX19zZXNzaW9uXCIsIGNvb2tpZUFyZyk7XG4gIHdhcm5PbmNlQWJvdXRTaWduaW5nU2Vzc2lvbkNvb2tpZShjb29raWUpO1xuICByZXR1cm4ge1xuICAgIGFzeW5jIGdldFNlc3Npb24oY29va2llSGVhZGVyLCBvcHRpb25zKSB7XG4gICAgICByZXR1cm4gY3JlYXRlU2Vzc2lvbihcbiAgICAgICAgY29va2llSGVhZGVyICYmIGF3YWl0IGNvb2tpZS5wYXJzZShjb29raWVIZWFkZXIsIG9wdGlvbnMpIHx8IHt9XG4gICAgICApO1xuICAgIH0sXG4gICAgYXN5bmMgY29tbWl0U2Vzc2lvbihzZXNzaW9uLCBvcHRpb25zKSB7XG4gICAgICBsZXQgc2VyaWFsaXplZENvb2tpZSA9IGF3YWl0IGNvb2tpZS5zZXJpYWxpemUoc2Vzc2lvbi5kYXRhLCBvcHRpb25zKTtcbiAgICAgIGlmIChzZXJpYWxpemVkQ29va2llLmxlbmd0aCA+IDQwOTYpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgIFwiQ29va2llIGxlbmd0aCB3aWxsIGV4Y2VlZCBicm93c2VyIG1heGltdW0uIExlbmd0aDogXCIgKyBzZXJpYWxpemVkQ29va2llLmxlbmd0aFxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHNlcmlhbGl6ZWRDb29raWU7XG4gICAgfSxcbiAgICBhc3luYyBkZXN0cm95U2Vzc2lvbihfc2Vzc2lvbiwgb3B0aW9ucykge1xuICAgICAgcmV0dXJuIGNvb2tpZS5zZXJpYWxpemUoXCJcIiwge1xuICAgICAgICAuLi5vcHRpb25zLFxuICAgICAgICBtYXhBZ2U6IHZvaWQgMCxcbiAgICAgICAgZXhwaXJlczogLyogQF9fUFVSRV9fICovIG5ldyBEYXRlKDApXG4gICAgICB9KTtcbiAgICB9XG4gIH07XG59XG5cbi8vIGxpYi9zZXJ2ZXItcnVudGltZS9zZXNzaW9ucy9tZW1vcnlTdG9yYWdlLnRzXG5mdW5jdGlvbiBjcmVhdGVNZW1vcnlTZXNzaW9uU3RvcmFnZSh7IGNvb2tpZSB9ID0ge30pIHtcbiAgbGV0IG1hcCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gIHJldHVybiBjcmVhdGVTZXNzaW9uU3RvcmFnZSh7XG4gICAgY29va2llLFxuICAgIGFzeW5jIGNyZWF0ZURhdGEoZGF0YTIsIGV4cGlyZXMpIHtcbiAgICAgIGxldCBpZCA9IE1hdGgucmFuZG9tKCkudG9TdHJpbmcoMzYpLnN1YnN0cmluZygyLCAxMCk7XG4gICAgICBtYXAuc2V0KGlkLCB7IGRhdGE6IGRhdGEyLCBleHBpcmVzIH0pO1xuICAgICAgcmV0dXJuIGlkO1xuICAgIH0sXG4gICAgYXN5bmMgcmVhZERhdGEoaWQpIHtcbiAgICAgIGlmIChtYXAuaGFzKGlkKSkge1xuICAgICAgICBsZXQgeyBkYXRhOiBkYXRhMiwgZXhwaXJlcyB9ID0gbWFwLmdldChpZCk7XG4gICAgICAgIGlmICghZXhwaXJlcyB8fCBleHBpcmVzID4gLyogQF9fUFVSRV9fICovIG5ldyBEYXRlKCkpIHtcbiAgICAgICAgICByZXR1cm4gZGF0YTI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGV4cGlyZXMpIG1hcC5kZWxldGUoaWQpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSxcbiAgICBhc3luYyB1cGRhdGVEYXRhKGlkLCBkYXRhMiwgZXhwaXJlcykge1xuICAgICAgbWFwLnNldChpZCwgeyBkYXRhOiBkYXRhMiwgZXhwaXJlcyB9KTtcbiAgICB9LFxuICAgIGFzeW5jIGRlbGV0ZURhdGEoaWQpIHtcbiAgICAgIG1hcC5kZWxldGUoaWQpO1xuICAgIH1cbiAgfSk7XG59XG5cbi8vIGxpYi9kb20vc3NyL2Vycm9ycy50c1xuZnVuY3Rpb24gZGVzZXJpYWxpemVFcnJvcnMyKGVycm9ycykge1xuICBpZiAoIWVycm9ycykgcmV0dXJuIG51bGw7XG4gIGxldCBlbnRyaWVzID0gT2JqZWN0LmVudHJpZXMoZXJyb3JzKTtcbiAgbGV0IHNlcmlhbGl6ZWQgPSB7fTtcbiAgZm9yIChsZXQgW2tleSwgdmFsXSBvZiBlbnRyaWVzKSB7XG4gICAgaWYgKHZhbCAmJiB2YWwuX190eXBlID09PSBcIlJvdXRlRXJyb3JSZXNwb25zZVwiKSB7XG4gICAgICBzZXJpYWxpemVkW2tleV0gPSBuZXcgRXJyb3JSZXNwb25zZUltcGwoXG4gICAgICAgIHZhbC5zdGF0dXMsXG4gICAgICAgIHZhbC5zdGF0dXNUZXh0LFxuICAgICAgICB2YWwuZGF0YSxcbiAgICAgICAgdmFsLmludGVybmFsID09PSB0cnVlXG4gICAgICApO1xuICAgIH0gZWxzZSBpZiAodmFsICYmIHZhbC5fX3R5cGUgPT09IFwiRXJyb3JcIikge1xuICAgICAgaWYgKHZhbC5fX3N1YlR5cGUpIHtcbiAgICAgICAgbGV0IEVycm9yQ29uc3RydWN0b3IgPSB3aW5kb3dbdmFsLl9fc3ViVHlwZV07XG4gICAgICAgIGlmICh0eXBlb2YgRXJyb3JDb25zdHJ1Y3RvciA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGxldCBlcnJvciA9IG5ldyBFcnJvckNvbnN0cnVjdG9yKHZhbC5tZXNzYWdlKTtcbiAgICAgICAgICAgIGVycm9yLnN0YWNrID0gdmFsLnN0YWNrO1xuICAgICAgICAgICAgc2VyaWFsaXplZFtrZXldID0gZXJyb3I7XG4gICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHNlcmlhbGl6ZWRba2V5XSA9PSBudWxsKSB7XG4gICAgICAgIGxldCBlcnJvciA9IG5ldyBFcnJvcih2YWwubWVzc2FnZSk7XG4gICAgICAgIGVycm9yLnN0YWNrID0gdmFsLnN0YWNrO1xuICAgICAgICBzZXJpYWxpemVkW2tleV0gPSBlcnJvcjtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgc2VyaWFsaXplZFtrZXldID0gdmFsO1xuICAgIH1cbiAgfVxuICByZXR1cm4gc2VyaWFsaXplZDtcbn1cbi8vIEFubm90YXRlIHRoZSBDb21tb25KUyBleHBvcnQgbmFtZXMgZm9yIEVTTSBpbXBvcnQgaW4gbm9kZTpcbjAgJiYgKG1vZHVsZS5leHBvcnRzID0ge1xuICBBd2FpdCxcbiAgQnJvd3NlclJvdXRlcixcbiAgRm9ybSxcbiAgSGFzaFJvdXRlcixcbiAgSURMRV9CTE9DS0VSLFxuICBJRExFX0ZFVENIRVIsXG4gIElETEVfTkFWSUdBVElPTixcbiAgTGluayxcbiAgTGlua3MsXG4gIE1lbW9yeVJvdXRlcixcbiAgTWV0YSxcbiAgTmF2TGluayxcbiAgTmF2aWdhdGUsXG4gIE5hdmlnYXRpb25UeXBlLFxuICBPdXRsZXQsXG4gIFByZWZldGNoUGFnZUxpbmtzLFxuICBSb3V0ZSxcbiAgUm91dGVyLFxuICBSb3V0ZXJQcm92aWRlcixcbiAgUm91dGVzLFxuICBTY3JpcHRzLFxuICBTY3JvbGxSZXN0b3JhdGlvbixcbiAgU2VydmVyUm91dGVyLFxuICBTdGF0aWNSb3V0ZXIsXG4gIFN0YXRpY1JvdXRlclByb3ZpZGVyLFxuICBVTlNBRkVfRGF0YVJvdXRlckNvbnRleHQsXG4gIFVOU0FGRV9EYXRhUm91dGVyU3RhdGVDb250ZXh0LFxuICBVTlNBRkVfRXJyb3JSZXNwb25zZUltcGwsXG4gIFVOU0FGRV9GZXRjaGVyc0NvbnRleHQsXG4gIFVOU0FGRV9GcmFtZXdvcmtDb250ZXh0LFxuICBVTlNBRkVfTG9jYXRpb25Db250ZXh0LFxuICBVTlNBRkVfTmF2aWdhdGlvbkNvbnRleHQsXG4gIFVOU0FGRV9SZW1peEVycm9yQm91bmRhcnksXG4gIFVOU0FGRV9Sb3V0ZUNvbnRleHQsXG4gIFVOU0FGRV9TZXJ2ZXJNb2RlLFxuICBVTlNBRkVfU2luZ2xlRmV0Y2hSZWRpcmVjdFN5bWJvbCxcbiAgVU5TQUZFX1ZpZXdUcmFuc2l0aW9uQ29udGV4dCxcbiAgVU5TQUZFX2NyZWF0ZUJyb3dzZXJIaXN0b3J5LFxuICBVTlNBRkVfY3JlYXRlQ2xpZW50Um91dGVzLFxuICBVTlNBRkVfY3JlYXRlQ2xpZW50Um91dGVzV2l0aEhNUlJldmFsaWRhdGlvbk9wdE91dCxcbiAgVU5TQUZFX2NyZWF0ZVJvdXRlcixcbiAgVU5TQUZFX2RlY29kZVZpYVR1cmJvU3RyZWFtLFxuICBVTlNBRkVfZGVzZXJpYWxpemVFcnJvcnMsXG4gIFVOU0FGRV9nZXRQYXRjaFJvdXRlc09uTmF2aWdhdGlvbkZ1bmN0aW9uLFxuICBVTlNBRkVfZ2V0U2luZ2xlRmV0Y2hEYXRhU3RyYXRlZ3ksXG4gIFVOU0FGRV9pbnZhcmlhbnQsXG4gIFVOU0FGRV9tYXBSb3V0ZVByb3BlcnRpZXMsXG4gIFVOU0FGRV9zaG91bGRIeWRyYXRlUm91dGVMb2FkZXIsXG4gIFVOU0FGRV91c2VGb2dPRldhckRpc2NvdmVyeSxcbiAgVU5TQUZFX3VzZVNjcm9sbFJlc3RvcmF0aW9uLFxuICBjcmVhdGVCcm93c2VyUm91dGVyLFxuICBjcmVhdGVDb29raWUsXG4gIGNyZWF0ZUNvb2tpZVNlc3Npb25TdG9yYWdlLFxuICBjcmVhdGVIYXNoUm91dGVyLFxuICBjcmVhdGVNZW1vcnlSb3V0ZXIsXG4gIGNyZWF0ZU1lbW9yeVNlc3Npb25TdG9yYWdlLFxuICBjcmVhdGVQYXRoLFxuICBjcmVhdGVSZXF1ZXN0SGFuZGxlcixcbiAgY3JlYXRlUm91dGVzRnJvbUNoaWxkcmVuLFxuICBjcmVhdGVSb3V0ZXNGcm9tRWxlbWVudHMsXG4gIGNyZWF0ZVJvdXRlc1N0dWIsXG4gIGNyZWF0ZVNlYXJjaFBhcmFtcyxcbiAgY3JlYXRlU2Vzc2lvbixcbiAgY3JlYXRlU2Vzc2lvblN0b3JhZ2UsXG4gIGNyZWF0ZVN0YXRpY0hhbmRsZXIsXG4gIGNyZWF0ZVN0YXRpY1JvdXRlcixcbiAgZGF0YSxcbiAgZ2VuZXJhdGVQYXRoLFxuICBpc0Nvb2tpZSxcbiAgaXNSb3V0ZUVycm9yUmVzcG9uc2UsXG4gIGlzU2Vzc2lvbixcbiAgbWF0Y2hQYXRoLFxuICBtYXRjaFJvdXRlcyxcbiAgcGFyc2VQYXRoLFxuICByZWRpcmVjdCxcbiAgcmVkaXJlY3REb2N1bWVudCxcbiAgcmVuZGVyTWF0Y2hlcyxcbiAgcmVwbGFjZSxcbiAgcmVzb2x2ZVBhdGgsXG4gIHVuc3RhYmxlX0hpc3RvcnlSb3V0ZXIsXG4gIHVuc3RhYmxlX3NldERldlNlcnZlckhvb2tzLFxuICB1bnN0YWJsZV91c2VQcm9tcHQsXG4gIHVzZUFjdGlvbkRhdGEsXG4gIHVzZUFzeW5jRXJyb3IsXG4gIHVzZUFzeW5jVmFsdWUsXG4gIHVzZUJlZm9yZVVubG9hZCxcbiAgdXNlQmxvY2tlcixcbiAgdXNlRmV0Y2hlcixcbiAgdXNlRmV0Y2hlcnMsXG4gIHVzZUZvcm1BY3Rpb24sXG4gIHVzZUhyZWYsXG4gIHVzZUluUm91dGVyQ29udGV4dCxcbiAgdXNlTGlua0NsaWNrSGFuZGxlcixcbiAgdXNlTG9hZGVyRGF0YSxcbiAgdXNlTG9jYXRpb24sXG4gIHVzZU1hdGNoLFxuICB1c2VNYXRjaGVzLFxuICB1c2VOYXZpZ2F0ZSxcbiAgdXNlTmF2aWdhdGlvbixcbiAgdXNlTmF2aWdhdGlvblR5cGUsXG4gIHVzZU91dGxldCxcbiAgdXNlT3V0bGV0Q29udGV4dCxcbiAgdXNlUGFyYW1zLFxuICB1c2VSZXNvbHZlZFBhdGgsXG4gIHVzZVJldmFsaWRhdG9yLFxuICB1c2VSb3V0ZUVycm9yLFxuICB1c2VSb3V0ZUxvYWRlckRhdGEsXG4gIHVzZVJvdXRlcyxcbiAgdXNlU2VhcmNoUGFyYW1zLFxuICB1c2VTdWJtaXQsXG4gIHVzZVZpZXdUcmFuc2l0aW9uU3RhdGVcbn0pO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/react-router/dist/development/index.js\n");

/***/ })

};
;